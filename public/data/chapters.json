[
  {
    "id": "b1_ch1",
    "title": "第1章：程式設計基礎",
    "number": 1,
    "content": {
      "intro": {
        "title": "第 1 章：程式設計初階 - 重點詳解 (Detail)",
        "roadmap": {
          "guide": "本章節為 Python 程式設計的起點，涵蓋了從環境建置到基礎資料結構的實用操作。",
          "objectives": "*   掌握 Spyder IDE 互動式開發環境的使用。\n*   理解 Python 變數與基礎數值類型的存儲邏輯。\n*   熟悉 **List (列表)** 與 **Dict (字典)** 的基本操作與金融應用。",
          "topics": "*   1.1 Python 介紹與環境安裝\n*   1.2 Spyder IDE 操作介面熟悉\n*   1.3 變數定義與數值類型應用\n*   1.4 資料序列概念理解\n*   1.5 列表 (List) 增刪改查操作\n*   1.6 元組 (Tuple)、集合 (Set) 與字典 (Dict) 實作"
        },
        "value": {
          "practical": "*   **實務場景**：環境佈署與基礎行情數據抓取腳本的撰寫。\n*   **考試重點**：理解基本邏輯運算在風險閾值觸發（Trigger）中的應用。",
          "theory": "",
          "further_reading": ""
        },
        "implementation": {
          "python": "",
          "logic": "",
          "scenarios": "| 腳本名稱 | 核心使命 |\n| :--- | :--- |\n| **B1_Ch1_1.py** | 實作隨機整數矩陣生成與本地數據檔案 (data.txt) 寫入操作。 |\n| **B1_Ch1_2.py** | 實作異常處理與輸入驗證，演示 try...except 捕捉非整數輸入。 |\n| **B1_Ch1_3.py** | 定義 Vasicek 利率模型函數，演示基礎隨機微分方程的編碼實現。 |\n| **B1_Ch1_4.py** | 演示函數長名稱定義與代碼風格規範。 |\n| **B1_Ch1_5.py** | 實作類別 (Class) 基礎：定義簡單方法並實體化對象。 |\n| **B1_Ch1_6.py** | 演示浮點數精確度與科學記數法的處理方式。 |\n| **B1_Ch1_7.py** | 演示隱式類型轉換 (Implicit Type Conversion) 的運算規則。 |\n| **B1_Ch1_8.py** | 演示字典 (Dictionary) 的鍵值對索引與訪問方法。 |\n| **B1_Ch1_9.py** | 使用 time 模組記錄列表操作的執行時間，進行效能評估。 |\n| **B1_Ch1_10.py** | 演示 list.insert() 函數在列表特定位置插入元素的用法。 |\n| **B1_Ch1_11.py** | 比較 del, remove(), 與 pop() 在刪除列表元素時的差異。 |\n| **B1_Ch1_12.py** | 演示 list.index() 函數查找元素索引與處理不存在值的邏輯。 |\n| **B1_Ch1_13.py** | 基礎列表推導式 (List Comprehension) 應用：生成數階列表。 |\n| **B1_Ch1_14.py** | 定義角度轉弧度 (convertDeg) 函數，演示基礎數學運算封装。 |\n| **B1_Ch1_15.py** | 實現半徑過濾器 (radius_filter)，演示列表篩選邏輯。 |\n| **B1_Ch1_16.py** | 演示嵌套迴圈 (Nested Loop) 在矩陣遍歷中的應用。 |\n| **B1_Ch1_17.py** | 演示集合 (Set) 的唯一性特徵及其在數據去重中的應用。 |\n| **B1_Ch1_18.py** | 演示如何將兩個列表 (Keys and Values) 合併為一個字典。 |\n| **B1_Ch1_19.py** | 演示 dict.fromkeys() 批量初始化具有相同初值的字典元素。 |\n| **B1_Ch1_20.py** | 進階列表推導式應用：結合條件判斷進行元素轉換。 |\n| **B1_Ch1_21.py** | 演示字典推導式 (Dictionary Comprehension) 的高效寫法。 |"
        },
        "body": "### 1.1 Python 介紹與環境安裝\n\n#### 概念定義\nPython 是一種高階、直譯式、動態類型的程式語言，由 Guido van Rossum 於 1991 年發布。其設計哲學強調**代碼可讀性**與**簡潔語法**，使開發者能用更少的程式碼完成任務。\n\n#### 財金理論背景\n在金融風險管理領域，Python 已成為量化分析的標準工具。原因包括：\n- **開源生態系**：Pandas、NumPy、SciPy 等套件免費且持續更新\n- **快速原型開發**：適合策略回測與模型驗證\n- **產業採用**：Bloomberg、Goldman Sachs 等機構皆使用 Python 進行風險建模\n\n#### Python 實現邏輯\n環境安裝建議使用 **Anaconda** 發行版：\n```python\n# 驗證安裝成功\nimport sys\nprint(sys.version)  # 應顯示 Python 3.x\n\n# 確認核心套件\nimport numpy as np\nimport pandas as pd\nprint(\"環境配置成功！\")\n```\n\n#### 常見陷阱與注意事項\n- **Python 2 vs 3**：請務必安裝 Python 3.x，Python 2 已於 2020 年停止支援\n- **PATH 環境變數**：Windows 安裝時務必勾選 \"Add Python to PATH\"\n- **套件版本衝突**：建議使用虛擬環境 (`conda create -n frm python=3.10`) 隔離專案\n\n#### 實務應用場景\n- 快速抓取行情數據並進行初步清洗\n- 建立自動化風險報表生成腳本\n- 開發客製化的交易策略回測框架\n\n#### 與其他章節的關聯\n本節建立的 Python 環境是後續所有章節的基礎，Ch3 NumPy 與 Ch5 Pandas 將進一步擴展數據處理能力。\n\n---\n\n### 1.2 Spyder IDE 操作介面熟悉\n\n#### 概念定義\nSpyder（Scientific Python Development Environment）是一個專為科學計算設計的開發環境，提供類似 MATLAB 的操作體驗，包含編輯器、變數瀏覽器與互動式控制台。\n\n#### 財金理論背景\n金融建模過程中，需要頻繁檢視中間變數（如矩陣維度、數據分佈）。Spyder 的**變數瀏覽器 (Variable Explorer)** 支援即時檢視陣列內容，大幅提升除錯效率，這是純文字編輯器難以替代的功能。\n\n#### Python 實現邏輯\nSpyder 核心功能區塊：\n| 區域 | 功能 | 金融應用 |\n|------|------|----------|\n| **Editor** | 程式碼編輯 | 撰寫定價模型 |\n| **IPython Console** | 互動執行 | 快速測試公式 |\n| **Variable Explorer** | 變數檢視 | 檢查報酬率矩陣維度 |\n| **Plots** | 圖形輸出 | 視覺化損益分佈 |\n\n#### 常見陷阱與注意事項\n- **執行範圍混淆**：`F5` 執行整個檔案，`F9` 僅執行選取區塊；初學者常混淆導致變數狀態不一致\n- **變數殘留問題**：上次執行的變數會保留在記憶體中，建議定期執行 `Remove all variables` 清除狀態\n- **Console 卡住**：長時間運算時 Console 會無回應，可按 `Ctrl+C` 中斷\n\n#### 實務應用場景\n- 逐行執行蒙地卡羅模擬，觀察每步結果\n- 使用 Variable Explorer 檢查 DataFrame 的缺失值數量\n- 快速繪製價格曲線驗證數據正確性\n\n#### 與其他章節的關聯\n熟悉 Spyder 後，Ch7 資料視覺化的圖形將直接顯示在 Plots 面板中，實現所見即所得的開發體驗。\n\n---\n\n### 1.3 變數定義與數值類型應用\n\n#### 概念定義\nPython 採用**動態類型系統**，變數無需事先宣告類型，直譯器會在執行時自動推斷。基礎數值類型包括：\n- `int`：任意精度整數\n- `float`：64 位元雙精度浮點數（遵循 IEEE 754 標準）\n- `complex`：複數（如 `3+4j`）\n\n#### 財金理論背景\n資料類型選擇直接影響計算精度與效能：\n- **價格數據**：使用 `float`，但需注意小數位精度\n- **交易口數**：使用 `int`，不應出現小數\n- **LIBOR 計息天數**：使用 `int`（如 ACT/360 的天數計算）\n\n#### 數學公式或模型\n浮點數遵循 IEEE 754 標準，有效位數約為 15-17 位：\n$$\n\\text{Machine Epsilon} \\approx 2.22 \\times 10^{-16}\n$$\n\n#### Python 實現邏輯\n```python\n# 類型檢查與轉換\nprice = 100.50      # float\nquantity = 1000     # int\nnotional = price * quantity  # 自動轉為 float\n\nprint(type(price))      # <class 'float'>\nprint(type(quantity))   # <class 'int'>\n\n# 強制轉換\nint_price = int(price)  # 100（截斷小數）\n```\n\n#### 常見陷阱與注意事項\n- **浮點數精度問題**：\n  ```python\n  >>> 0.1 + 0.2\n  0.30000000000000004  # 非精確 0.3！\n  ```\n  金融計算建議使用 `decimal.Decimal` 處理貨幣\n- **整數除法陷阱**：Python 3 中 `/` 返回 float，`//` 才是整數除法\n- **隱式轉換優先級**：`int + float → float`，可能導致非預期結果\n\n#### 實務應用場景\n計算投資組合總市值時，需確保各持倉市值為 `float` 類型再加總，避免整數截斷誤差。\n\n#### 與其他章節的關聯\n數值類型概念將在 Ch3 NumPy 中擴展為 `np.float64`、`np.int32` 等更精細的控制，Ch4 則涉及複數在選擇權定價中的應用。\n\n---\n\n### 1.4 資料序列概念理解\n\n#### 概念定義\n**序列 (Sequence)** 是 Python 中有序集合的抽象概念，支援：\n- **索引 (Indexing)**：`seq[0]` 存取第一個元素\n- **切片 (Slicing)**：`seq[1:4]` 取得子序列\n- **迭代 (Iteration)**：`for item in seq`\n\n常見序列類型：字串 (`str`)、列表 (`list`)、元組 (`tuple`)\n\n#### 財金理論背景\n金融時間序列本質上就是序列資料：\n- 每日收盤價序列\n- 利率期限結構 (Term Structure)\n- 歷史波動率視窗\n\n掌握序列操作是處理金融數據的基礎能力。\n\n#### Python 實現邏輯\n```python\n# 索引：正向與負向\nprices = [100, 101, 99, 102, 98]\nprint(prices[0])   # 100（第一個）\nprint(prices[-1])  # 98（最後一個）\n\n# 切片：[start:end:step]\nprint(prices[1:4])     # [101, 99, 102]\nprint(prices[::2])     # [100, 99, 98]（隔一取）\nprint(prices[::-1])    # [98, 102, 99, 101, 100]（反轉）\n```\n\n#### 常見陷阱與注意事項\n- **索引從 0 開始**：`prices[1]` 是第**二**個元素，非第一個\n- **切片不包含 end**：`prices[1:3]` 包含索引 1、2，不含 3\n- **負索引**：`-1` 表示最後一個，`-2` 表示倒數第二個\n\n#### 實務應用場景\n- 取得最近 N 天的價格：`prices[-N:]`\n- 計算滾動視窗報酬率時使用切片分割數據\n- 反轉序列用於時間倒序分析\n\n#### 與其他章節的關聯\n序列概念在 Ch3 NumPy 中擴展為多維陣列索引，Ch5 Pandas DataFrame 的 `.iloc[]` 與 `.loc[]` 即為序列索引的進階應用。\n\n---\n\n### 1.5 列表 (List) 增刪改查操作\n\n#### 概念定義\n**列表 (List)** 是 Python 最常用的可變序列，使用方括號 `[]` 定義，可包含不同類型元素。核心特性：\n- **可變 (Mutable)**：可原地修改內容\n- **有序 (Ordered)**：元素順序固定\n- **可重複**：允許相同值多次出現\n\n#### 財金理論背景\n列表常用於儲存：\n- 動態新增的交易紀錄\n- 非結構化的多資產組合\n- 中間計算結果的暫存\n\n#### Python 實現邏輯\n```python\nportfolio = [\"AAPL\", \"GOOGL\", \"MSFT\"]\n\n# 新增\nportfolio.append(\"TSLA\")          # 尾部新增\nportfolio.insert(1, \"AMZN\")       # 指定位置插入\n\n# 刪除\nportfolio.remove(\"MSFT\")          # 依值刪除（第一個匹配）\ndel portfolio[0]                  # 依索引刪除\npopped = portfolio.pop()          # 取出並移除最後一個\n\n# 修改\nportfolio[0] = \"NVDA\"             # 直接賦值\n\n# 查詢\nidx = portfolio.index(\"GOOGL\")    # 取得索引\nexists = \"AAPL\" in portfolio      # 存在檢查\n```\n\n#### 常見陷阱與注意事項\n- **`remove()` 僅刪除第一個匹配**：若有重複值，需用迴圈或列表推導式\n- **迭代時刪除**：\n  ```python\n  # 錯誤示範！會跳過元素\n  for item in portfolio:\n      if condition:\n          portfolio.remove(item)\n  \n  # 正確：使用列表推導式\n  portfolio = [item for item in portfolio if not condition]\n  ```\n- **淺拷貝問題**：`new_list = old_list` 僅複製參考，修改會影響原列表\n\n#### 實務應用場景\n- 動態建構交易訊號列表\n- 儲存蒙地卡羅模擬的每次試驗結果\n- 管理風險因子清單\n\n#### 與其他章節的關聯\n列表是 Ch3 NumPy 陣列的前身，但 NumPy 在數值運算效率上遠優於列表。Ch5 Pandas Series 可視為帶有標籤的強化版列表。\n\n---\n\n### 1.6 元組 (Tuple)、集合 (Set) 與字典 (Dict) 實作\n\n#### 概念定義\n\n| 類型 | 符號 | 特性 | 適用場景 |\n|------|------|------|----------|\n| **Tuple** | `()` | 不可變、有序 | 固定參數配置 |\n| **Set** | `{}` | 可變、無序、唯一 | 去重、集合運算 |\n| **Dict** | `{k:v}` | 可變、鍵唯一、O(1) 查找 | 映射表 |\n\n#### 財金理論背景\n- **Tuple**：適合存儲模型參數 (μ, σ)，防止意外修改\n- **Set**：快速篩選獨立交易對手或去重證券代碼\n- **Dict**：建立 Ticker → 公司資訊的映射，實現 O(1) 查詢效率\n\n#### Python 實現邏輯\n\n**Tuple（元組）**\n```python\n# 模型參數（不可變，防止誤改）\nparams = (0.05, 0.2, 1.0)  # (mu, sigma, T)\nmu, sigma, T = params       # 解包\n\n# 作為字典鍵（列表不行）\ncache = {(100, 0.2): 10.5}  # (strike, vol) → price\n```\n\n**Set（集合）**\n```python\n# 去重\ntickers = [\"AAPL\", \"GOOGL\", \"AAPL\", \"MSFT\"]\nunique_tickers = set(tickers)  # {'AAPL', 'GOOGL', 'MSFT'}\n\n# 集合運算\nportfolio_a = {\"AAPL\", \"GOOGL\", \"MSFT\"}\nportfolio_b = {\"GOOGL\", \"AMZN\", \"TSLA\"}\ncommon = portfolio_a & portfolio_b      # 交集：{'GOOGL'}\nall_stocks = portfolio_a | portfolio_b  # 聯集\nonly_a = portfolio_a - portfolio_b      # 差集\n```\n\n**Dict（字典）**\n```python\n# 建立映射\nstock_info = {\n    \"AAPL\": {\"name\": \"Apple\", \"sector\": \"Tech\"},\n    \"JPM\": {\"name\": \"JPMorgan\", \"sector\": \"Finance\"}\n}\n\n# O(1) 查詢\nprint(stock_info[\"AAPL\"][\"sector\"])  # Tech\n\n# 安全取值\nsector = stock_info.get(\"UNKNOWN\", {}).get(\"sector\", \"N/A\")\n```\n\n#### 常見陷阱與注意事項\n- **Tuple 單元素**：`(1)` 是整數，`(1,)` 才是元組\n- **Set 無序**：不能用索引存取，`my_set[0]` 會報錯\n- **Dict 鍵必須為 Hashable**：列表不能作為鍵，元組可以\n- **Dict 覆蓋**：重複鍵會覆蓋舊值，無警告\n\n#### 實務應用場景\n- **Tuple**：儲存交易訂單 (symbol, side, quantity, price)\n- **Set**：檢查投資組合是否包含特定產業的所有成分股\n- **Dict**：建立即時行情快取，提供毫秒級查詢\n\n#### 與其他章節的關聯\nDict 的概念延伸至 Ch5 Pandas DataFrame 的 column 標籤，以及 Ch6 的 groupby 操作。掌握這些基礎資料結構，是理解 Pandas 內部機制的關鍵。"
      }
    },
    "examples": [
      {
        "id": "ex1",
        "title": "1.1 B1_Ch1_1.py",
        "filename": "B1_Ch1_1.py",
        "code": "# B1_Ch1_1.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\nimport numpy as np\ndata =np.random.randint(100,size=16).reshape(4,4)\n\nwith open('data.txt', 'w') as outfile:\n    for row in data:\n        for column in row:\n            outfile.write(f'{column:3.0f}')\n        outfile.write('\\n')\n"
      },
      {
        "id": "ex2",
        "title": "1.2 B1_Ch1_2.py",
        "filename": "B1_Ch1_2.py",
        "code": "# B1_Ch1_2.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n# Indentation example\ndef is_prime(a):\n    if type(a) != int:\n        print(\"Your input is not an integer\")\n    if a <=3:\n        print(\"The input number is too small\")\n    else:\n        if a %2 ==0:\n            print(\"This is an even number\")\n        else:\n            b = int(a/2.)+1\n            for i in range(3,b,2):\n                if a % i ==0:\n                    print(\"The input number can be divided by %2d\"%i)\n                    break\n                if i>=b-2:\n                    print(\"The input number is a prime number\")\nis_prime(2)#Out: The input number is too small\nis_prime(16)#Out: This is an even number\nis_prime(81)#Out: The input number can be divided by  3\nis_prime(89)#Out: The input number is a prime number\n"
      },
      {
        "id": "ex3",
        "title": "1.3 B1_Ch1_3.py",
        "filename": "B1_Ch1_3.py",
        "code": "# B1_Ch1_3.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n# Add 4 spaces (an extra level of indentation) to distinguish arguments from the rest.\n#%%\n# Code cell: Vasicek Model\nimport numpy as np\nimport matplotlib.pyplot as plt\ndef vasicek(r0,k,theta,sigma, T=1., N=10,seed=500):\n    np.random.seed(seed)\n    dt = T/float(N)\n    rates = [r0]\n    for i in range(N):\n        dr = k*(theta-rates[-1])*dt+sigma*np.random.normal()\n        rates.append(rates[-1]+dr)\n    return range(N+1), rates\nx,y = vasicek(0.02,0.25,0.02,0.01,20.,500)\nfig,ax=plt.subplots()\nax.plot(x,y)\nax.set(xlabel='Time step',ylabel='Interest rate',title='Vasicek Model')\nplt.show()\n# %%\n# Code cell: CIR model\nimport math\nimport matplotlib.pyplot as plt\ndef cir(r0,k,theta,sigma,T=1.,N=10,seed=500):\n    np.random.seed(seed)\n    dt = T/float(N)\n    rates = [r0]\n    for i in range(N):\n        dr=k*(theta-rates[-1])*dt+\\\n            sigma*math.sqrt(rates[-1])*np.random.normal()\n        rates.append(rates[-1]+dr)\n    return range(N+1),rates\nx,y = cir(0.02,0.25,0.02,0.01,20,500)\nfig,ax=plt.subplots()\nax.plot(x,y)\nax.set(xlabel='Time step',ylabel='Interest rate',title='CIR model')\nplt.show()\n\n"
      },
      {
        "id": "ex4",
        "title": "1.4 B1_Ch1_4.py",
        "filename": "B1_Ch1_4.py",
        "code": "# B1_Ch1_4.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n# Add 4 spaces (an extra level of indentation) to distinguish arguments from the rest.\ndef long_func_name(\n        var1, \n        var2, \n        var3,\n        var4):\n    print(var1)\n\nvar1, var2, var3, var4 = 1, 2, 3,4\n# Aligned with opening delimiter.\nlong_func_name(var1, var2,\n               var3, var4)\n\n# Hanging indents should add a level.\nfoo = long_func_name(\n    var1, var2,\n    var3, var4)\n"
      },
      {
        "id": "ex5",
        "title": "1.5 B1_Ch1_5.py",
        "filename": "B1_Ch1_5.py",
        "code": "# B1_Ch1_5.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\nclass People(object):\n    def _eat(self):\n        print('I am eating')\n    def __run(self):\n        print('I can run')\n\nclass Student(People):\n    def torun(self):\n        self.__run() #AttributeError: 'Student' object has no attribute '_Student__run'\n\ns = Student()\ns.torun()  \np = People()\np.__run()   #error: it cannot be accessed externally\n"
      },
      {
        "id": "ex6",
        "title": "1.6 B1_Ch1_6.py",
        "filename": "B1_Ch1_6.py",
        "code": "# B1_Ch1_6.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n# Example 1, flaoting point\nprint((1.1 + 2.2) == 3.3)#Out:False\nprint(1.1+2.2)#Out: 3.3000000000000003\n\n# Example 2, fractions\nimport fractions\nprint(fractions.Fraction(1.5)) # Output: 3/2\nprint(fractions.Fraction(5)) # Output: 5\nprint(fractions.Fraction(1,3)) # Output: 1/3\n\n# Example 3, Bolleans\nx = (1 == True) # True and False are both case-sensitive\ny = (1 == False)\na = True + 4\nb = False + 10\nprint(\"x is\", x)\nprint(\"y is\", y)\nprint(\"a:\", a)\nprint(\"b:\", b)\nprint(bool(0))# Output False\na =[];\nb = ['']\nprint(bool(a))# Output False\nprint(bool(b))# Output True\nprint(bool(1))# Output True\nprint(bool(-1908))# Output True\nprint(bool(\"Hello!\"))# Output True\n"
      },
      {
        "id": "ex7",
        "title": "1.7 B1_Ch1_7.py",
        "filename": "B1_Ch1_7.py",
        "code": "# B1_Ch1_7.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n#Example1, implicit type conversion\nnum_int = 123\nnum_str = \"456\"\nprint(\"Data type of num_int:\",type(num_int))\nprint(\"Data type of num_str before Type Casting:\",type(num_str))\nnum_str = int(num_str)\nprint(\"Data type of num_str after Type Casting:\",type(num_str))\nnum_sum = num_int + num_str\nprint(\"Sum of num_int and num_str:\",num_sum)\nprint(\"Data type of the sum:\",type(num_sum))\n\n#Example2, implicit type conversion\nnum_flo = 1.23\nnum_new = num_int + num_flo\nprint(\"datatype of num_int:\",type(num_int))\nprint(\"datatype of num_flo:\",type(num_flo))\nprint(\"Value of num_new:\",num_new)\nprint(\"datatype of num_new:\",type(num_new))\n"
      },
      {
        "id": "ex8",
        "title": "1.8 B1_Ch1_8.py",
        "filename": "B1_Ch1_8.py",
        "code": "# B1_Ch1_8.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n#Indexing of a dictionary\nDict = {\"John\":20,\"Theresa\":22,\"Tom\":20}\nprint(Dict[\"Tom\"])#20\n\n#Indexing of a list, a string, a tuple\nList,String = [1,2,3],\"123\"\nTuple, Set= tuple(List),set(List)\nprint(List[1])#2\nprint(Tuple[1])#2\nprint(String[1])#2\nprint(Set[1])#'set' object is not subscriptable\n"
      },
      {
        "id": "ex9",
        "title": "1.9 B1_Ch1_9.py",
        "filename": "B1_Ch1_9.py",
        "code": "# B1_Ch1_9.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\nimport timeit\n# Record list execution time\nList_setup = 'List = range(10**6)'\nList_code = '10**6 in List'\nRun_number = 10**4 # PWA optimized (Original: 10**9)\nList_time = timeit.timeit(stmt=List_code, setup=List_setup, number=Run_number)\nprint(\"List execution time = %f\"%List_time)\n\n# Record tuple execution time\nTuple_setup = 'Tuple = set(range(10**6))'\nTuple_code = '10**6 in Tuple'\nTuple_time = timeit.timeit(stmt=Tuple_code, setup=Tuple_setup, number=Run_number)\nprint(\"Tuple execution time = %f\"%Tuple_time)\n\n# Size comparison of a list and a tuple\nList = list(range(10**6))\nTuple = tuple(range(10**6))\nprint(\"Size of the list is %d\"%List.__sizeof__())# 8000040\nprint(\"Size of the tuple is %d\"%Tuple.__sizeof__())#8000024\n"
      },
      {
        "id": "ex10",
        "title": "1.10 B1_Ch1_10.py",
        "filename": "B1_Ch1_10.py",
        "code": "# B1_Ch1_10.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n#%% insert()function\naList = [123, 'xyz', 'zara', 'abc']\naList.insert( 3, 2009)\nprint (\"Final List : \", aList) # Out: Final List :  [123, 'xyz', 'zara', 2009, 'abc']\n#%% append()function\nlist1 = ['James', 'Bryant', 'Anthony']\nlist2= ['Lisa','Jack','Wade']\nlist1.extend(list2)  \nprint (\"The extened list is：\", list1)\n#%% extend() function\n#%% extend() function\nE1 = ['a', 'b', 'c']\nA1 = ['a', 'b', 'c']\nt = ['d', 'e']\nE1.append(t)\nA1.extend(t)\nprint(E1)\nprint(A1)\n"
      },
      {
        "id": "ex11",
        "title": "1.11 B1_Ch1_11.py",
        "filename": "B1_Ch1_11.py",
        "code": "# B1_Ch1_11.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n#%% Ways to delete elements in a list\n# pop() function\nt = ['a','b','c','d','e','f']\nx = t.pop(1)\nprint(t) # Out: ['a','c','d','e','f']\nprint(x) # Out: b\n\n# del() function\ndel t[1]\nprint(t) # Out: ['a','d','e','f']\ndel t[1:3]\nprint(t) # Out: ['a','f']\n\n# remove() function\nt.remove('a')\nprint(t) # Out: ['f']\n"
      },
      {
        "id": "ex12",
        "title": "1.12 B1_Ch1_12.py",
        "filename": "B1_Ch1_12.py",
        "code": "# B1_Ch1_12.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n#%% Example #1 shows how to use index() function\nguests = ['Christopher','Susan','Bill','Satya']\n\n#this will return the index in the list \n#where the name Bill is found \nprint(guests.index('Bill'))\naList = [123, 'xyz', 'zara', 'abc'];\nprint (\"Index for xyz : \", aList.index( 'xyz' ))\nprint (\"Index for zara : \", aList.index( 'zara' ))\n# Out:Index for xyz :  1\n# Out: Index for zara :  2\n\n#%% Example #2 shows how to use count() function\naList = [123, 'xyz', 'zara', 'abc', 123];\nprint (\"Count for 123 : \", aList.count(123))\nprint (\"Count for zara : \", aList.count('zara'))\n# Out: Count for 123 : 2\n# Out: Count for zara : 1\n\n#%% Example #3 shows how to use min() function\nlist1, list2 = [123, 'xyz', 'zara', 'abc'], [456, 700, 200]\nprint (\"min value element : \", min(list2))\nprint (\"min value element : \", min(list1)) # error\n\n#%% Example#4 shows how to use sort() function\naList = ['xyz', 'zara', 'abc', 'xyz']\naList.sort()\nprint (\"List : \", aList) # Out: List :  ['abc', 'xyz', 'xyz', 'zara']\n"
      },
      {
        "id": "ex13",
        "title": "1.13 B1_Ch1_13.py",
        "filename": "B1_Ch1_13.py",
        "code": "# B1_Ch1_13.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n# List comprehension example #1\nh_letters = [ letter for letter in 'human' ]\nprint( h_letters)#Out: ['h', 'u', 'm', 'a', 'n']\n# List comprehension example #2\nnumber_list = [ x for x in range(20) if x % 2 == 0]\nprint(number_list) # Out: [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]\n# List comprehension example #3\nnum_list = [y for y in range(100) if y % 2 == 0 if y % 5 == 0]\nprint(num_list)# Out: [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]\n# List comprehension example #4\nh_letters = list(map(lambda x: x, 'human'))\nprint(h_letters)# Out: ['h', 'u', 'm', 'a', 'n']\n"
      },
      {
        "id": "ex14",
        "title": "1.14 B1_Ch1_14.py",
        "filename": "B1_Ch1_14.py",
        "code": "# B1_Ch1_14.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n#%% Define a function explicitly for creating a list\ndef convertDeg(degrees):\n    converted = [ ]\n    for degree in degrees:\n        result = (9/5) * degree + 32\n        converted.append(result)\n    return converted\ntemps = [ 15, 20, 25, 30 ]\nconverted_temps = convertDeg(temps)\nprint(converted_temps)\n\n#%% List comprehension with lambda() and map() functions\nDegree_C = [ 15, 20, 25, 30 ]\nDegree_F = list( map( lambda C : (9/5) * C + 32,temps) ) \nprint(Degree_F)\n"
      },
      {
        "id": "ex15",
        "title": "1.15 B1_Ch1_15.py",
        "filename": "B1_Ch1_15.py",
        "code": "# B1_Ch1_15.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n#%% Use a explicit function for filtering\ndef radius_filter(r):\n    return True if 3.14*r**2 > 10 else False\nRadius = [ 1, 2, 5, 10 ]\nr_filter = filter(radius_filter,Radius)\nprint(r_filter)\nprint(list(r_filter))\n#%% List comprehension with lambada() and filter()function, full form\nRadius = [ 1, 2, 5, 10 ]\nRadius_filtered = list( filter( lambda r : 3.14*r**2 > 10, Radius) ) # type convert the filter\nprint(Radius_filtered)\n#%% List comprehension with lambada() and filter()function, simplified form\nRadius = [ 1, 2, 5, 10 ]\nDegree_C_filtered = list( filter( lambda r : 3.14*r**2 > 10, Radius) )\nprint(Radius_filtered)\n"
      },
      {
        "id": "ex16",
        "title": "1.16 B1_Ch1_16.py",
        "filename": "B1_Ch1_16.py",
        "code": "# B1_Ch1_16.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n# Nested loop\nList1 = []\nfor x in [1, 2]:\n    for y in [4, 5]:\n        List1.append(x * y)\n\nprint(List1)# Out: [4, 5, 8, 10]\n\n# Nested loop is replaced by comprehension\n\nList2 = [x * y for x in [1, 2] for y in [4, 5]]\nprint(List2)# Out: [4, 5, 8, 10]\n"
      },
      {
        "id": "ex17",
        "title": "1.17 B1_Ch1_17.py",
        "filename": "B1_Ch1_17.py",
        "code": "# B1_Ch1_17.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n# Set cannot hold duplicated elements\nList = [1,1,2,2,3,3,4,4,5,10,10]\nA = set(List)\nprint(A)#{1, 2, 3, 4, 5, 10}\nB = set(range(6))\nprint(B)#{0, 1, 2, 3, 4, 5}\n#set union\nprint(A|B)#{0, 1, 2, 3, 4, 5, 10}\nprint(A.union(B))#{0, 1, 2, 3, 4, 5, 10}\n#set intersection\nprint(A&B)#{1, 2, 3, 4, 5}\nprint(A.intersection(B))#{1, 2, 3, 4, 5}\n#set set difference\nprint(B-A)#{0}\nprint(B.difference(A))#{0}\n#set set symmetric difference\nprint(A^B)#{0, 10}\nprint(A.symmetric_difference(B))#{0, 10}\n"
      },
      {
        "id": "ex18",
        "title": "1.18 B1_Ch1_18.py",
        "filename": "B1_Ch1_18.py",
        "code": "# B1_Ch1_18.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n#%% create a dictionary using two lists\nkeys = [\"Jack\", \"John\", \"Josh\"] \nvalues = [20, 25, 22]\nstu = dict(zip(keys, values))\nprint (\"Students' names and ages are' : \" +  str(stu))\n#Students' names and ages are' : {'Jack': 20, 'John': 25, 'Josh': 22}\n#%% create a dictionary using two tuples\nkeys = tuple([\"Jack\", \"John\", \"Josh\"])\nvalues = tuple([20, 25, 22])\nstu = dict(zip(keys, values))\nprint (\"Students' names and ages are' : \" +  str(stu))\n#Students' names and ages are' : {'Jack': 20, 'John': 25, 'Josh': 22}\n#%% create a dictionary using two sets\nkeys = set([\"Jack\", \"John\", \"Josh\"])\nvalues = set([20, 25, 22])\nstu = dict(zip(keys, values))\nprint (\"Students' names and ages are' : \" +  str(stu))\n#Students' names and ages are' : {'Josh': 25, 'John': 20, 'Jack': 22}\n"
      },
      {
        "id": "ex19",
        "title": "1.19 B1_Ch1_19.py",
        "filename": "B1_Ch1_19.py",
        "code": "# B1_Ch1_19.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n#%%fromkeys()\nkeys =(\"brand\",\"model\",\"year\")\nvalues =(\"Ford\",\"Mustang\",\"2020\")\ncar =dict.fromkeys(keys,values)\nprint(car)\n#%%values()\nprint(car.values())\n#%%keys()\nprint(car.keys())\n#%%pop()method\nprint(car.pop(\"model\"))\nprint(car)\n#%%popitem()method\nprint(car.popitem())\n#%%items()\nprint(car.items())\n#%%There are two ways to update the values\ncar.update({\"color\": \"White\"})\ncar[\"brand\"]=\"BMW\"\nprint(car)\n#%%Get the value for a specific key\nprint(car.get(\"model\"))\nprint(car[\"year\"])\n"
      },
      {
        "id": "ex20",
        "title": "1.20 B1_Ch1_20.py",
        "filename": "B1_Ch1_20.py",
        "code": "# B1_Ch1_20.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\na = [0, 1, 2, 3]\n# List comprehension\nList_comprehension = [i*10 for i in a]\nprint(List_comprehension)\n# Set comprehension\nSet_comprehension = {i*10 for i in a}\nprint(Set_comprehension)\n# Tuple comprehension\nTuple_comprehension = (i*10 for i in a)\nprint(Tuple_comprehension)\n# Dictionary comprehension\nDic_comprehension = {x: x**2 for x in (1, 2, 3)}\nprint(Dic_comprehension)\nprint(type(List_comprehension))#Out: <class 'list'>\nprint(type(Set_comprehension))#Out: <class 'set'>\nprint(type(Tuple_comprehension))#Out: <class 'generator'>\nprint(type(Dic_comprehension))#Out: <class 'dict'>\nprint(next(Tuple_comprehension))#0\nprint(next(Tuple_comprehension))#10\nprint(next(Tuple_comprehension))#20\nprint(next(Tuple_comprehension))#30\n"
      },
      {
        "id": "ex21",
        "title": "1.21 B1_Ch1_21.py",
        "filename": "B1_Ch1_21.py",
        "code": "# B1_Ch1_21.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n#%% Dictionary comprehension example\nfruits = ['apple', 'mango', 'banana','cherry']\nDict1 = {f:len(f) for f in fruits}\nprint(Dict1)#{'apple': 5, 'mango': 5, 'banana': 6, 'cherry': 6}\nDict2 = {f:i for i,f in enumerate(fruits)}\nDict3 = {v:k for k,v in Dict2.items()}\nprint(Dict2)#{'apple': 0, 'mango': 1, 'banana': 2, 'cherry': 3}\nprint(Dict3)#{0: 'apple', 1: 'mango', 2: 'banana', 3: 'cherry'}\nRemove_dict = {0,1}\nDict_updated = {key:fruits[key] for key in Dict3.keys()-Remove_dict}\nprint(Dict_updated)#{2: 'banana', 3: 'cherry'}\n"
      }
    ]
  },
  {
    "id": "b1_ch2",
    "title": "第2章：程式設計基礎 II",
    "number": 2,
    "content": {
      "intro": {
        "title": "第 2 章：程式設計基礎 II - 詳解",
        "roadmap": {
          "guide": "本章深入探討程式邏輯自動化。掌握字串格式化、控制流程（if/for/while）以及函數化編程，將單點的運算串聯成自動化的分析流程。",
          "objectives": "*   熟練運用字串處理與多樣化格式化輸出。\n*   掌握條與迴圈控流程於財金模型中的邏輯應用。\n*   理解函數封裝與異常處理在實務系統中的重要性。",
          "topics": "*   2.1 字串處理與格式化\n*   2.2 運算子與邏輯運算\n*   2.3 關鍵字與變數複製 (Copy vs Deepcopy)\n*   2.4 條件與迴圈敘述 (if, for, while)\n*   2.5 迭代器與生成器應用\n*   2.6 檔案讀寫操作 (.txt, .csv)\n*   2.7 函數定義、參數與回傳值\n*   2.8 異常處理 (try-except) 與錯誤排除"
        },
        "value": {
          "practical": "*   **實務場景**：編寫一個自動監控程序，當資產價值跌破限額時自動發送通知。\n*   **考試重點**：決策樹邏輯在信用評等（Credit Rating）流程中的 Python 實現。",
          "theory": "*   **情境分析 (Scenario Analysis)**：透過 `if...elif...else` 邏輯，實現不同市場情境（如：牛市、熊市、盤整）下不同策略路徑的自動選擇。\n*   **壓力測試邏輯**：利用迴圈（`for`）遍歷多個風險因子變化程度，計算組合價值變動。",
          "further_reading": "*   裝飾器 (Decorators)：為函數增加執行時間監控或日誌記錄功能。"
        },
        "implementation": {
          "python": "*   **自動化報告**：利用 `f-string` 或 `.format()` 自動生成格式化的風險分析日報。\n*   **異常處理**：`try...except` 確保在抓取行情斷線或存取非法日期時，程序不會直接崩潰，這對高頻交易系統至關重要。",
          "logic": "*   `def function()`：將常用的 VaR 計算或 Beta 計算封裝，實現代碼重用。\n*   `with open()`：標準的檔案 I/O，讀取本地存儲的資產配置表或存儲分析結果。",
          "scenarios": "| 腳本名稱 | 核心使命 |\n| :--- | :--- |\n| **B1_Ch2_1.py** | 實作字串操作與格式化輸出排版。 |\n| **B1_Ch2_2.py** | 實作字串內建函數 (upper, lower, replace) 的金融報表格式化。 |\n| **B1_Ch2_3.py** | 演示邏輯運算符 (and, or, not) 的真值表驗證。 |\n| **B1_Ch2_4.py** | 演示複合數據類型（列表嵌套字典）的結構設計。 |\n| **B1_Ch2_5.py** | 實作列表切片 (Slicing) 技術，實現數據子集的快速提取。 |\n| **B1_Ch2_6.py** | 演示多維列表的索引訪問與元素修改邏輯。 |\n| **B1_Ch2_7.py** | 基礎控制流程演練：if...else 條件分支設計。 |\n| **B1_Ch2_8.py** | 演示區間判斷邏輯及其在信用評等矩陣中的應用。 |\n| **B1_Ch2_9.py** | 利用字典模擬 Switch-Case 結構，實現數據的映射查找。 |\n| **B1_Ch2_10.py** | 實作質數判別函數 (func_get_prime)，演示數學邏輯編程。 |\n| **B1_Ch2_11.py** | 演示 enumerate() 在列表遍歷與條件匹配中的高級用法。 |\n| **B1_Ch2_12.py** | 演示列表作為可迭代對象 (Iterable) 的循環處理邏輯。 |\n| **B1_Ch2_13.py** | 定義費波那契數列 (Fibonacci) 生成函數，演示遞迴與迭代。 |\n| **B1_Ch2_14.py** | 利用 NumPy 的 random.randn 生成服從標準正態分佈的隨機變數。 |\n| **B1_Ch2_15.py** | 實作二進位數據檔案的讀取與二維數據結構重建。 |\n| **B1_Ch2_16.py** | 演示文本檔案的按行讀取與字串清理操作。 |\n| **B1_Ch2_17.py** | 演示函數區域變數與全域變數的作用域差異。 |\n| **B1_Ch2_18.py** | 實作多層 if-elif 邏輯判斷，並結合輸入範圍校驗。 |"
        },
        "body": "### 2.1 字串處理與格式化\n\n#### 概念定義\n字串 (String) 是 Python 中的不可變序列，用於表示文字數據。字串格式化則是將變數動態嵌入文字的技術，現代 Python 推薦使用 **f-string**（格式化字串字面值）。\n\n#### 財金理論背景\n金融數據常包含非結構化文本：\n- 公司公告與財報摘要\n- 交易對手名稱標準化\n- 即時新聞情緒分析前處理\n\n字串處理是自然語言處理 (NLP) 在金融應用的基礎。\n\n#### Python 實現邏輯\n```python\n# 常用字串方法\nticker = \"  AAPL.US  \"\nclean = ticker.strip()          # 去頭尾空白：'AAPL.US'\nparts = clean.split('.')        # 分割：['AAPL', 'US']\nupper = clean.upper()           # 大寫：'AAPL.US'\n\n# f-string 格式化（推薦）\nprice = 178.52\nvolume = 1234567\nreport = f\"Symbol: {ticker.strip()}, Price: ${price:.2f}, Vol: {volume:,}\"\n# 'Symbol: AAPL.US, Price: $178.52, Vol: 1,234,567'\n\n# 舊式格式化（了解即可）\nold_style = \"Price: %.2f\" % price\nformat_style = \"Price: {:.2f}\".format(price)\n```\n\n#### 常見陷阱與注意事項\n- **字串不可變**：`s[0] = 'X'` 會報錯，需用 `s = 'X' + s[1:]`\n- **編碼問題**：讀取含中文的財報時，指定 `encoding='utf-8'`\n- **連接效率**：大量字串連接用 `''.join(list)` 而非 `+`\n\n#### 實務應用場景\n- 生成每日風險報表標題：`f\"VaR Report - {date}\"`\n- 清理 Bloomberg 終端機抓取的 Ticker 數據\n- 解析 FIX 協議訊息中的交易資訊\n\n#### 與其他章節的關聯\n字串處理技術在 Ch5 Pandas 中廣泛應用於 DataFrame 的 column 名稱處理與 `.str` 存取器。\n\n---\n\n### 2.2 運算子與邏輯運算\n\n#### 概念定義\n運算子 (Operators) 分為：\n- **算術運算子**：`+`, `-`, `*`, `/`, `//`（整除）, `%`（餘數）, `**`（次方）\n- **比較運算子**：`>`, `<`, `>=`, `<=`, `==`, `!=`\n- **邏輯運算子**：`and`, `or`, `not`\n\n#### 財金理論背景\n邏輯運算是建構交易規則與風控條件的核心：\n- **買入訊號**：`(price > ma_20) and (rsi < 30)`\n- **停損條件**：`(loss > threshold) or (time > end_of_day)`\n\n交易系統的決策引擎本質上是邏輯運算的組合。\n\n#### Python 實現邏輯\n```python\n# 算術運算\nreturns = (price_today - price_yesterday) / price_yesterday\nannual_return = (1 + daily_return) ** 252 - 1\n\n# 比較與邏輯\nis_bullish = (close > open) and (volume > avg_volume)\nis_bearish = (close < open) and (rsi > 70)\nshould_trade = is_bullish or is_bearish\n\n# 短路求值\nresult = x != 0 and (y / x > 1)  # 若 x=0，不會執行除法\n```\n\n#### 常見陷阱與注意事項\n- **`==` vs `is`**：`==` 比較值，`is` 比較記憶體位置；比較 `None` 用 `is None`\n- **浮點數比較**：`0.1 + 0.2 == 0.3` 為 `False`！使用 `math.isclose()`\n- **運算子優先級**：建議使用括號明確順序，`a and b or c` 可能產生歧義\n\n#### 實務應用場景\n- 實現多因子選股邏輯\n- 建構 VaR 突破警示條件\n- 信用評等遷移矩陣的狀態判斷\n\n#### 與其他章節的關聯\n邏輯運算在 Ch5 Pandas 中用於布林索引 `df[df['return'] > 0]`，是資料篩選的核心技術。\n\n---\n\n### 2.3 關鍵字與變數複製 (Copy vs Deepcopy)\n\n#### 概念定義\nPython 變數是物件的**參考**（Reference），而非物件本身：\n- **淺拷貝 (Shallow Copy)**：複製最外層容器，內層仍共享引用\n- **深拷貝 (Deep Copy)**：遞迴複製所有層級，完全獨立\n\n#### 財金理論背景\n在風險模擬中，常需保留原始情境數據進行對比：\n- 壓力測試需要對比「基準情境」與「壓力情境」\n- 蒙地卡羅模擬需保存初始狀態\n\n若複製不當，修改模擬結果會污染原始數據。\n\n#### Python 實現邏輯\n```python\nimport copy\n\n# 直接賦值（共享引用）\noriginal = [[1, 2], [3, 4]]\nreference = original         # 同一物件！\nreference[0][0] = 999        # original 也變成 [[999, 2], [3, 4]]\n\n# 淺拷貝\nshallow = original.copy()    # 或 list(original)\nshallow[0] = [0, 0]          # original 不受影響\nshallow[1][0] = 888          # original[1][0] 也變成 888！\n\n# 深拷貝\ndeep = copy.deepcopy(original)\ndeep[1][1] = 777             # original 完全不受影響\n```\n\n#### 常見陷阱與注意事項\n- **切片也是淺拷貝**：`new = old[:]` 只複製最外層\n- **字典的 `.copy()`**：也是淺拷貝\n- **性能考量**：深拷貝大物件很慢，必要時才使用\n\n#### 實務應用場景\n- 保存蒙地卡羅模擬的初始投資組合狀態\n- 在情境分析中創建多個獨立的假設情境\n- 避免函數內部修改影響外部數據\n\n#### 與其他章節的關聯\nCh5 Pandas DataFrame 的 `.copy()` 同樣預設淺拷貝，處理巢狀結構時需特別注意。\n\n---\n\n### 2.4 條件與迴圈敘述 (if, for, while)\n\n#### 概念定義\n控制流程 (Control Flow) 決定程式執行路徑：\n- **`if...elif...else`**：條件分支\n- **`for`**：遍歷序列\n- **`while`**：條件迴圈\n\n#### 財金理論背景\n- **信用評等模型**：根據財務指標分級（if-elif 鏈）\n- **歷史回測**：逐日遍歷計算損益（for 迴圈）\n- **迭代收斂**：直到隱含波動率誤差 < 門檻（while 迴圈）\n\n#### Python 實現邏輯\n```python\n# 條件分支：信用評等\ndef credit_rating(score):\n    if score >= 90:\n        return 'AAA'\n    elif score >= 80:\n        return 'AA'\n    elif score >= 70:\n        return 'A'\n    else:\n        return 'BBB'\n\n# for 迴圈：計算累積報酬\nprices = [100, 102, 99, 105]\ncumulative = 1.0\nfor i in range(1, len(prices)):\n    daily_return = prices[i] / prices[i-1] - 1\n    cumulative *= (1 + daily_return)\n\n# while 迴圈：牛頓法求隱含波動率\ntolerance = 1e-6\nwhile abs(error) > tolerance:\n    vol = vol - f(vol) / f_prime(vol)\n    error = f(vol)\n```\n\n#### 常見陷阱與注意事項\n- **無限迴圈**：`while True` 必須有 `break` 出口\n- **迭代時修改序列**：邊遍歷邊刪除會跳過元素\n- **`range(n)` 不含 n**：`range(5)` 產出 0,1,2,3,4\n\n#### 實務應用場景\n- 根據不同市場狀態切換交易策略\n- 遍歷歷史數據計算滾動 VaR\n- 迭代求解債券到期收益率 (YTM)\n\n#### 與其他章節的關聯\n向量化計算（Ch3 NumPy）可取代大部分 for 迴圈，效能提升數十倍，是專業量化開發的關鍵。\n\n---\n\n### 2.5 迭代器與生成器應用\n\n#### 概念定義\n- **迭代器 (Iterator)**：實現 `__next__()` 方法的物件，逐一產生元素\n- **生成器 (Generator)**：使用 `yield` 關鍵字的函數，延遲計算\n\n生成器不會一次性載入所有數據到記憶體，而是按需產生。\n\n#### 財金理論背景\n高頻交易數據量極為龐大：\n- 每日可能有數十 GB 的 Tick 數據\n- 逐筆全部載入記憶體不切實際\n\n生成器允許串流式處理，邊讀邊計算。\n\n#### Python 實現邏輯\n```python\n# 生成器函數\ndef price_stream(filename):\n    with open(filename, 'r') as f:\n        for line in f:\n            yield float(line.strip())  # 逐行產出\n\n# 使用生成器（記憶體友好）\nfor price in price_stream('ticks.txt'):\n    process(price)\n\n# 生成器表達式（類似列表推導式）\nsquares = (x**2 for x in range(1000000))  # 不佔記憶體\nfirst_ten = [next(squares) for _ in range(10)]\n```\n\n#### 常見陷阱與注意事項\n- **一次性消耗**：生成器只能遍歷一次，第二次為空\n- **無法取長度**：`len(generator)` 會報錯\n- **調試困難**：無法直接查看所有元素，需轉為 list\n\n#### 實務應用場景\n- 處理大型歷史 Tick 數據文件\n- 實時行情的串流處理管道\n- 蒙地卡羅模擬的批次生成\n\n#### 與其他章節的關聯\nCh5 Pandas 的 `read_csv(chunksize=n)` 底層也是生成器機制，用於處理超大 CSV 文件。\n\n---\n\n### 2.6 檔案讀寫操作 (.txt, .csv)\n\n#### 概念定義\n檔案 I/O (Input/Output) 是程式與外部數據交互的橋樑。Python 使用 `open()` 函數開啟檔案，搭配 `with` 語法確保資源正確釋放。\n\n#### 財金理論背景\n風險管理系統需要：\n- **輸入**：讀取持倉數據、市場行情、模型參數\n- **輸出**：存儲 VaR 計算結果、風險報表、審計日誌\n\n檔案 I/O 是數據管道的基礎。\n\n#### Python 實現邏輯\n```python\n# 讀取文本檔案\nwith open('portfolio.txt', 'r', encoding='utf-8') as f:\n    lines = f.readlines()       # 全部讀入（小檔案）\n    # 或逐行處理（大檔案）\n    for line in f:\n        process(line)\n\n# 寫入檔案\nwith open('var_result.txt', 'w', encoding='utf-8') as f:\n    f.write(f\"VaR (95%): {var_95:.2f}\\n\")\n    f.write(f\"VaR (99%): {var_99:.2f}\\n\")\n\n# CSV 檔案（基礎方式）\nimport csv\nwith open('trades.csv', 'r') as f:\n    reader = csv.DictReader(f)\n    for row in reader:\n        print(row['symbol'], row['quantity'])\n```\n\n#### 常見陷阱與注意事項\n- **編碼問題**：中文檔案必須指定 `encoding='utf-8'` 或 `'big5'`\n- **路徑格式**：Windows 使用 `\\\\` 或原始字串 `r'C:\\path\\file.txt'`\n- **資源洩漏**：不用 `with` 時必須手動 `f.close()`\n\n#### 實務應用場景\n- 讀取交易所提供的每日結算文件\n- 自動生成每日風險報表並存檔\n- 記錄模型參數變更的審計軌跡\n\n#### 與其他章節的關聯\nCh5 Pandas 的 `read_csv()` 和 `to_csv()` 是更高級的封裝，但理解底層 I/O 有助於處理非標準格式。\n\n---\n\n### 2.7 函數定義、參數與回傳值\n\n#### 概念定義\n函數 (Function) 是可重用的程式碼區塊，透過 `def` 定義。參數類型包括：\n- **位置參數**：按順序傳入\n- **關鍵字參數**：按名稱傳入\n- **預設參數**：提供預設值\n- **可變參數**：`*args`（元組）、`**kwargs`（字典）\n\n#### 財金理論背景\n金融模型高度模組化：\n- **Black-Scholes 函數**：輸入 S, K, T, r, σ → 輸出選擇權價格\n- **VaR 計算函數**：輸入報酬率序列、信賴水準 → 輸出 VaR 值\n\n函數封裝是建構可維護量化系統的基礎。\n\n#### Python 實現邏輯\n```python\nfrom scipy.stats import norm\nimport numpy as np\n\ndef black_scholes_call(S, K, T, r, sigma, q=0):\n    \"\"\"\n    計算歐式買權價格\n    \n    Parameters:\n        S: 標的價格\n        K: 履約價\n        T: 到期時間（年）\n        r: 無風險利率\n        sigma: 波動率\n        q: 股息率（預設 0）\n    \n    Returns:\n        call_price: 買權價格\n    \"\"\"\n    d1 = (np.log(S/K) + (r - q + 0.5*sigma**2)*T) / (sigma*np.sqrt(T))\n    d2 = d1 - sigma * np.sqrt(T)\n    \n    call_price = S * np.exp(-q*T) * norm.cdf(d1) - K * np.exp(-r*T) * norm.cdf(d2)\n    return call_price\n\n# 呼叫方式\nprice = black_scholes_call(100, 100, 1, 0.05, 0.2)  # 位置參數\nprice = black_scholes_call(S=100, K=100, T=1, r=0.05, sigma=0.2, q=0.02)  # 關鍵字\n```\n\n#### 常見陷阱與注意事項\n- **可變預設參數**：`def f(x=[])` 會共享同一列表！使用 `def f(x=None)`\n- **作用域**：函數內變數為局部變數，修改全域需用 `global`\n- **回傳多值**：`return a, b` 實際回傳元組\n\n#### 實務應用場景\n- 封裝定價模型供多處調用\n- 建立風險指標計算函數庫\n- 設計可配置的交易策略函數\n\n#### 與其他章節的關聯\nCh4 SymPy 將展示如何用符號運算自動推導 Greeks（選擇權敏感度），本質上是對函數進行微分。\n\n---\n\n### 2.8 異常處理 (try-except) 與錯誤排除\n\n#### 概念定義\n異常 (Exception) 是程式執行時的錯誤事件。`try...except` 區塊允許捕捉異常並進行優雅處理，而非讓程式崩潰。\n\n#### 財金理論背景\n生產環境中的交易系統必須具備高可用性：\n- 行情斷線時不應導致整體系統停擺\n- 數據異常（如：缺失值、格式錯誤）需記錄並跳過\n- 關鍵操作失敗需觸發告警\n\n#### Python 實現邏輯\n```python\n# 基本結構\ntry:\n    result = risky_operation()\nexcept ZeroDivisionError:\n    print(\"除以零錯誤\")\n    result = float('inf')\nexcept FileNotFoundError as e:\n    print(f\"檔案未找到: {e}\")\n    result = None\nexcept Exception as e:\n    print(f\"未預期錯誤: {type(e).__name__}: {e}\")\n    raise  # 重新拋出\nelse:\n    print(\"執行成功\")  # 無異常時執行\nfinally:\n    cleanup()  # 無論如何都執行\n\n# 自定義異常\nclass InsufficientBalanceError(Exception):\n    pass\n\ndef withdraw(balance, amount):\n    if amount > balance:\n        raise InsufficientBalanceError(f\"餘額不足: {balance} < {amount}\")\n    return balance - amount\n```\n\n#### 常見陷阱與注意事項\n- **過度捕捉**：`except:` 或 `except Exception:` 會捕捉所有錯誤，可能隱藏 bug\n- **忽略異常**：`except: pass` 是反模式，至少要記錄日誌\n- **異常順序**：子類別異常必須放在父類別之前\n\n#### 實務應用場景\n- API 調用失敗時自動重試\n- 解析非標準化數據文件時跳過損壞記錄\n- 交易執行失敗時發送 Slack 告警\n\n#### 與其他章節的關聯\nCh4 的數值計算（如：矩陣分解）可能因輸入不合法而拋出 `LinAlgError`，異常處理確保系統穩定性。"
      }
    },
    "examples": [
      {
        "id": "ex1",
        "title": "2.1 B1_Ch2_1.py",
        "filename": "B1_Ch2_1.py",
        "code": "# B1_Ch2_1.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n# Example 1: Single or double quotes can be used\nprint('Hickory Dickory Dock! The mouse ran up the clock') #single quote\nprint(\"Hickory Dickory Dock! The mouse ran up the clock\") #double quote\n# Out: Hickory Dickory Dock! The mouse ran up the clock\n\n# Example 2: force a new line\n# Use \"\\n\" to force a new line\nprint('Hickory Dickory Dock!\\nThe mouse ran up the clock') \n# Out:  Hickory Dickory Dock!\n#       The mouse ran up the clock\n# Use triple quotes to force a new line\nprint(\"\"\"Hickory Dickory Dock! \nThe mouse ran up the clock\"\"\")\n# Out:  Hickory Dickory Dock!\n#       The mouse ran up the clock\n# Example 3: Use \\\nprint(\"Hickory Dickory Dock!\\\nThe mouse ran up the clock\")\n"
      },
      {
        "id": "ex2",
        "title": "2.2 B1_Ch2_2.py",
        "filename": "B1_Ch2_2.py",
        "code": "# B1_Ch2_2.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n# Example of string function\nmessage = 'hello world' \n\n# Find  the index of the first character\nprint(message.find('world')) \n# Out: 6\n\n# count() function is used to count the number of a specific character\nprint(message.count('o')) \n# Out: 2\n\n# capitalize() can capitalize the initial character of the string\nprint(message.capitalize()) \n#  Hello world\n\n# replace() function\nprint(message.replace('hello','Hi')) \n# Hi world\n\n# title() function can capitalize the initial character of each word\nstr = \"this is string example....wow!!!\";\nprint (str.title()) # Out: This Is String Example....Wow!!\n# split() function to break a sentence in to words\ns = 'Eat more bananas, will u?'\nt = s.split()\nprint(t) # Out: ['Eat', 'more', 'bananas,', 'will', 'u?']\ns = 'bananas-are-good-for-you'\ndelimiter = '-'\nt = s.split(delimiter)\nprint(t) #Out: ['bananas', 'are', 'good', 'for', 'you']\n# join() function\nt = ['bananas', 'are', 'good', 'for', 'you']\ndelimiter = ' '\ns = delimiter.join(t) # Out: bananas are good for you\n"
      },
      {
        "id": "ex3",
        "title": "2.3 B1_Ch2_3.py",
        "filename": "B1_Ch2_3.py",
        "code": "# B1_Ch2_3.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\nx = True\ny = False\n# Output: x and y is False\nprint('x and y is',x and y)\n\n# Output: x or y is True\nprint('x or y is',x or y)\n\n# Output: not x is False\nprint('not x is',not x)\nx =n= 3\nprint(x > 0 and x < 10  )\n# is true only if x is greater than 0 and less than 10\n\nprint(n%2 == 0 or n%3 == 0 )\n# is true if either or both of the conditions is true, \n# that is, if the number is divisible by 2 or 3\n"
      },
      {
        "id": "ex4",
        "title": "2.4 B1_Ch2_4.py",
        "filename": "B1_Ch2_4.py",
        "code": "# B1_Ch2_4.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\nA = {'Name': 'John', 'Born': 1992}\nB = A\nprint(B is A)# Out: True\nprint(id(A))# Out:2433131563032\nprint(id(B))# Out:2433131563032\nprint(id(A)==id(B))# Out: True\nB ['Height'] = 180\nprint(A)#Out: {'Name': 'John', 'Born': 1992, 'Height': 180}\nprint(B)#Out: {'Name': 'John', 'Born': 1992, 'Height': 180}\n\nC = {'Name': 'John', 'Born': 1992, 'Height': 180}\nprint(C==A)# Out: True\nprint(C is A)# Out: False\nprint(id(C))#Out:2433131575240\nprint(id(A))#Out:2433131563032\n"
      },
      {
        "id": "ex5",
        "title": "2.5 B1_Ch2_5.py",
        "filename": "B1_Ch2_5.py",
        "code": "# B1_Ch2_5.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\nOriginal_list = [0,1,[2,3]]\nprint(id(Original_list))\n\n#Use slicing\nList_cloning1 = Original_list[:]\nprint(id(List_cloning1))\n\n#Use extend() method\nList_cloning2 = []\nList_cloning2.extend(Original_list)\nprint(id(List_cloning2))\n\n#Use list() function\nList_cloning3 = list(Original_list)\nprint(id(List_cloning3))\n\n#Use list comprehension\nList_cloning4 = [i for i in Original_list]\nprint(id(List_cloning4))\n\n#Use copy() function\nList_cloning5 = Original_list.copy()\nprint(id(List_cloning5))\n\nOriginal_list.append(5)\nprint(Original_list)\nprint(List_cloning1,List_cloning2,List_cloning3,List_cloning4,List_cloning5)\n\nOriginal_list[2].remove(3)\nprint(List_cloning1,List_cloning2,List_cloning3,List_cloning4,List_cloning5)\n"
      },
      {
        "id": "ex6",
        "title": "2.6 B1_Ch2_6.py",
        "filename": "B1_Ch2_6.py",
        "code": "# B1_Ch2_6.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\nfrom copy import deepcopy\na=[['Jack',21],['Theresa']]\nb=a.copy()\nc=deepcopy(a)\nprint([id(x) for x in a])#Out: [192455504, 192457944]\nprint([id(x) for x in b])#Out: [192455504, 192457944]\nprint([id(x) for x in c])#Out: [192451408, 192457064]\n#a[0]= ['Durant',23]\na[1].append(22)\nprint(a)\n#Out:[['Jack', 21], ['Theresa', 22]]\nprint([id(x) for x in a])\n#Ou: [192451528, 192457944]\nprint(b)\n#Out: [['Jack', 21], ['Theresa', 22]]\nprint([id(x) for x in b])\n#Out: [192455504, 192457944]\nprint(c)\n#Out: [['Jack', 21], ['Theresa']]\nprint([id(x) for x in c])\n#Out: [192451408, 192457064]\n"
      },
      {
        "id": "ex7",
        "title": "2.7 B1_Ch2_7.py",
        "filename": "B1_Ch2_7.py",
        "code": "# B1_Ch2_7.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n#if... else example\nnum = int(input(\"Please enter a number\"))\nif num > 1:\n   for i in range(2,num):\n       if (num % i) == 0:\n           print(num,\"This is not a prime number\")\n           print(i,\"multiplied by \",num//i,\"makes\",num)\n           break\n   else:\n       print(num,\"This is a prime number\")\n# A prime number is larger than 1\nelse:\n   print(num,\"This is not a prime number\")\n"
      },
      {
        "id": "ex8",
        "title": "2.8 B1_Ch2_8.py",
        "filename": "B1_Ch2_8.py",
        "code": "# B1_Ch2_8.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\nnum = 1\nif num >= 0 and num <= 10:\n    print(\"The number is between 0 and 10\")\nnum =2\nif num < 0 or num > 10:\n    print(\"The number is smaller than 0 or larger than 10\")\nelse:\n    print('undefine')\nnum = 8\nif (num >= 0 and num <= 5) or (num >= 10 and num <= 15):    \n    print('hello')\nelse:\n    print ('undefine')\n"
      },
      {
        "id": "ex9",
        "title": "2.9 B1_Ch2_9.py",
        "filename": "B1_Ch2_9.py",
        "code": "# B1_Ch2_9.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n#Methods for achieving switch structure\n#%%Method1: use \ndef week(i):\n        switcher={\n                0:'Sunday',\n                1:'Monday',\n                2:'Tuesday',\n                3:'Wednesday',\n                4:'Thursday',\n                5:'Friday',\n                6:'Saturday'\n             }\n        return switcher.get(i,\"Invalid day of week\")\nprint(week(2))\n#%% Method2: use class\nclass week(object):\n          def indirect(self,i):\n                   method_name='number_'+str(i)\n                   method=getattr(self,method_name,lambda :'Invalid')\n                   return method()\n          def number_1(self):\n                   print('Monday')\n          def number_2(self):\n                   print('Tuesday')\n          def number_3(self):\n                   print('Wednesday')\n          def number_4(self):\n                   print('Thursday')\n          def number_5(self):\n                   print('Friday')\n          def number_6(self):\n                   print('Saturday')\n          def number_7(self):\n                   print('Sunday')\nw = week()\nw.indirect(1)\n"
      },
      {
        "id": "ex10",
        "title": "2.10 B1_Ch2_10.py",
        "filename": "B1_Ch2_10.py",
        "code": "# B1_Ch2_10.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n#%% Use for and break to get the prime numbers\nnum=[];\ni=2\nfor i in range(2,100):\n   j=2\n   for j in range(2,i):\n      if(i%j==0):\n         break\n   else:\n      num.append(i)\nprint(num)\n#%% use function and lambda function to get the prime numbers\nimport math\ndef func_get_prime(n):\n  return list(filter(lambda x: not [x%i for i in range(2, int(math.sqrt(x))+1) if x%i ==0], range(2,n+1)))\nprint(func_get_prime(100))\n"
      },
      {
        "id": "ex11",
        "title": "2.11 B1_Ch2_11.py",
        "filename": "B1_Ch2_11.py",
        "code": "# B1_Ch2_11.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n# Methods to search something in an information pool\n#%% Method #1,for loop with break and else structure\ncar = {\"Ford\":2020, \"Toyota\":2019,\"Nissan\":2018}\nfound_brand = None\nfor key in car.keys():\n    if key == \"BMW\":\n        found_brand = key\n        print(\"BMW is found\")\n        break\nelse:\n    print(\"BMW is not found.\")\n#%% Method 2, define a function to search\ndef find_brand(brand, Objects):\n    for obj in Objects.keys():\n        if obj == brand:\n            print(\"{0} is found\".format(obj))\ncar = {\"Ford\":2020, \"Toyota\":2019,\"Nissan\":2018}\nbrand = \"Nissan\"\nfind_brand(brand,car)\n#%% Method3, use list comprehension\ncar = {\"Ford\":2020, \"Toyota\":2019,\"Nissan\":2018}\nmatching_brand = [obj for obj in car.keys() if obj == \"Toyota\"]\nif matching_brand:\n    print(\"{} is found\".format(matching_brand[0]))\nelse:\n    print(\"Toyota is not found\")\n"
      },
      {
        "id": "ex12",
        "title": "2.12 B1_Ch2_12.py",
        "filename": "B1_Ch2_12.py",
        "code": "# B1_Ch2_12.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n# A list is an iterable\nfor city in [\"Beijing\", \"Toronto\", \"Shanghai\"]: \n    print(city) \nprint(\"\\n\") \n# A tuple is an iterable\nfor city in (\"Chongqing\", \"Guangzhou\", \"Shenzhen\"): \n    print(city) \nprint(\"\\n\")\n# A tuple is an iterable\nfor char in \"We love FRM and Python\": \n    print(char, end = \" \")\nprint(\"\\n\")\n# A range object is an iterable\nfor i in range(5): \n    print(i**2, end = \" \")\nprint(\"\\n\")\n"
      },
      {
        "id": "ex13",
        "title": "2.13 B1_Ch2_13.py",
        "filename": "B1_Ch2_13.py",
        "code": "# B1_Ch2_13.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n#% Generator example\ndef Fibonacci(max):\n    a,b,c =0,0,1\n    while a < max:\n        yield b\n        b,c =c,b+c\n        a += 1\nFib = Fibonacci(100)\nprint(Fib)\nprint(type(Fib)) #<class 'generator'>\nwhile True:\n    try:\n        print(next(Fib))\n    except StopIteration:\n        break\nfor i in Fib:\n    print(i**2)\n"
      },
      {
        "id": "ex14",
        "title": "2.14 B1_Ch2_14.py",
        "filename": "B1_Ch2_14.py",
        "code": "# B1_Ch2_14.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\nimport csv\nimport numpy as np\nfrom copy import deepcopy\nimport pandas as pd\n#%% Generate the names of the files\nfre_list = np.arange(533.33,13333.25+533.33,533.33)\nfor i in np.arange(25):\n    if fre_list[i]>10000:\n        fre_list[i]=np.around(fre_list[i],1)\nfre_list_round = [np.int(np.fix(i)) for i in fre_list]\n#%% Generate the random data for the files\nfor name in fre_list_round:\n    data1 = np.random.rand(1000,2)\n    data2 = np.random.rand(1000,2)\n    data1 = [complex(x,y) for x in data1[:,0] for y in data1[:,1]]\n    data2 = [complex(x,y) for x in data2[:,0] for y in data2[:,1]]\n    data = np.transpose(np.array([data1,data2]))\n    pd.DataFrame(data).to_csv(\"{}.csv\".format(name),index=False, header=False)\n#%%\nfor name in fre_list_round:\n    with open('{}.csv'.format(name),'r') as file:\n        reader =list(csv.reader(file))\n        result = np.array(reader)\n        da = deepcopy(result[1:,1:])\n        da = da.astype(complex)\n    for i in np.arange(len(da[:,0])):\n        for j in np.arange(len(da[0,:])):\n           da[i,j] = da[i,j]*100\n    df = pd.DataFrame (da)\n    filepath = '{}_10timies.xlsx'.format(name)\n    df.to_excel(filepath, index=False, header=False)\n"
      },
      {
        "id": "ex15",
        "title": "2.15 B1_Ch2_15.py",
        "filename": "B1_Ch2_15.py",
        "code": "# B1_Ch2_15.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\nFile = open(\"Week.txt\",'w')\nWeek = 'Monday\\nTuesday\\nWednesday\\nThursday\\nFriday\\nSasturday\\nSunday'\nFile.write(Week)\nFile.close()\nFile1=open(\"Week.txt\" ,'r' )\nDay1 = File1.readline()\nprint(Day1)#Out:Monday\nDay2 = File1.readline()\nprint(Day2)#Out:Tuesday\nDay3 = File1.readline()\nprint(Day3)#Out:Wednesday\nDay4 = File1.readline()\nprint(Day4)#Out:Thursday\nDay5 = File1.readline()\nprint(Day5)#Out:Friday\nWeekend = File1.readlines()\nprint(Weekend)#Out: ['Saturday\\n', 'Sunday']\n#% The second method to print the content in each line\nfor f in File1:\n    print(f)\nFile1.close()\nFile2 =open(\"Week.txt\" ,'r+' )\nWeeklist = File2.read()\nFile2.write(\"\\nA week has 7 days\")\nFile2.close()\nFile3 =open(\"Week.txt\" ,'r+' )\nWeeklist2 = File3.read()\nFile3.close()\n"
      },
      {
        "id": "ex16",
        "title": "2.16 B1_Ch2_16.py",
        "filename": "B1_Ch2_16.py",
        "code": "# B1_Ch2_16.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\nwith open('file.txt', 'w+') as f:\n    f.write('Hello, John!')\nwith open('file.txt', 'r') as f1, open('file2.txt', 'w') as f2:\n    txt = f1.read()\n    f2.write(txt)\n"
      },
      {
        "id": "ex17",
        "title": "2.17 B1_Ch2_17.py",
        "filename": "B1_Ch2_17.py",
        "code": "# B1_Ch2_17.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n# Define the function to calculate its integration:\ndef f1(x):\n    return x ** 4 * (1 - x) ** 4 / (1 + x ** 2)\ndef f2(x):\n    return x ** 4 +x**3+x**2\n#define a function to do integration of f(x)\n# The start and end points for the integration can be changed.\ndef trap(f, n,start=0,end=1):\n    h = (end-start) / float(n)\n    intgr = 0.5 * h * (f(start) + f(end))\n    for i in range(1, int(n)):\n        intgr = intgr + h * f(i * h+start)\n    return intgr\nprint(trap(f1, 100,start=2,end=3))\nprint(trap(f1, 100,start=1,end=2))\nprint(trap(f2, 100))\nprint(trap(f2, 100,start=5,end=9))"
      },
      {
        "id": "ex18",
        "title": "2.18 B1_Ch2_18.py",
        "filename": "B1_Ch2_18.py",
        "code": "# B1_Ch2_18.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\ntry:\n    import random\n    rand_num = int(random.random()*10)\n    value = input(\"Please enter a number between 0 and 9:\\n\")\n    input_value = int(value)\nexcept ValueError as error:\n    print(\"The value is invalid %s\"%error)\nelse:\n    if input_value <0 or input_value >9:\n        print(\"Input invalid. Please enter a number between 0 and 9\")\n    elif input_value ==rand_num:\n        print(\"Your guess is correct!You Win!\")\n    else:\n        print(\"Nope!The random value was %s\"%rand_num)\n"
      }
    ]
  },
  {
    "id": "b1_ch3",
    "title": "第3章：NumPy 使用",
    "number": 3,
    "content": {
      "intro": {
        "title": "第 3 章：使用 NumPy - 詳解",
        "roadmap": {
          "guide": "本章進入高效能數值運算的領域。NumPy 是金融工程的核心，掌握矩陣建立與運算技巧是處理大規模報酬率數據的基礎。",
          "objectives": "開啟高效能的高維數值運算門票。NumPy 是金融工程的核心，本章重點在於矩陣（ndarray）的建立、運算與切片技巧，這對於處理資產報酬率矩陣（Return Matrix）至關重要。",
          "topics": "*   3.1 NumPy 套件匯入與 ndarray 介紹\n*   3.2 基本類型矩陣與基本矩陣建立\n*   3.3 其他矩陣建立函數 (zeros, ones, eye)\n*   3.4 矩陣索引、切片與遍歷\n*   3.5 矩陣變形 (Reshape, Flatten)"
        },
        "value": {
          "practical": "*   **實務場景**：大規模蒙地卡羅模擬 (Monte Carlo Simulation) 的基礎結構。\n*   **考試重點**：資產相關性與多分散投資（Diversification）的數值模擬。",
          "theory": "*   **矩陣代數與資產組合**：資產組合的期望收益率 $R_p = \\mathbf{w}^T \\mathbf{R}$，組合方差 $\\sigma_p^2 = \\mathbf{w}^T \\mathbf{\\Sigma} \\mathbf{w}$。這些線性代數運算在 NumPy 中透過矩陣乘法極速完成。\n*   **相關性矩陣**：理解協方差矩陣與相關係數矩陣在 NumPy 中的數據表示形式。",
          "further_reading": "*   NumPy Ufuncs：自定義通用的向量化函數。"
        },
        "implementation": {
          "python": "*   **向量化運算 (Vectorization)**：避免使用慢速的 Python 迴圈，一次性對整個資產列表進行數值變換。\n*   **廣播機制 (Broadcasting)**：自動處理不同維度數組間的無縫計算（例如：給所有資產同時加上無風險利率）。",
          "logic": "*   `np.array()`：建立高維矩陣。\n*   `np.dot()`：執行矩陣內積，計算組合收益。\n*   切片技巧 (`arr[1:5, :]`)：快速選取特定時間段或特定資產的數據子集。",
          "scenarios": "| 腳本名稱 | 核心使命 |\n| :--- | :--- |\n| **B1_Ch3_1.py** | 利用 NumPy arange 生成數值區間向量，並進行重塑 (Reshape)。 |\n| **B1_Ch3_2.py** | 演示 NumPy 陣列與 Python 原始列表在運算速度上的對比。 |\n| **B1_Ch3_3.py** | 實作矩陣廣播機制 (Broadcasting)，演示不同維度佈局的運算。 |\n| **B1_Ch3_4.py** | 比較陣列初始化方法：empty, zeros, ones 與 eye 單位矩陣。 |\n| **B1_Ch3_5.py** | 演示 NumPy 數值索引與布林遮罩 (Boolean Mask) 的特徵提取。 |\n| **B1_Ch3_6.py** | 實作矩陣轉置與共軛轉置，演示基礎線性代數變換。 |"
        },
        "body": "### 3.1 NumPy 套件匯入與 ndarray 介紹\n\n#### 概念定義\n**NumPy** (Numerical Python) 是 Python 科學計算的基石套件。其核心是 **ndarray** (N-dimensional array)，一種同質（homogeneous）多維陣列物件，所有元素必須為相同類型，存儲在連續的記憶體區塊中。\n\n#### 財金理論背景\n金融數據天然具備矩陣結構：\n- **報酬率矩陣**：[時間 × 資產] = 每日每檔股票報酬率\n- **協方差矩陣**：[資產 × 資產] = 資產間的共變異\n- **情境矩陣**：[模擬次數 × 時間步 × 資產] = 蒙地卡羅路徑\n\nNumPy 是處理這些矩陣運算的標準工具。\n\n#### 數學公式或模型\n投資組合報酬率的矩陣表示：\n$$\nR_p = \\mathbf{w}^T \\mathbf{R}\n$$\n其中 $\\mathbf{w}$ 是權重向量，$\\mathbf{R}$ 是資產報酬率向量。\n\n#### Python 實現邏輯\n```python\nimport numpy as np  # 標準匯入慣例\n\n# 建立 ndarray\nreturns = np.array([0.01, -0.02, 0.03, 0.01, -0.01])\n\n# 關鍵屬性\nprint(returns.shape)     # (5,) - 維度\nprint(returns.dtype)     # float64 - 資料類型\nprint(returns.ndim)      # 1 - 維數\nprint(returns.size)      # 5 - 元素總數\nprint(returns.nbytes)    # 40 - 記憶體大小 (5 * 8 bytes)\n```\n\n#### 常見陷阱與注意事項\n- **匯入慣例**：**必須**使用 `import numpy as np`，這是社群慣例\n- **類型強制**：`np.array([1, 2, 3.0])` 會自動轉為 `float64`\n- **記憶體效率**：NumPy 陣列比 Python 列表節省約 4 倍記憶體\n\n#### 實務應用場景\n- 存儲大型歷史價格數據集\n- 計算多資產的批量報酬率\n- 作為機器學習模型的輸入格式\n\n#### 與其他章節的關聯\nndarray 是 Ch4 線性代數運算、Ch5 Pandas 底層數據結構的基礎。理解 ndarray 是量化開發的必備技能。\n\n---\n\n### 3.2 基本類型矩陣與基本矩陣建立\n\n#### 概念定義\nNumPy 支援多種數據類型 (dtype)，包括：\n- `np.float64`：64 位浮點數（預設）\n- `np.float32`：32 位浮點數（節省記憶體）\n- `np.int32/int64`：整數\n- `np.complex128`：複數（選擇權定價）\n\n#### 財金理論背景\n數據類型選擇影響：\n- **精度**：VaR 計算需要 float64\n- **效能**：GPU 加速偏好 float32\n- **記憶體**：大規模回測需權衡空間\n\n#### 數學公式或模型\n多維陣列的形狀定義：\n$$\n\\text{Shape} = (n_1, n_2, \\ldots, n_k)\n$$\n其中 $n_i$ 是第 $i$ 維的大小。\n\n#### Python 實現邏輯\n```python\n# 從列表建立\nprices = np.array([[100, 101, 102],\n                   [50, 51, 49]], dtype=np.float64)\nprint(prices.shape)  # (2, 3) - 2 資產 × 3 天\n\n# 指定類型\nweights = np.array([0.6, 0.4], dtype=np.float32)\n\n# 類型轉換\nint_prices = prices.astype(np.int32)\n\n# 從檔案讀取\ndata = np.loadtxt('prices.csv', delimiter=',')\n\n# 儲存陣列\nnp.save('returns.npy', returns)  # 二進位格式\nnp.savetxt('returns.csv', returns, delimiter=',')  # CSV\n```\n\n#### 常見陷阱與注意事項\n- **整數除法**：`np.int32` 陣列相除仍為整數！\n- **精度溢出**：`np.int32` 最大值約 21 億\n- **NaN 處理**：`np.float64` 支援 `np.nan`，整數類型不支援\n\n#### 實務應用場景\n- 建立多資產報酬率矩陣\n- 從 CSV 載入歷史行情\n- 序列化模型參數便於復現\n\n#### 與其他章節的關聯\n強類型控制在 Ch4 矩陣分解中很重要，Cholesky 分解要求輸入為 float 類型。\n\n---\n\n### 3.3 其他矩陣建立函數 (zeros, ones, eye)\n\n#### 概念定義\nNumPy 提供快捷函數建立特殊矩陣：\n- `np.zeros(shape)`：全零矩陣\n- `np.ones(shape)`：全一矩陣\n- `np.eye(n)`：單位矩陣\n- `np.arange(start, stop, step)`：等差序列\n- `np.linspace(start, stop, n)`：等分 n 個點\n\n#### 財金理論背景\n這些特殊矩陣在金融中有具體意義：\n- **全零**：初始化損益陣列\n- **全一**：等權重投資組合\n- **單位矩陣**：無相關性的協方差矩陣基準\n\n#### 數學公式或模型\n單位矩陣：\n$$\nI_n = \\begin{pmatrix} 1 & 0 & \\cdots & 0 \\\\ 0 & 1 & \\cdots & 0 \\\\ \\vdots & & \\ddots & \\\\ 0 & 0 & \\cdots & 1 \\end{pmatrix}\n$$\n\n性質：$A \\cdot I = I \\cdot A = A$\n\n#### Python 實現邏輯\n```python\n# 全零：初始化損益陣列\npnl = np.zeros((1000, 252))  # 1000 次模擬 × 252 天\n\n# 全一：等權重\nn_assets = 5\nequal_weights = np.ones(n_assets) / n_assets  # [0.2, 0.2, 0.2, 0.2, 0.2]\n\n# 單位矩陣\nidentity = np.eye(3)\n\n# 對角矩陣\nvariances = np.array([0.04, 0.09, 0.01])\ndiag_cov = np.diag(variances)  # 3×3 對角矩陣\n\n# 時間軸生成\ndays = np.arange(0, 252)           # 0, 1, 2, ..., 251\ntime_grid = np.linspace(0, 1, 100)  # 0 到 1 年切成 100 個時點\n\n# 網格生成\nstrikes = np.arange(80, 121, 5)     # [80, 85, 90, ..., 120]\nmaturities = np.array([0.25, 0.5, 1.0])\nK, T = np.meshgrid(strikes, maturities)  # 3×9 網格\n```\n\n#### 常見陷阱與注意事項\n- **形狀是元組**：`np.zeros((3, 4))` 而非 `np.zeros(3, 4)`\n- **`arange` 不含終點**：`np.arange(0, 5)` → [0,1,2,3,4]\n- **`linspace` 含終點**：`np.linspace(0, 1, 5)` → [0, 0.25, 0.5, 0.75, 1]\n\n#### 實務應用場景\n- 初始化蒙地卡羅模擬結果陣列\n- 建立時間軸供債券折現使用\n- 生成選擇權定價的履約價/到期日網格\n\n#### 與其他章節的關聯\n`np.linspace` 在 Ch12 殖利率曲線插值中用於生成評估時點。\n\n---\n\n### 3.4 矩陣索引、切片與遍歷\n\n#### 概念定義\nNumPy 索引功能遠超 Python 列表：\n- **基本索引**：`arr[i, j]` 存取單一元素\n- **切片**：`arr[start:end, :]` 選取子矩陣\n- **布林索引**：`arr[arr > 0]` 條件篩選\n- **花式索引**：`arr[[0, 2, 4]]` 特定位置\n\n#### 財金理論背景\n數據篩選是風險分析的核心操作：\n- 選取特定日期區間的報酬率\n- 篩選正/負報酬日進行非對稱分析\n- 提取特定資產子集進行歸因分析\n\n#### Python 實現邏輯\n```python\n# 二維陣列：3 資產 × 5 天\nreturns = np.array([\n    [0.01, -0.02, 0.03, 0.01, -0.01],  # Asset A\n    [-0.01, 0.02, -0.01, 0.02, 0.01],  # Asset B\n    [0.02, 0.01, 0.01, -0.02, 0.03]    # Asset C\n])\n\n# 基本索引\nprint(returns[0, 2])     # 0.03 - Asset A 第 3 天\n\n# 切片\nprint(returns[:, :3])    # 所有資產的前 3 天\nprint(returns[1:, -2:])  # Asset B, C 的最後 2 天\n\n# 布林索引（極重要！）\nmask = returns > 0\npositive_returns = returns[mask]       # 一維：所有正報酬\nprint(returns[returns < -0.01])        # 大幅下跌的日子\n\n# 花式索引\nselected = returns[[0, 2], :]          # 選 Asset A 和 C\ndays = returns[:, [0, 2, 4]]           # 選第 1, 3, 5 天\n\n# 條件賦值\nreturns_clipped = returns.copy()\nreturns_clipped[returns_clipped < -0.05] = -0.05  # 截尾處理\n```\n\n#### 常見陷阱與注意事項\n- **視圖 vs 複本**：基本切片返回視圖（修改會影響原陣列），布林索引返回複本\n- **維度降低**：`arr[0]` 會從 2D 變成 1D\n- **空結果**：布林條件無匹配時返回空陣列，不是 None\n\n#### 實務應用場景\n- 分離訓練/測試數據集（時間切片）\n- 篩選 VaR 突破日進行回溯測試\n- 計算條件期望值（如：正報酬日的平均報酬）\n\n#### 與其他章節的關聯\n布林索引在 Ch5 Pandas 中對應 `df[df['col'] > 0]` 語法，是資料分析的核心技術。\n\n---\n\n### 3.5 矩陣變形 (Reshape, Flatten)\n\n#### 概念定義\n- **`reshape(new_shape)`**：改變陣列形狀但不改變數據\n- **`flatten()`**：攤平為一維（返回複本）\n- **`ravel()`**：攤平為一維（返回視圖）\n- **`transpose()` / `.T`**：轉置\n\n#### 財金理論背景\n數據格式轉換是建模流程的關鍵：\n- LSTM 模型輸入需要 `(samples, timesteps, features)`\n- 矩陣乘法需要確保維度匹配\n- 協方差計算需要正確的資產/時間排列\n\n#### 數學公式或模型\n轉置矩陣：\n$$\n(A^T)_{ij} = A_{ji}\n$$\n\n協方差矩陣計算（去均值後）：\n$$\n\\Sigma = \\frac{1}{n-1} X^T X\n$$\n\n#### Python 實現邏輯\n```python\n# 原始陣列\na = np.arange(12)  # [0, 1, 2, ..., 11]\n\n# Reshape（不改變數據順序）\nmatrix = a.reshape(3, 4)   # 3 行 × 4 列\nmatrix = a.reshape(3, -1)  # -1 自動計算：12/3=4\n\n# 常見的時間序列重塑\nprices = np.array([100, 101, 102, 103, 104, 105])\n# 轉換為 LSTM 輸入：3 個樣本，每個 2 時步\nlstm_input = prices.reshape(3, 2, 1)\n\n# 攤平\nflat = matrix.flatten()  # 返回複本\nflat_view = matrix.ravel()  # 返回視圖（省記憶體）\n\n# 轉置\nreturns = np.random.randn(252, 5)  # 252 天 × 5 資產\nreturns_T = returns.T              # 5 資產 × 252 天\n\n# 計算協方差矩陣\nmean_returns = returns.mean(axis=0)\ndemeaned = returns - mean_returns\ncov_matrix = demeaned.T @ demeaned / (len(returns) - 1)\n# 或直接用：np.cov(returns, rowvar=False)\n```\n\n#### 常見陷阱與注意事項\n- **元素總數不變**：`reshape(2, 5)` 需要原陣列恰好有 10 個元素\n- **記憶體順序**：預設 C 順序（行優先），MATLAB 用 F 順序（列優先）\n- **`-1` 自動推斷**：只能用一個 `-1`\n\n#### 實務應用場景\n- 將一維價格序列重塑為二維（日期 × 資產）\n- 準備深度學習模型的輸入格式\n- 轉置以匹配矩陣乘法的維度要求\n\n#### 與其他章節的關聯\n矩陣變形在 Ch4 的線性代數運算（矩陣乘法、分解）中是前置操作。Ch8 的隨機變數生成也需要 reshape 以匹配模型結構。"
      }
    },
    "examples": [
      {
        "id": "ex1",
        "title": "3.1 B1_Ch3_1.py",
        "filename": "B1_Ch3_1.py",
        "code": "# B1_Ch3_1.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\nimport numpy as np\nimport time\n# Create a ndarray of integers in the range\n# 0 up to (but not including) 10,000,000\narray = np.arange(1e4)\n# Convert it to a list\nlist_array = array.tolist()\nstart_time = time.time()\ny = [val * 5 for val in list_array]\nprint(\"List calculation time is %s seconds.\" % (time.time() - start_time)) \n# List calculation time is 5.672233819961548 seconds.\nstart_time = time.time()\nx = array * 5\nprint(\"NumPy Array calculation time is %s seconds.\" % (time.time() - start_time))\n# ndarray calculation time is 0.12609171867370605 seconds.\n"
      },
      {
        "id": "ex2",
        "title": "3.2 B1_Ch3_2.py",
        "filename": "B1_Ch3_2.py",
        "code": "# B1_Ch3_2.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\nimport numpy as np\na_list =[1,2,3,4]\na_tuple = tuple(a_list)\na_set = set(a_list)\nprint(f\"The original list is {a_list}\")\nprint(\"The array created from a list is {}\".format(np.array(a_list)))\nprint(f\"The array created from a tuple is {np.array(a_tuple)}\")\nprint(f\"The array created from a set is {np.array(list(a_set))}\")\nprint(f\"The type of the array created from a tuple is {type(np.array(a_tuple))}\")\nprint(f\"The type of the array created from a set is {type(np.array(list(a_set)))}\")"
      },
      {
        "id": "ex3",
        "title": "3.3 B1_Ch3_3.py",
        "filename": "B1_Ch3_3.py",
        "code": "# B1_Ch3_3.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\nimport numpy as np\nimport math\ndegree_list = [10,20,30]\nsin_list = [math.sin(i) for i in degree_list]\nsin_list_int = np.array(sin_list,dtype='i')\nsin_list_float = np.array(sin_list,dtype='f')\ndate_example = np.array(['2005-02-25','2011-12-25','2020-09-20'],dtype = 'M')\ndate_increment = np.array([100,200,300],dtype = 'm')\ndate_example_updated = date_example+date_increment\nprint(f'Saving the data in the format of integer:{sin_list_int}')\nprint(f'Saving the data in the format of floating point:{sin_list_float}')\nprint(f'Datetime example: {date_example}')\nprint(f'Updated datetime is: {date_example_updated}')\n"
      },
      {
        "id": "ex4",
        "title": "3.4 B1_Ch3_4.py",
        "filename": "B1_Ch3_4.py",
        "code": "# B1_Ch3_4.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\nimport numpy as np\nlist_obj = [[1,1],[1,1]]\n# create a ndarray and a list, respectively\nndarray_obj = np.ones((2,2),dtype = 'i')\nlist_np = np.array(list_obj)\n\n#Case 1: create a ndarray from a list\nnd_1 = np.array(list_obj,copy = False)\n#Case 2: use the default value for the copy parameter\nnd_2 = np.array(ndarray_obj)\n#Case 3: copy = false\nnd_3 = np.array(ndarray_obj,copy = False)\n# Case 4: change dtype\nnd_4 = np.array(ndarray_obj,copy = False,dtype = 'f')\n\nndarray_obj[1][1]=2\nlist_obj[1][1] =2\n\nprint(f\"The ndarray in case 1 is \\n {nd_1}\\n\")\nprint(f\"The ndarray in case 2 is \\n {nd_2}\\n\")\nprint(f\"The ndarray in case 3 is \\n {nd_3}\\n\")\nprint(f\"The ndarray in case 4 is \\n {nd_4}\\n\")\n"
      },
      {
        "id": "ex5",
        "title": "3.5 B1_Ch3_5.py",
        "filename": "B1_Ch3_5.py",
        "code": "# B1_Ch3_5.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\nimport numpy as np\nidentity_matrix = np.identity(3,dtype = 'i')\neye_matrix1 = np.eye(3,dtype ='i')\neye_matrix2 = np.eye(3,2,dtype ='f')\neye_matrix3 = np.eye(3,3,1,dtype = 'i')\neye_matrix4 = np.eye(3,3,-1)\nprint(f'The identity matrix is \\n {identity_matrix}')\nprint(f'The identity matrix created by eye function: \\n {eye_matrix1}')\nprint(f'The 3×2 matrix is \\n {eye_matrix2}')\nprint(f'The index of the diagonal is 1: \\n {eye_matrix3}')\nprint(f'The index of the diagonal is -1: \\n {eye_matrix4}')\n"
      },
      {
        "id": "ex6",
        "title": "3.6 B1_Ch3_6.py",
        "filename": "B1_Ch3_6.py",
        "code": "# B1_Ch3_6.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nx = y = np.linspace(-10, 10, 150)\nX, Y = np.meshgrid(x, y,indexing = 'xy')\n\nZ = np.cos(X) * np.sin(Y) * np.exp(-(X/5)**2-(Y/5)**2)\nfig, ax = plt.subplots(figsize=(6, 5))\nnorm = mpl.colors.Normalize(-abs(Z).max(), abs(Z).max())\np = ax.pcolor(X, Y, Z, norm=norm, cmap=mpl.cm.bwr)\nplt.colorbar(p)"
      }
    ]
  },
  {
    "id": "b1_ch4",
    "title": "第4章：數學工具",
    "number": 4,
    "content": {
      "intro": {
        "title": "第 4 章：數學工具套件 - 詳解",
        "roadmap": {
          "guide": "本章將數學理論與 Python 工具結合。利用 SciPy 與 SymPy 解決金融工程中常見的求導、積分與線性代數分解問題。",
          "objectives": "駕馭符號數學與科學計算。結合 SciPy 的強大算法庫與 SymPy 的解析引擎，解決金融工程中常見的求導、積分、線性代數分解與統計隨機性問題。",
          "topics": "*   4.1 矩陣元素統計計算 (mean, std, sum)\n*   4.2 數值圓整 (Round, Floor, Ceil)\n*   4.3 矩陣基本運算 (Element-wise)\n*   4.4 線性代數計算 (Dot product, Inverse)\n*   4.5 矩陣分解初探\n*   4.6 一元函數符號運算式 (SymPy)\n*   4.7 多元函數符號運算式\n*   4.8 符號函數矩陣實作"
        },
        "value": {
          "practical": "*   **實務場景**：構建結構型產品的定價引擎與希臘字母監控系統。\n*   **考試重點**：矩陣運算的性質與統計分佈的性質驗證。",
          "theory": "*   **風險演算法的穩定性**：線性代數中的矩陣分解（如：Cholesky 分解）是用於將獨立的隨機變數轉化為具有特定相關性的金融因子。\n*   **希臘字母與解析解**：利用 SymPy 的符號演算，可以直接對 Black-Scholes 公式求一階導（Delta）或二階導（Gamma），獲得精確解析解。",
          "further_reading": "*   利用 SciPy 進行非線性規劃（Optimization）的初步探索。"
        },
        "implementation": {
          "python": "*   **SciPy.stats**：內建所有 FRM 涉及的統計分佈（正態、t、F、卡方分佈），一鍵獲取分位點（Quantile）。\n*   **SymPy**：像人類一樣推導數學公式，減少手算錯誤。",
          "logic": "*   `scipy.linalg`：處理矩陣分解與特徵值計算，應用於主成分分析（PCA）風險建模。\n*   `sympy.diff()`：自動執行微積分對沖策略的靈敏度分析。",
          "scenarios": "| 腳本名稱 | 核心使命 |\n| :--- | :--- |\n| **B1_Ch4_1.py** | 使用 np.argmax 查找風險因子中的最大權重或極值位置。 |\n| **B1_Ch4_2.py** | 實作矩陣乘法 (Dot Product) 與內積運算，模擬投資組合收益計算。 |\n| **B1_Ch4_3.py** | 演示線性方程組的數值解法，驗證解的精確度。 |\n| **B1_Ch4_4.py** | 實作特徵值 (Eigenvalues) 與特徵向量分解，應用於風險主成分分析。 |\n| **B1_Ch4_5.py** | 演示矩陣的逆 (Inverse) 與行列式 (Determinant) 的計算意義。 |\n| **B1_Ch4_6.py** | 演示稀疏矩陣 (Sparse Matrix) 的存儲優化與基本運算。 |\n| **B1_Ch4_7.py** | 利用 NumPy 進行多項式擬合與回歸曲線分析。 |\n| **B1_Ch4_8.py** | 演示函數項符號運算，定義複雜金融定價公式的導函數。 |\n| **B1_Ch4_9.py** | 實作 SymPy 符號微分，自動計算 Black-Scholes 模型對風險因子的偏導。 |\n| **B1_Ch4_10.py** | 利用 SymPy 對多元符號矩陣進行數值代換與求值。 |"
        },
        "body": "### 4.1 矩陣元素統計計算 (mean, std, sum)\n\n#### 概念定義\nNumPy 提供沿指定軸 (axis) 計算統計量的函數：\n- `np.mean()`：算術平均\n- `np.std()`：標準差\n- `np.var()`：變異數\n- `np.sum()`：總和\n\n`axis=0` 沿列（跨時間），`axis=1` 沿行（跨資產）。\n\n#### 財金理論背景\n風險管理核心指標皆基於這些統計量：\n- **期望報酬率**：$\\mu = \\frac{1}{n}\\sum R_i$\n- **波動率**：$\\sigma = \\sqrt{\\text{Var}(R)}$\n- **投資組合報酬**：$R_p = \\sum w_i R_i$\n\n#### 數學公式或模型\n樣本標準差（無偏估計）：\n$$\n\\sigma = \\sqrt{\\frac{1}{n-1}\\sum_{i=1}^{n}(x_i - \\bar{x})^2}\n$$\n\n#### Python 實現邏輯\n```python\nimport numpy as np\n\n# 報酬率矩陣：252 天 × 5 資產\nreturns = np.random.randn(252, 5) * 0.02\n\n# 各資產平均報酬（axis=0：沿時間軸）\nmean_returns = np.mean(returns, axis=0)  # shape: (5,)\n\n# 各資產波動率（使用 ddof=1 為無偏估計）\nvolatility = np.std(returns, axis=0, ddof=1)\n\n# 年化\nannual_return = mean_returns * 252\nannual_vol = volatility * np.sqrt(252)\n\n# 累積報酬\ncumulative = np.sum(returns, axis=0)\n```\n\n#### 常見陷阱與注意事項\n- **ddof 參數**：預設 `ddof=0`（母體標準差），金融常用 `ddof=1`（樣本）\n- **axis 混淆**：`axis=0` 消除第一維，結果形狀為其餘維度\n- **NaN 處理**：使用 `np.nanmean()` 忽略缺失值\n\n#### 實務應用場景\n- 計算多資產的歷史波動率\n- 評估投資組合的夏普比率\n- 壓力測試中計算極端損失的統計特徵\n\n#### 與其他章節的關聯\n這些統計量是 Ch8-Ch9 機率統計章節的計算基礎，也用於 Ch12 固定收益的殖利率分析。\n\n---\n\n### 4.2 數值圓整 (Round, Floor, Ceil)\n\n#### 概念定義\n數值圓整控制精度：\n- `np.round()`：四捨五入\n- `np.floor()`：向下取整\n- `np.ceil()`：向上取整\n- `np.trunc()`：截斷小數\n\n#### 財金理論背景\n金融交易有最小變動單位限制：\n- **股票價格**：最小跳動 0.01 元\n- **期貨張數**：必須為整數\n- **交易金額**：銀行家舍入避免系統性偏差\n\n#### Python 實現邏輯\n```python\n# 價格四捨五入到兩位小數\nprice = 123.456789\nrounded = np.round(price, 2)  # 123.46\n\n# 期貨張數（向下取整）\ncapital = 1000000\ncontract_value = 123456\nmax_contracts = np.floor(capital / contract_value)  # 8.0\n\n# 風險限額（向上取整確保保守）\nrisk_budget = np.ceil(var * 1.05)\n\n# 銀行家舍入（Python 3 內建 round 行為）\n# np.round 在 .5 時向偶數舍入\nprint(np.round(2.5))  # 2.0\nprint(np.round(3.5))  # 4.0\n```\n\n#### 常見陷阱與注意事項\n- **返回類型**：`np.floor()` 返回 float，需 `.astype(int)` 轉整數\n- **負數行為**：`floor(-2.5)` = -3，`trunc(-2.5)` = -2\n- **浮點誤差**：`round(2.675, 2)` 可能不是 2.68\n\n#### 實務應用場景\n- 計算可交易的最大張數\n- 報表金額格式化\n- 滿足交易所最小跳動單位\n\n#### 與其他章節的關聯\n在 Ch10-Ch11 金融計算中，圓整用於處理離散複利計算與口數分配。\n\n---\n\n### 4.3 矩陣基本運算 (Element-wise)\n\n#### 概念定義\nNumPy 算術運算預設為**元素級 (Element-wise)**：\n- `A + B`：對應元素相加\n- `A * B`：對應元素相乘（非矩陣乘法！）\n- `A ** 2`：每個元素平方\n- 支援廣播機制 (Broadcasting)\n\n#### 財金理論背景\n元素級運算簡化計算：\n- **超額報酬**：$R^e = R - R_f$（減去無風險利率）\n- **對數報酬**：$r = \\ln(1 + R)$\n- **年化轉換**：$\\sigma_{annual} = \\sigma_{daily} \\times \\sqrt{252}$\n\n#### 數學公式或模型\n對數報酬率轉換：\n$$\nr_t = \\ln\\left(\\frac{P_t}{P_{t-1}}\\right) = \\ln(P_t) - \\ln(P_{t-1})\n$$\n\n#### Python 實現邏輯\n```python\n# 元素級運算\nreturns = np.array([0.01, -0.02, 0.03])\nrf = 0.001\n\n# 超額報酬（廣播：標量擴展到陣列）\nexcess = returns - rf\n\n# 對數報酬\nprices = np.array([100, 102, 99, 105])\nlog_returns = np.log(prices[1:] / prices[:-1])\n# 或\nlog_returns = np.diff(np.log(prices))\n\n# 平方（計算變異數）\nsquared_dev = (returns - returns.mean()) ** 2\n\n# 常用數學函數\nnp.exp(returns)    # 指數\nnp.sqrt(variance)  # 平方根\nnp.abs(returns)    # 絕對值\n```\n\n#### 常見陷阱與注意事項\n- **`*` 不是矩陣乘法**：使用 `@` 或 `np.dot()`\n- **形狀必須兼容**：廣播規則需滿足\n- **原地運算**：`A += B` 修改原陣列，`A = A + B` 創建新陣列\n\n#### 實務應用場景\n- 批量計算多資產報酬率\n- 向量化風險因子變換\n- 蒙地卡羅路徑的統一處理\n\n#### 與其他章節的關聯\n元素級運算是向量化編程的基礎，在 Ch5 Pandas 中透過 `.apply()` 或直接運算實現。\n\n---\n\n### 4.4 線性代數計算 (Dot product, Inverse)\n\n#### 概念定義\n線性代數核心運算：\n- **矩陣乘法**：`A @ B` 或 `np.dot(A, B)`\n- **反矩陣**：`np.linalg.inv(A)`\n- **解線性方程**：`np.linalg.solve(A, b)`\n- **行列式**：`np.linalg.det(A)`\n\n#### 財金理論背景\n投資組合優化依賴線性代數：\n- **組合報酬**：$R_p = \\mathbf{w}^T \\mathbf{R}$\n- **組合變異數**：$\\sigma_p^2 = \\mathbf{w}^T \\mathbf{\\Sigma} \\mathbf{w}$\n- **最小變異組合權重**：$\\mathbf{w}^* = \\frac{\\mathbf{\\Sigma}^{-1} \\mathbf{1}}{\\mathbf{1}^T \\mathbf{\\Sigma}^{-1} \\mathbf{1}}$\n\n#### 數學公式或模型\n解線性方程組 $A\\mathbf{x} = \\mathbf{b}$：\n$$\n\\mathbf{x} = A^{-1}\\mathbf{b}\n$$\n\n#### Python 實現邏輯\n```python\n# 投資組合計算\nweights = np.array([0.4, 0.3, 0.3])\nreturns = np.array([0.08, 0.10, 0.06])\ncov_matrix = np.array([\n    [0.04, 0.01, 0.005],\n    [0.01, 0.09, 0.02],\n    [0.005, 0.02, 0.01]\n])\n\n# 組合報酬\nport_return = weights @ returns  # 0.076\n\n# 組合變異數\nport_var = weights @ cov_matrix @ weights  # 標量\n\n# 最小變異組合\nones = np.ones(3)\ninv_cov = np.linalg.inv(cov_matrix)\nmin_var_weights = inv_cov @ ones / (ones @ inv_cov @ ones)\n\n# 解線性方程（比求逆更穩定）\nb = np.array([1, 0, 0])\nx = np.linalg.solve(cov_matrix, b)\n```\n\n#### 常見陷阱與注意事項\n- **奇異矩陣**：非滿秩矩陣無法求逆，使用偽逆 `np.linalg.pinv()`\n- **數值穩定性**：優先用 `solve()` 而非 `inv()`\n- **維度匹配**：(m×n) @ (n×p) → (m×p)\n\n#### 實務應用場景\n- Markowitz 均值-變異數優化\n- 因子暴露度計算\n- 對沖比率求解\n\n#### 與其他章節的關聯\n本節是 Ch4.5 矩陣分解的前置知識，也是 Ch10-Ch11 最佳化計算的基礎。\n\n---\n\n### 4.5 矩陣分解初探\n\n#### 概念定義\n矩陣分解將矩陣表示為其他矩陣的乘積：\n- **Cholesky**：$A = LL^T$（正定矩陣）\n- **SVD**：$A = U\\Sigma V^T$（任意矩陣）\n- **特徵分解**：$A = Q\\Lambda Q^{-1}$\n\n#### 財金理論背景\n- **Cholesky**：蒙地卡羅模擬生成相關隨機變數\n- **SVD/PCA**：風險因子降維，識別主要風險來源\n- **特徵分解**：分析協方差矩陣的主成分\n\n#### 數學公式或模型\nCholesky 分解用於相關性轉換：\n$$\n\\mathbf{Z}_{correlated} = L \\cdot \\mathbf{Z}_{independent}\n$$\n其中 $L$ 是協方差矩陣 $\\Sigma$ 的 Cholesky 下三角因子。\n\n#### Python 實現邏輯\n```python\n# Cholesky 分解\ncov = np.array([[1.0, 0.8], [0.8, 1.0]])\nL = np.linalg.cholesky(cov)\n\n# 生成相關隨機變數\nn_sims = 10000\nz_indep = np.random.randn(2, n_sims)\nz_corr = L @ z_indep  # 具有相關性的隨機變數\n\n# SVD 分解\nU, S, Vt = np.linalg.svd(returns_matrix)\n# 保留前 k 個主成分\nk = 3\nreturns_approx = U[:, :k] @ np.diag(S[:k]) @ Vt[:k, :]\n\n# 特徵分解\neigenvalues, eigenvectors = np.linalg.eig(cov)\n# 主成分解釋比例\nexplained_ratio = eigenvalues / eigenvalues.sum()\n```\n\n#### 常見陷阱與注意事項\n- **正定性要求**：Cholesky 要求矩陣正定，非正定拋出 `LinAlgError`\n- **數值精度**：接近奇異的矩陣可能導致分解不穩定\n- **SVD vs Eig**：SVD 數值更穩定，Eig 對稱矩陣效率高\n\n#### 實務應用場景\n- 蒙地卡羅 VaR 的多資產模擬\n- 風險因子的 PCA 降維\n- 相關性矩陣的平滑處理\n\n#### 與其他章節的關聯\nCholesky 分解在 Ch8 隨機變數生成中直接應用，PCA 則用於 Ch9 的統計分析。\n\n---\n\n### 4.6 一元函數符號運算式 (SymPy)\n\n#### 概念定義\n**SymPy** 提供符號數學運算，區別於數值計算：\n- 符號變數：`x = symbols('x')`\n- 符號表達式：`f = x**2 + 2*x + 1`\n- 解析操作：微分、積分、化簡、求解\n\n#### 財金理論背景\n金融模型常需要解析解：\n- **Delta 對沖**：$\\Delta = \\frac{\\partial C}{\\partial S}$\n- **隱含波動率**：解 $C_{market} = C_{BS}(\\sigma)$ 求 $\\sigma$\n- **久期公式**：$D = -\\frac{1}{P}\\frac{dP}{dy}$\n\n#### Python 實現邏輯\n```python\nfrom sympy import symbols, diff, integrate, solve, exp, sqrt, log\n\n# 定義符號變數\nx = symbols('x')\nS, K, r, T, sigma = symbols('S K r T sigma', positive=True)\n\n# 建立表達式\nf = x**3 - 6*x**2 + 11*x - 6\n\n# 微分\ndf = diff(f, x)  # 3*x**2 - 12*x + 11\n\n# 積分\nF = integrate(f, x)  # x**4/4 - 2*x**3 + 11*x**2/2 - 6*x\n\n# 求解方程\nroots = solve(f, x)  # [1, 2, 3]\n\n# 代入數值\nresult = f.subs(x, 2)  # 0\n\n# 轉為數值函數\nfrom sympy import lambdify\nf_numeric = lambdify(x, f, 'numpy')\nvalues = f_numeric(np.array([1, 2, 3]))\n```\n\n#### 常見陷阱與注意事項\n- **符號 vs 數值**：SymPy 符號不能直接用於 NumPy 計算\n- **化簡**：使用 `simplify()` 或 `trigsimp()` 化簡複雜表達式\n- **效能**：符號計算比數值計算慢，生產環境用 `lambdify` 轉換\n\n#### 實務應用場景\n- 推導 Black-Scholes Greeks 的解析式\n- 驗證手工推導的數學公式\n- 生成可讀的金融模型文檔\n\n#### 與其他章節的關聯\n符號微分直接用於 Ch10-Ch11 計算 Delta、Gamma 等敏感度，以及 Ch12 久期計算。\n\n---\n\n### 4.7 多元函數符號運算式\n\n#### 概念定義\n處理多變數函數的符號運算：\n- **偏微分**：$\\frac{\\partial f}{\\partial x_i}$\n- **多變數方程組**：聯立求解\n- **泰勒展開**：多維近似\n\n#### 財金理論背景\nBlack-Scholes 公式是多元函數：\n$$\nC = C(S, K, T, r, \\sigma)\n$$\n各 Greeks 是對不同變數的偏導數。\n\n#### 數學公式或模型\n選擇權的 Delta 和 Gamma：\n$$\n\\Delta = \\frac{\\partial C}{\\partial S}, \\quad \\Gamma = \\frac{\\partial^2 C}{\\partial S^2}\n$$\n\n#### Python 實現邏輯\n```python\nfrom sympy import symbols, diff, exp, sqrt, log\nfrom sympy.stats import Normal, cdf\n\n# 定義多個符號變數\nS, K, r, T, sigma = symbols('S K r T sigma', positive=True, real=True)\n\n# Black-Scholes d1, d2\nd1 = (log(S/K) + (r + sigma**2/2)*T) / (sigma*sqrt(T))\nd2 = d1 - sigma*sqrt(T)\n\n# 簡化版 BS Call（使用符號 CDF）\nfrom sympy import Function\nN = Function('N')  # 標準常態 CDF\nCall = S * N(d1) - K * exp(-r*T) * N(d2)\n\n# 計算 Greeks\nDelta = diff(Call, S)\nGamma = diff(Call, S, 2)  # 二階導\nVega = diff(Call, sigma)\nTheta = diff(Call, T)\nRho = diff(Call, r)\n\n# 多元方程求解\nfrom sympy import Eq, solve\neq1 = Eq(x + y, 10)\neq2 = Eq(x - y, 2)\nsolution = solve([eq1, eq2], [x, y])  # {x: 6, y: 4}\n```\n\n#### 常見陷阱與注意事項\n- **變數假設**：添加 `positive=True` 等約束以獲得更簡潔結果\n- **CDF 處理**：SymPy 內建 CDF 較複雜，常用 `Function('N')` 佔位\n- **表達式膨脹**：多次微分可能導致表達式過長\n\n#### 實務應用場景\n- 自動生成完整的 Greeks 公式\n- 推導新型衍生品的定價公式\n- 驗證學術論文的數學推導\n\n#### 與其他章節的關聯\n多元微分是 Ch10-Ch11 泰勒展開近似和敏感度分析的基礎。\n\n---\n\n### 4.8 符號函數矩陣實作\n\n#### 概念定義\nSymPy 支援符號矩陣：\n- **Matrix 類別**：支援符號元素\n- **矩陣微分**：對矩陣求導\n- **Jacobian/Hessian**：多元函數的導數矩陣\n\n#### 財金理論背景\n風險敏感度分析涉及矩陣微分：\n- **Jacobian**：多輸出對多輸入的一階導\n- **Hessian**：二階偏導矩陣，用於凸性分析\n- **協方差矩陣的符號表示**：推導組合風險\n\n#### 數學公式或模型\nHessian 矩陣：\n$$\nH_{ij} = \\frac{\\partial^2 f}{\\partial x_i \\partial x_j}\n$$\n\n對於二元函數 $f(x, y)$：\n$$\nH = \\begin{pmatrix} f_{xx} & f_{xy} \\\\ f_{yx} & f_{yy} \\end{pmatrix}\n$$\n\n#### Python 實現邏輯\n```python\nfrom sympy import Matrix, symbols, hessian, diff\n\n# 符號矩陣\nx, y, z = symbols('x y z')\nw = Matrix([x, y, z])  # 權重向量\n\n# 協方差矩陣（符號）\nsigma_11, sigma_12, sigma_22 = symbols('sigma_11 sigma_12 sigma_22')\nSigma = Matrix([\n    [sigma_11, sigma_12],\n    [sigma_12, sigma_22]\n])\n\n# 矩陣轉置與乘法\nw_2d = Matrix([x, y])\nport_var = w_2d.T * Sigma * w_2d  # 組合變異數\n\n# Hessian 矩陣\nf = x**2 + x*y + y**2\nH = hessian(f, [x, y])\n# Matrix([[2, 1], [1, 2]])\n\n# Jacobian 矩陣\nfrom sympy import Matrix\nF = Matrix([x**2 + y, x*y + z])\nJ = F.jacobian([x, y, z])\n\n# 數值代換\nresult = port_var.subs([(x, 0.5), (y, 0.5), (sigma_11, 0.04), (sigma_12, 0.01), (sigma_22, 0.09)])\n```\n\n#### 常見陷阱與注意事項\n- **矩陣乘法**：SymPy 使用 `*`，不是 `@`\n- **結果形狀**：`w.T * Sigma * w` 返回 1×1 Matrix，需 `[0,0]` 取標量\n- **簡化**：矩陣表達式可能需要 `.simplify()` 清理\n\n#### 實務應用場景\n- 推導投資組合優化的 KKT 條件\n- 分析債券組合的凸性矩陣\n- 驗證多因子模型的敏感度\n\n#### 與其他章節的關聯\n符號矩陣技術可用於 Ch12 推導債券久期與凸性的精確公式，也用於 Ch10-Ch11 的最佳化問題。"
      }
    },
    "examples": [
      {
        "id": "ex1",
        "title": "4.1 B1_Ch4_1.py",
        "filename": "B1_Ch4_1.py",
        "code": "# B1_Ch4_1.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\nimport numpy as np\na=np.arange(9).reshape(3,3)-1\n\n#max()\nprint(a.max(axis=1))#Out: [1 4 7], Return the max value in each row\nprint(np.max(a,axis=0))#Out: [5 6 7], Return the max value in each column\nprint(a.max())#Out: 7, Return the max value of the whole matrix\n\n#argmax()\nprint(a.argmax(axis=1))#Out: [2 2 2], Return the indices of the maximum values along each row\nprint(np.argmax(a,axis=0))#Out: Out: [2 2 2], Return the indices of the maximum values along each column\nprint(a.argmax())#Out: 8, Return the index of the max value of the whole matrix\n\n#sum()\nprint(a.sum())#Out: 27, Calculate the sum of all the element of the matrix\nprint(np.sum(a,axis=0))#Out: [6 9 12],Calculate the sum of each column\nprint(a.sum(axis=1))#Out: [0 9 18],Calculate the sum of eac row\n\n#all()\nprint(a.all())#Out: False, Test whether all array elements are True\nprint(a.all(axis=0))#Out: False, Test whether all array elements in each column are True\nprint(np.all(a,axis=1))#Out: False, Test whether all array elements in each row are True\n\n#any()\nprint(a.any())#Out: True, Test whether any array elements are True\nprint(a.any(axis=0))#Out: [ True  True  True], Test whether any array elements in each column are True\nprint(np.any(a,axis=1))#Out: [ True  True  True], Test whether any array elements in each row are True\n\n#clip()\nprint(a.clip(3,6))\n#Out: [[3 3 3],[3 3 4], [5 6 6]]\n\n#ptp()\nprint(a.ptp())#Out: 8, return the range of values (maximum - minimum) of the matrix.\nprint(a.ptp(axis=0))#Out: [6 6 6], return the range of values (maximum - minimum) in each column.\nprint(a.ptp(axis=1))#Out: [2 2 2], return the range of values (maximum - minimum) in each row.\n\n"
      },
      {
        "id": "ex2",
        "title": "4.2 B1_Ch4_2.py",
        "filename": "B1_Ch4_2.py",
        "code": "# B1_Ch4_2.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\nimport numpy as np\nfrom scipy.linalg import pascal\n# Use left array division to solve\nA = pascal(3)\nB = np.array([3,1,4]).reshape(3,1,)\nx1,resid,rank,s = np.linalg.lstsq(A,B)\nprint(f'Calculating left array division by lstsq() function: {x1}')\nx2=np.linalg.solve(A,B)\nprint(f'Calculating left array division by solve() function: {x2}')\nx3=(np.linalg.inv(A))@B\nprint(f'Calculating left array division by the inverse of the matrix: {x3}')\n# Use right array division solve xA=b\nA = np.array([[1,1,3], [2,0,4], [-1,6,-1]])\nB = np.array([2,19,8])\n\nx=B@np.linalg.inv(A)\nprint(f'Calculating right array division by the inverse of the matrix: {x}')\n"
      },
      {
        "id": "ex3",
        "title": "4.3 B1_Ch4_2.py",
        "filename": "B1_Ch4_3.py",
        "code": "# B1_Ch4_2.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\nimport numpy as np\nA=np.array([[3,2,4],[2,0,2],[4,2,3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\neigenvalues=eigenvalues.round(1)\nindex =['first','second','third']\nfor i, eigenvalue in enumerate(eigenvalues):\n    print(f'The {index[i]} eigenvalue is \\n {eigenvalue}')\n    print(f'The eigenvectors for the {index[i]} eigenvalue are: \\n {eigenvectors[:,i]}')\n    print('Validation:')\n    print(f'Ax={A@eigenvectors[:,i]}')\n    print(f'\\u03BBx={eigenvalue*eigenvectors[:,i]}')\n"
      },
      {
        "id": "ex4",
        "title": "4.4 B1_Ch4_4.py",
        "filename": "B1_Ch4_4.py",
        "code": "# B1_Ch4_4.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\nimport numpy as np\nfrom scipy.linalg import ldl\nA = np.array([[2, -1, 0],\n               [-1, 2, -1],\n               [0, -1, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint(f'Check if Matrix A is positive-definite by using the eigenvalues: \\n {eigenvalues}')\nprint(f'Check if Matrix A is a Hermitian matrix or not: \\n A.T=\\n{A.T}')\nL, D, P = ldl(A)\nprint(f'L matrix is: \\n {L}')\nprint(f'D matrix is: \\n {D}')\nprint(f'Check if A=LDL.T:\\n {np.isclose(L@D@L.T-A,0)}')\n"
      },
      {
        "id": "ex5",
        "title": "4.5 B1_Ch4_5.py",
        "filename": "B1_Ch4_5.py",
        "code": "# B1_Ch4_5.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\nfrom sympy import symbols, sympify\nimport sympy\n\nu1, u2, u3, u4, v1, v2 = symbols('u1 u2 u3 u4 v1 v2')\n\nequationsList = [\"sin(u1)+4\", \"(u2*3)+4\", \"log(u3)+6*v1\", \"(u4*3)+v2\"]\n\nexpressions = [sympify(expr) for expr in equationsList]\n\nvalues = {u1: 1, u2: 2, u3: 3, u4: 4, v1: -1, v2: -2}\n\nfor expression in expressions:\n    print('{:10s} ->  {:4d}'.format(str(expression),\n                                    int(expression.subs(values))))\n"
      },
      {
        "id": "ex6",
        "title": "4.6 B1_Ch4_6.py",
        "filename": "B1_Ch4_6.py",
        "code": "# B1_Ch4_6.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\nimport sympy as sym\nx, y, z = sym.symbols(\"x y z\")\nf1 = 2*sym.sin(x)\nf2 = sym.sin(x)+y**2+sym.log(z)\n\nvalue1 =f1.evalf(subs={x: 2.4})\nvalue2=f2.evalf(subs={x: 1,y:2,z:3})\n\nf3 = f1.subs(x,x**2)\nf4 = f2.subs({x:x**2,y:sym.cos(y),z:sym.tan(z)})\nprint(value1)\nprint(value2)\nprint(f3)\nprint(f4)\n"
      },
      {
        "id": "ex7",
        "title": "4.7 B1_Ch4_7.py",
        "filename": "B1_Ch4_7.py",
        "code": "# B1_Ch4_7.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\nfrom sympy import symbols\nfrom sympy.plotting import plot\nimport sympy as sym\nimport matplotlib.pyplot as plt\nx=symbols('x')\n\nplot1=plot(sym.sin(x)/x,(x,-15,15),show=True)\n\nplot1.xlabel='x'\nplot1.ylabel='f(x)'\nplot2=plot(sym.sin(x)/x,(x,-50,50),nb_of_points=1000,adaptive=False)\n\nplot3=plot(sym.sin(x)/x,(x,-500,500),nb_of_points=1000,adaptive=False)\nplot2.show()\nplot3.show()\nplot2.xlabel='x'\nplot2.ylabel='f(x)'\nplot3.xlabel='x'\nplot3.ylabel='f(x)'\nlimit1=sym.limit(sym.sin(x)/x,x,0)\nlimit2=sym.limit(sym.sin(x)/x,x,sym.oo)\nprint(f'When x approaches 0, f(x) approaches {limit1}')\nprint(f'When x approaches ∞, f(x) approaches {limit2}')\n"
      },
      {
        "id": "ex8",
        "title": "4.8 B1_Ch4_8.py",
        "filename": "B1_Ch4_8.py",
        "code": "# B1_Ch4_8.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\nimport sympy as sym\nfrom sympy import *\nfrom sympy import Eq, And\nimport math\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom sympy.plotting import plot,PlotGrid\nplt.close('all')\n\nx,y = symbols('x y')\n\nf_x = 3*sin(x)-x\nf_x_diff = sym.diff(f_x,x)\nf_x_diff2 = sym.diff(f_x,x,2)\n\np1 = sym.plot(f_x,(x,-2*sym.pi,2*sym.pi),show=False,title=f_x)\np2 = sym.plot(f_x_diff,(x,-2*sym.pi,2*sym.pi),show=False,title=f_x_diff)\np3 = sym.plot(f_x_diff2,(x,-2*sym.pi,2*sym.pi),show=False,title=f_x_diff2)\n\nzero_point = acos(1/3)\nzero_point_v = [(-zero_point+2*math.pi),-(-zero_point+2*math.pi),zero_point,-zero_point]\nzero_point_v.sort()\n\nfor i in zero_point_v:\n    p = sym.plot_implicit(Eq(x,i),(x,-6,6),(y,-8,8),show=False)\n    p1.extend(p)\n    p2.extend(p)\n\nplot_range = [-6]+zero_point_v+[6]\nfor i in range(len(plot_range)-1):\n    if f_x_diff.evalf(subs={x: plot_range[i]+0.1})>0:\n        pp1 = sym.plot_implicit(And(y<f_x_diff,y>0),\n                                (x,plot_range[i],plot_range[i+1]),\n                                (y,-8,8),\n                                line_color='blue',\n                                show=False)\n        pp2 = sym.plot_implicit(And(y<f_x,y>0),\n                                (x,plot_range[i],\n                                 plot_range[i+1]),\n                                (y,-8,8),\n                                line_color='blue',\n                                show=False)\n        pp3 = sym.plot_implicit(And(y>f_x,y<0),\n                                (x,plot_range[i],plot_range[i+1]),\n                                (y,-8,8),\n                                line_color='blue',\n                                show=False)\n    else:\n        pp1 = sym.plot_implicit(And(y>f_x_diff,y<0),\n                                (x,plot_range[i],plot_range[i+1]),\n                                (y,-8,8),\n                                line_color='red', \n                                show=False)\n        pp2 = sym.plot_implicit(And(y<f_x,y>0),\n                                (x,plot_range[i],plot_range[i+1]),\n                                (y,-8,8),\n                                line_color='red',\n                                show=False)\n        pp3 = sym.plot_implicit(And(y>f_x,y<0),\n                                (x,plot_range[i],\n                                 plot_range[i+1]),\n                                (y,-8,8),\n                                line_color='red',\n                                show=False) \n    p2.extend(pp1)\n    p1.extend(pp2)\n    p1.extend(pp3)\n    \np1.xlim=(-6,6)\np2.xlim=(-6,6)\np1.ylim=(-10,10)\np2.ylim=(-6,3)\n\np1.show()\np2.show()\np3.show()\n\ndef f1(x):\n    return -3*math.sin(x)\ndef trap(f, n,start,end):\n    h = (end-start) / float(n)\n    intgr = 0.5 * h * (f(start) + f(end))\n    for i in range(1, int(n)):\n        intgr = intgr + h * f(i * h+start)\n    return intgr\n\nIntegral_sympy = integrate(f_x_diff2,(x,0,2*math.pi))\nIntegral_trap = trap(f1,n=1000,start = 0,end=2*math.pi)\nprint(f'The integration of {f_x_diff2} by using SymPy integration fuction is: {Integral_sympy}')\nprint(f'The integration of {f_x_diff2} by using trapezium rule is: {np.round(Integral_trap)}')\n"
      },
      {
        "id": "ex9",
        "title": "4.9 B1_Ch4_9.py",
        "filename": "B1_Ch4_9.py",
        "code": "# B1_Ch4_9.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\nimport sympy as sym\nfrom sympy import symbols\nfrom sympy.plotting import plot3d, PlotGrid\nimport numpy as np\nimport matplotlib.pyplot as plt\nx, y = symbols(\"x y\")\n\nplt.close('all')\n\nf_xy = x**2*y**2\n# Calculate df(x,y)/dx\nf_xy_diff_x = sym.diff(f_xy,x)\n# Calculate df(x,y)/dy\nf_xy_diff_y = sym.diff(f_xy,y)\n# Calculate df(x,y)/dxdy\nf_xy_diff_xy = sym.diff(f_xy_diff_x,y)\n\nprint(f'f(xy)={f_xy}')\nprint(f'df/dx={f_xy_diff_x}')\nprint(f'df/dy={f_xy_diff_y}')\nprint(f'df/dxdy={f_xy_diff_xy}')\n\n# Evaluate f(x,y) at x=1,y=1\nvalue1=f_xy.evalf(subs={x: 1,y:1})\nprint(f'f(xy) at x=1,y=1 is equal to {value1}')\n\n# Calculate the integration of f(x,y) along x = [-1,1]\nIntegration1 = sym.integrate(f_xy,(x,-1,1))\n# Calculate the integration of f(x,y) along y = [-1,1]\nIntegration2 = sym.integrate(f_xy,(y,-1,1))\n# Calculate the integration of f(x,y) along x = [-1,1] and y = [-1,1]\nIntegration3 = sym.integrate(f_xy,(x,-1,1),(y,-1,1))\nprint(f'Calculate the integration of f(x,y) along x = [-1,1] : {Integration1}')\nprint(f'Calculate the integration of f(x,y) along x = [-1,1] : {Integration2}')\nprint(f'Calculate the integration of f(x,y) along x = [-1,1] and y = [-1,1]: {Integration3}')\n\np1=plot3d(f_xy,(x,-2,2),(y,-2,2),show=False)\np2=plot3d(f_xy_diff_x,(x,-2,2),(y,-2,2),show=False)\np3=plot3d(f_xy_diff_y,(x,-2,2),(y,-2,2),show=False)\np4=plot3d(f_xy_diff_xy,(x,-2,2),(y,-2,2),show=True)\nPlotGrid(4,1,p1,p2,p3,p4)\n"
      },
      {
        "id": "ex10",
        "title": "4.10 B1_Ch4_10.py",
        "filename": "B1_Ch4_10.py",
        "code": "# B1_Ch4_10.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\nimport sympy as sym\nfrom sympy import symbols, Matrix\nx,y=symbols('x y')\n\nf11,f12,f13=x*y,1,sym.exp(x)+y\nf21,f22,f23=x**2,y**2,sym.sin(x)\nf31,f32,f33=sym.exp(x)*y,x**2+y**2,sym.log(x)\n\nM=Matrix([[f11,f12,f13],[f21,f22,f23],[f31,f32,f33]])\n\n# Evaluate the values of the symbolic matrix at x = 1,y=2\npoints = {x:1,y:2}\nvalues = M.subs(points)\nprint(f'The symbolic matrix at x=1,y=2 is equal to: \\n {values}')\n\n# Calculate the derivative of Matrix with respect to x\nM_diff_x = sym.diff(M,x)\nprint(f'dM/dx is\\n {M_diff_x}')\n\n# Calculate the derivative of Matrix with respect to y\nM_diff_y = sym.diff(M,y)\nprint(f'dM/dy is\\n {M_diff_y}')\n\n# Calculte the derivative of Matrix M with respect to x and then y\nM_diff_xy = sym.diff(M_diff_x,y)\nprint(f'dM/dxdy is\\n {M_diff_xy}')\n\n# Calculate the indefinite integral of M with respect to x\nM_integration_x = sym.integrate(M,(x,0,1))\nprint(f'The integral of M for x in the range of (1,2) is {M_integration_x}')\n\n# Calculate the indefinite integral of M in the ranges of (0,1) for x and y\nM_integration_xy = sym.integrate(M_integration_x,(y,0,1))\nprint(f'The integral of M for x and y in the range of (0,1) is {M_integration_xy}')\n"
      }
    ]
  },
  {
    "id": "b1_ch5",
    "title": "第5章：Pandas 與資料分析 I",
    "number": 5,
    "content": {
      "intro": {
        "title": "第 5 章：Pandas 與資料分析 I - 詳解",
        "roadmap": {
          "guide": "掌握金融建模的工業級工具 Pandas。本章旨在教會學習者如何處理結構化的金融序列（Series）與表格（DataFrame）。",
          "objectives": "掌握金融建模的工業級工具 **Pandas**。本章旨在教會學習者如何處理結構化的金融序列（Series）與表格（DataFrame），並精確執行標籤基礎（Label-based）與位置基礎（Position-based）的數據選取。",
          "topics": "*   5.1 Pandas 套件匯入與資料結構簡介\n*   5.2 序列 (Series) 建立與特性\n*   5.3 序列資料選取與篩選\n*   5.4 資料框 (DataFrame) 建立\n*   5.5 DataFrame 的資料選擇 (loc, iloc)\n*   5.6 序列與 DataFrame 的基本算術運算\n*   5.7 索重引、更新索引與重建索引 (Reindex)"
        },
        "value": {
          "practical": "*   **實務場景**：將原始成交數據（Raw Tick Data）轉換為標準頻率的開高低收數據（OHLC）。\n*   **考試重點**：理解數據清洗細節如何影響 VaR（風險價值）的歷史模擬精確度。",
          "theory": "*   **數據對齊與向量化**：金融表格處理的核心是「對齊」。當我們計算多個資產的報酬率時，Pandas 能自動根據日期索引（Datetime Index）對齊數據，避免了手動處理數值錯位的風險。\n*   **矩陣思維的擴展**：將 NumPy 的高速與 Excel 的標籤化標題結合，形成了金融數據的「大腦」。",
          "further_reading": "*   Pandas 中的 `MultiIndex`（多維層次索引）在資產多級分類中的應用。"
        },
        "implementation": {
          "python": "*   **解決 Excel 瓶頸**：Excel 在處理 10 萬行以上的行情數據時會變得緩慢且易崩潰，Pandas 能在數毫秒內完成處理。\n*   **Time Series 支援**：內建強大的時間序列分析功能，如：重採樣（Resampling）與滑動窗口計算。",
          "logic": "*   `pd.Series()` / `pd.DataFrame()`：核心資料結構。\n*   `.loc[]` 與 `.iloc[]`：實現精確、高效的數據檢索，區分邏輯索引與物理索引。\n*   `reindex()`：解決時序數據對齊問題的黃金函數。",
          "scenarios": "| 腳本名稱 | 核心使命 |\n| :--- | :--- |"
        },
        "body": "### 5.1 Pandas 套件匯入與資料結構簡介\n\n#### 概念定義\n**Pandas** 是 Python 資料分析的核心套件，建構於 NumPy 之上，提供兩種主要資料結構：\n- **Series**：帶標籤索引的一維陣列\n- **DataFrame**：帶行/列標籤的二維表格\n\n#### 財金理論背景\n金融數據本質上是表格化的：\n- **時間序列**：日期索引 + 價格/報酬率\n- **橫截面數據**：資產代碼 + 財務指標\n- **面板數據**：時間 × 資產 的二維結構\n\nPandas 是處理這類結構的標準工具，取代 Excel 成為業界首選。\n\n#### Python 實現邏輯\n```python\nimport pandas as pd\nimport numpy as np\n\n# 基本結構\nprint(pd.__version__)  # 確認版本\n\n# Series：帶標籤的一維陣列\nreturns = pd.Series([0.01, -0.02, 0.03], \n                    index=['2024-01-01', '2024-01-02', '2024-01-03'],\n                    name='AAPL_return')\n\n# DataFrame：二維表格\ndata = {\n    'AAPL': [100, 102, 99],\n    'GOOGL': [150, 148, 152],\n    'MSFT': [300, 305, 298]\n}\nprices = pd.DataFrame(data, index=pd.date_range('2024-01-01', periods=3))\n```\n\n#### 常見陷阱與注意事項\n- **匯入慣例**：**必須** `import pandas as pd`\n- **與 NumPy 區別**：Pandas 有索引對齊功能，NumPy 沒有\n- **記憶體開銷**：DataFrame 比 NumPy 陣列佔用更多記憶體\n\n#### 實務應用場景\n- 讀取與處理 Bloomberg 或 Reuters 數據\n- 建立投資組合績效追蹤表\n- 準備機器學習特徵矩陣\n\n#### 與其他章節的關聯\nPandas 底層是 NumPy (Ch3)，繪圖功能接入 Matplotlib (Ch7)。\n\n---\n\n### 5.2 序列 (Series) 建立與特性\n\n#### 概念定義\n**Series** 是帶有「標籤索引」的一維陣列，可視為「有名字的列表」或「固定長度的有序字典」。\n\n核心屬性：\n- `values`：底層 NumPy 陣列\n- `index`：標籤索引\n- `name`：序列名稱\n- `dtype`：資料類型\n\n#### 財金理論背景\n單一資產的時間序列就是一個 Series：\n- 索引 = 交易日期\n- 值 = 收盤價或報酬率\n- Name = 股票代碼\n\n#### Python 實現邏輯\n```python\n# 建立方式一：從列表\ns1 = pd.Series([100, 102, 99], name='price')\n\n# 建立方式二：從字典（自動設索引）\ns2 = pd.Series({'AAPL': 100, 'GOOGL': 150, 'MSFT': 300})\n\n# 建立方式三：從 NumPy 陣列\ns3 = pd.Series(np.random.randn(252), \n               index=pd.date_range('2024-01-01', periods=252),\n               name='daily_return')\n\n# 核心屬性\nprint(s3.shape)     # (252,)\nprint(s3.dtype)     # float64\nprint(s3.index[:3]) # DatetimeIndex\n```\n\n#### 常見陷阱與注意事項\n- **索引非唯一**：允許重複索引，但可能導致選取時返回多行\n- **NaN 處理**：缺失值自動表示為 `NaN`\n- **類型推斷**：混合類型會推斷為 `object`（慢！）\n\n#### 實務應用場景\n- 單一股票的歷史價格序列\n- 投資組合的每日淨值\n- 宏觀經濟指標時間序列\n\n#### 與其他章節的關聯\nSeries 是 DataFrame 的 column，Ch6 的 groupby 操作返回的常是 Series。\n\n---\n\n### 5.3 序列資料選取與篩選\n\n#### 概念定義\nSeries 支援多種選取方式：\n- **標籤索引**：`s['2024-01-01']`\n- **位置索引**：`s.iloc[0]`\n- **布林索引**：`s[s > 0]`\n- **切片**：`s['2024-01':'2024-06']`\n\n#### 財金理論背景\n數據篩選是風險分析的核心：\n- 選取特定日期區間的報酬率\n- 篩選負報酬日分析下行風險\n- 提取異常值進行壓力測試\n\n#### Python 實現邏輯\n```python\n# 標籤索引\nprice = returns['2024-01-15']       # 單一值\nsubset = returns['2024-01':'2024-03']  # 範圍切片\n\n# 位置索引\nfirst = returns.iloc[0]\nlast_10 = returns.iloc[-10:]\n\n# 布林索引（最重要！）\npositive = returns[returns > 0]          # 正報酬\nextreme = returns[returns.abs() > 0.03]  # 極端報酬\nfiltered = returns[(returns > 0) & (returns < 0.05)]  # 組合條件\n\n# 條件計數\nn_positive = (returns > 0).sum()\npct_positive = (returns > 0).mean()  # 正報酬比例\n```\n\n#### 常見陷阱與注意事項\n- **`loc` vs `iloc`**：`loc` 用標籤（含終點），`iloc` 用位置（不含終點）\n- **鏈式賦值警告**：`s[s > 0][0] = 1` 可能失效，使用 `loc`\n- **日期切片含終點**：`s['2024-01':'2024-06']` 包含 6 月\n\n#### 實務應用場景\n- 計算歷史 VaR（篩選最差 5% 報酬）\n- 分析牛/熊市期間的績效差異\n- 識別連續虧損天數\n\n#### 與其他章節的關聯\n布林索引概念源自 Ch3 NumPy，在 Ch6 groupby 中用於條件分組。\n\n---\n\n### 5.4 資料框 (DataFrame) 建立\n\n#### 概念定義\n**DataFrame** 是二維表格結構，包含：\n- **index**：行標籤（通常是日期）\n- **columns**：列標籤（通常是資產代碼或欄位名）\n- **values**：底層二維 NumPy 陣列\n\n每個 column 是一個 Series。\n\n#### 財金理論背景\n金融數據天然適合 DataFrame 表示：\n- **OHLCV 數據**：columns = [Open, High, Low, Close, Volume]\n- **多資產報酬率**：columns = 各股票代碼\n- **財務報表**：rows = 科目, columns = 年度\n\n#### Python 實現邏輯\n```python\n# 從字典建立（最常用）\ndata = {\n    'Open': [100, 102, 101],\n    'High': [103, 104, 102],\n    'Low': [99, 101, 100],\n    'Close': [102, 103, 101]\n}\nohlc = pd.DataFrame(data, index=pd.date_range('2024-01-01', periods=3))\n\n# 從 NumPy 陣列建立\narr = np.random.randn(252, 5)\nreturns = pd.DataFrame(arr, \n                       index=pd.date_range('2024-01-01', periods=252),\n                       columns=['AAPL', 'GOOGL', 'MSFT', 'AMZN', 'META'])\n\n# 核心屬性\nprint(returns.shape)      # (252, 5)\nprint(returns.columns)    # Index(['AAPL', 'GOOGL', ...])\nprint(returns.info())     # 結構摘要\nprint(returns.describe()) # 統計摘要\n```\n\n#### 常見陷阱與注意事項\n- **Column 順序**：Python 3.7+ 保持插入順序\n- **Copy vs View**：`df['col']` 返回 view，修改會影響原 df\n- **空 DataFrame**：`pd.DataFrame()` 建立空表，需後續賦值\n\n#### 實務應用場景\n- 存儲多資產的歷史行情\n- 建立財務指標矩陣\n- 準備回測數據結構\n\n#### 與其他章節的關聯\nDataFrame 是 Ch6 合併、分組操作的基礎，也是 Ch7 繪圖的主要數據來源。\n\n---\n\n### 5.5 DataFrame 的資料選擇 (loc, iloc)\n\n#### 概念定義\nDataFrame 提供兩種主要索引器：\n- **`.loc[]`**：標籤基礎（Label-based），含終點\n- **`.iloc[]`**：位置基礎（Integer Position-based），不含終點\n\n語法：`df.loc[row_selector, column_selector]`\n\n#### 財金理論背景\n精確的數據選取對風險計算至關重要：\n- 選取特定日期範圍的特定資產\n- 提取子組合進行歸因分析\n- 排除特定異常值\n\n#### Python 實現邏輯\n```python\n# 假設 df 是多資產價格 DataFrame，索引為日期\n\n# --- loc: 標籤選取 ---\n# 單一儲存格\nprice = df.loc['2024-01-15', 'AAPL']\n\n# 單行\nrow = df.loc['2024-01-15']  # 返回 Series\n\n# 單列\ncol = df.loc[:, 'AAPL']     # 或 df['AAPL']\n\n# 多行多列\nsubset = df.loc['2024-01':'2024-03', ['AAPL', 'GOOGL']]\n\n# --- iloc: 位置選取 ---\n# 第一行\nfirst_row = df.iloc[0]\n\n# 最後 5 行，前 2 列\ntail = df.iloc[-5:, :2]\n\n# 第 10-20 行，第 1, 3, 5 列\nsample = df.iloc[10:20, [0, 2, 4]]\n\n# --- 混合選取 ---\n# 使用 .loc 搭配布林條件\nhigh_vol = df.loc[df['AAPL'].pct_change().abs() > 0.05]\n```\n\n#### 常見陷阱與注意事項\n- **切片行為差異**：`loc['a':'c']` 含 'c'，`iloc[0:3]` 不含 3\n- **返回類型**：`df.loc[single_row]` 返回 Series，`df.loc[[single_row]]` 返回 DataFrame\n- **鏈式索引**：避免 `df['A']['B']`，使用 `df.loc[:, ('A', 'B')]`\n\n#### 實務應用場景\n- 提取特定時期的特定資產進行歸因\n- 建立滾動視窗數據切片\n- 準備機器學習訓練/測試集分割\n\n#### 與其他章節的關聯\nloc/iloc 技術在 Ch6 數據合併後用於驗證結果正確性。\n\n---\n\n### 5.6 序列與 DataFrame 的基本算術運算\n\n#### 概念定義\nPandas 運算的核心特性是**索引自動對齊 (Alignment)**：\n- 運算時自動匹配相同的 index 和 column\n- 對應不到的位置填入 NaN\n- 支援廣播（Series 與 DataFrame 運算）\n\n#### 財金理論背景\n對齊功能解決了金融數據的常見問題：\n- 不同交易所的交易日曆不同\n- 新股無完整歷史數據\n- 數據源更新頻率不一致\n\nPandas 自動處理這些對齊問題，避免手工匹配錯誤。\n\n#### Python 實現邏輯\n```python\n# 自動對齊範例\ns1 = pd.Series([1, 2, 3], index=['a', 'b', 'c'])\ns2 = pd.Series([4, 5, 6], index=['b', 'c', 'd'])\n\nresult = s1 + s2\n# a    NaN  (s2 沒有 'a')\n# b    6.0\n# c    8.0\n# d    NaN  (s1 沒有 'd')\n\n# 填充缺失值\nresult_filled = s1.add(s2, fill_value=0)\n\n# DataFrame 廣播\nreturns = pd.DataFrame(np.random.randn(252, 5))\nrf = 0.0001  # 日無風險利率\nexcess_returns = returns - rf  # 標量廣播\n\n# 沿軸運算\nmean_return = returns.mean(axis=0)        # 各資產平均\nexcess = returns.sub(mean_return, axis=1) # 減去各資產均值\n```\n\n#### 常見陷阱與注意事項\n- **NaN 傳播**：任何與 NaN 的運算結果都是 NaN\n- **整數變浮點**：NaN 只能存在於 float，整數列會自動轉型\n- **對齊警告**：大量 NaN 可能表示索引設置錯誤\n\n#### 實務應用場景\n- 計算超額報酬（減去基準）\n- 不同交易所數據的跨市場分析\n- 處理缺失報價的資產\n\n#### 與其他章節的關聯\n對齊概念是 Ch6 合併操作的基礎，確保 merge/join 後數據一致。\n\n---\n\n### 5.7 索重引、更新索引與重建索引 (Reindex)\n\n#### 概念定義\n**`reindex()`** 將數據適配到新的索引：\n- 新索引有而舊索引沒有 → 填入 NaN（或指定填充方式）\n- 舊索引有而新索引沒有 → 該行被丟棄\n- 支援前向填充 (ffill) 和後向填充 (bfill)\n\n#### 財金理論背景\n索引重建解決數據對齊問題：\n- 將週頻數據映射到日頻索引\n- 填補非交易日的缺失值\n- 統一不同來源數據的時間軸\n\n#### Python 實現邏輯\n```python\n# 基本 reindex\nold_index = pd.date_range('2024-01-01', periods=5, freq='B')\nnew_index = pd.date_range('2024-01-01', periods=7, freq='D')\n\ns = pd.Series([100, 101, 102, 103, 104], index=old_index)\ns_reindexed = s.reindex(new_index)  # 週末為 NaN\n\n# 前向填充（用前一個有效值）\ns_ffill = s.reindex(new_index, method='ffill')\n\n# 後向填充\ns_bfill = s.reindex(new_index, method='bfill')\n\n# 指定填充值\ns_filled = s.reindex(new_index, fill_value=0)\n\n# DataFrame 同時 reindex 行和列\ndf_new = df.reindex(index=new_date_index, columns=new_columns)\n\n# 重置為數字索引\ndf_reset = df.reset_index()  # 舊索引變成 column\ndf_set = df_reset.set_index('Date')  # 設定新索引\n```\n\n#### 常見陷阱與注意事項\n- **ffill vs interpolate**：ffill 是「持平」，interpolate 是「線性插值」\n- **原地修改**：`reindex()` 返回新物件，原物件不變\n- **排序要求**：`method='ffill/bfill'` 要求索引已排序\n\n#### 實務應用場景\n- 將月底發布的宏觀數據映射到每日索引\n- 填補節假日的收盤價（沿用前一日）\n- 對齊不同資產的交易日曆\n\n#### 與其他章節的關聯\nreindex 是 Ch6 數據合併的前置處理，確保 merge 前的索引一致性。"
      }
    },
    "examples": []
  },
  {
    "id": "b1_ch6",
    "title": "第6章：Pandas 與資料分析 II",
    "number": 6,
    "content": {
      "intro": {
        "title": "第 6 章：Pandas 與資料分析 II - 詳解",
        "roadmap": {
          "guide": "提升數據的「透視」與「整合」能力。本章專注於進階數據操作：多表合併（Join/Merge）、分組運算（GroupBy）。",
          "objectives": "提升數據的「透視」與「整合」能力。本章專注於進階數據操作：多表合併（Join/Merge）、分組運算（GroupBy）以及樞紐分析表（Pivot Tables），這是在銀行生成風險暴露彙總報告的核心技術。",
          "topics": "*   6.1 資料視覺化初步 (Pandas Plot)\n*   6.2 常用檔案寫出與讀取 (to_csv, read_csv)\n*   6.3 DataFrame 合併 (Merge)\n*   6.4 DataFrame 列連接 (Join)\n*   6.5 DataFrame 拼接 (Concat)\n*   6.6 分組分析 (GroupBy)\n*   6.7 樞紐分析表 (Pivot Table)"
        },
        "value": {
          "practical": "*   **實務場景**：計算資產組合在不同行業別（Industry）、不同主體（Issuer）下的平均風險敞口。\n*   **考試重點**：在處理合併後的數據時，識別並處理資料重複與孤立值。",
          "theory": "*   **聚合與分解 (Aggregation & De-aggregation)**：風險管理要求能從「整個組合的 VaR」下鑽（Drill-down）到「單一交易對手的 VaR」。這一邏輯在 Pandas 中透過 `groupby` 完美實現。\n*   **關聯式數據思維**：金融數據分散在各處（如：信用評等表與市場價值表），核心是透過主鍵（Key）進行「關係型」整合。",
          "further_reading": "*   Pandas 與 SQL 的無縫對接。"
        },
        "implementation": {
          "python": "*   **自動化報告生成**：一鍵將原始交易明細轉換為專業的風險暴露分佈矩陣（如：按行業與信用評等雙向透視）。\n*   **數據清洗流水線**：利用 `merge` 高效清理缺失值與冗餘項。",
          "logic": "*   `pd.merge()`：實現數據庫級別的 Join 操作。\n*   `.groupby()`：數據分析的靈魂，實施 Split-Apply-Combine 範式。\n*   `.pivot_table()`：超越 Excel 透視表的靈活性。",
          "scenarios": "| 腳本名稱 | 核心使命 |\n| :--- | :--- |"
        },
        "body": "### 6.1 資料視覺化初步 (Pandas Plot)\n\n#### 概念定義\nPandas 內建繪圖接口，底層調用 Matplotlib。透過 `.plot()` 方法可快速生成：\n- 折線圖 (`kind='line'`)\n- 長條圖 (`kind='bar'`)\n- 直方圖 (`kind='hist'`)\n- 散佈圖 (`kind='scatter'`)\n\n#### 財金理論背景\n視覺化是數據分析的第一步：\n- 識別趨勢與異常值\n- 比較多資產績效\n- 檢查數據品質（缺失、離群點）\n\n#### Python 實現邏輯\n```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# 折線圖：股價走勢\nprices['AAPL'].plot(title='AAPL Price', figsize=(10, 4))\nplt.show()\n\n# 多資產疊加\nprices[['AAPL', 'GOOGL', 'MSFT']].plot(figsize=(10, 4), alpha=0.7)\n\n# 直方圖：報酬率分佈\nreturns['AAPL'].hist(bins=50, alpha=0.7, edgecolor='black')\nplt.xlabel('Daily Return')\nplt.title('AAPL Return Distribution')\n\n# 散佈圖：相關性視覺化\nreturns.plot.scatter(x='AAPL', y='GOOGL', alpha=0.5)\n\n# 子圖\nreturns.plot(subplots=True, layout=(2, 3), figsize=(12, 6))\n```\n\n#### 常見陷阱與注意事項\n- **圖片不顯示**：Jupyter 需 `%matplotlib inline`\n- **中文亂碼**：需設定中文字型 `plt.rcParams['font.sans-serif']`\n- **儲存圖片**：使用 `plt.savefig('chart.png', dpi=150)`\n\n#### 實務應用場景\n- 每日風險報告的績效曲線\n- 數據探索階段的快速檢視\n- 異常值的視覺識別\n\n#### 與其他章節的關聯\nCh7 將深入 Matplotlib 和 Seaborn 製作專業級視覺化。\n\n---\n\n### 6.2 常用檔案寫出與讀取 (to_csv, read_csv)\n\n#### 概念定義\nPandas 提供強大的 I/O 功能：\n- **讀取**：`pd.read_csv()`, `pd.read_excel()`, `pd.read_sql()`\n- **寫出**：`df.to_csv()`, `df.to_excel()`, `df.to_sql()`\n\n`read_csv()` 擁有豐富參數處理各種格式。\n\n#### 財金理論背景\n數據管道是風險系統的基礎：\n- 從數據供應商讀取每日行情\n- 儲存計算結果供報表使用\n- 歸檔歷史數據供審計\n\n#### Python 實現邏輯\n```python\n# 基本讀取\ndf = pd.read_csv('prices.csv')\n\n# 進階參數\ndf = pd.read_csv('prices.csv',\n                 index_col='Date',        # 設定索引列\n                 parse_dates=['Date'],    # 解析日期\n                 usecols=['Date', 'Open', 'Close'],  # 選取列\n                 na_values=['N/A', ''],   # 缺失值標記\n                 encoding='utf-8')\n\n# 分塊讀取大文件\nfor chunk in pd.read_csv('big_data.csv', chunksize=100000):\n    process(chunk)\n\n# 寫出\ndf.to_csv('output.csv', \n          index=True,              # 是否輸出索引\n          float_format='%.4f',     # 小數位數\n          date_format='%Y-%m-%d')  # 日期格式\n\n# Excel\ndf.to_excel('output.xlsx', sheet_name='Returns')\ndf_excel = pd.read_excel('data.xlsx', sheet_name='Sheet1')\n```\n\n#### 常見陷阱與注意事項\n- **編碼問題**：中文 CSV 可能需要 `encoding='big5'` 或 `'gb2312'`\n- **索引重複**：`read_csv` 後索引可能變成數字，需手動 `set_index`\n- **記憶體溢出**：大文件使用 `chunksize` 或 `dtype` 優化\n\n#### 實務應用場景\n- 自動化每日數據更新流程\n- 備份風險計算結果\n- 與 Excel 使用者協作\n\n#### 與其他章節的關聯\nCh2 介紹基礎 I/O，本章使用 Pandas 高級封裝簡化操作。\n\n---\n\n### 6.3 DataFrame 合併 (Merge)\n\n#### 概念定義\n**`pd.merge()`** 類似 SQL 的 JOIN，根據鍵 (Key) 合併兩個 DataFrame：\n- `inner`：交集（預設）\n- `outer`：聯集\n- `left`/`right`：以左/右表為主\n\n#### 財金理論背景\n金融數據分散在多個來源：\n- 市場價格 + 信用評等\n- 交易記錄 + 對手方資訊\n- 持倉數據 + 宏觀因子\n\nMerge 是整合這些數據的核心操作。\n\n#### Python 實現邏輯\n```python\n# 基本合併\nprices = pd.DataFrame({\n    'ticker': ['AAPL', 'GOOGL', 'MSFT'],\n    'price': [150, 2500, 300]\n})\n\nratings = pd.DataFrame({\n    'ticker': ['AAPL', 'GOOGL', 'AMZN'],\n    'rating': ['AA', 'AA', 'A']\n})\n\n# Inner Join（只保留兩邊都有的）\nresult = pd.merge(prices, ratings, on='ticker', how='inner')\n\n# Left Join（保留左邊所有，右邊補 NaN）\nresult = pd.merge(prices, ratings, on='ticker', how='left')\n\n# 多鍵合併\nresult = pd.merge(df1, df2, on=['date', 'ticker'], how='outer')\n\n# 欄位名不同\nresult = pd.merge(df1, df2, left_on='symbol', right_on='ticker')\n\n# 處理重複欄位名\nresult = pd.merge(df1, df2, on='ticker', suffixes=('_price', '_volume'))\n```\n\n#### 常見陷阱與注意事項\n- **重複鍵**：多對多合併會產生笛卡爾積，列數暴增\n- **NaN 處理**：Outer join 會產生大量 NaN\n- **效能**：大表合併前先過濾不需要的列\n\n#### 實務應用場景\n- 將持倉表與市場價格表合併計算市值\n- 整合信用評等與違約機率\n- 合併多數據供應商的數據\n\n#### 與其他章節的關聯\nMerge 後常用 Ch5 的 loc/iloc 驗證結果，並用 Ch6.6 groupby 進行分組分析。\n\n---\n\n### 6.4 DataFrame 列連接 (Join)\n\n#### 概念定義\n**`.join()`** 基於索引 (Index) 合併，適用於已設定 DatetimeIndex 的時間序列數據。\n\n與 `merge` 的區別：\n- `merge`：基於 column 合併\n- `join`：基於 index 合併\n\n#### 財金理論背景\n多資產時間序列通常以日期為索引：\n- 將多檔股票價格橫向拼接\n- 合併價格與成交量序列\n- 整合不同頻率的數據\n\n#### Python 實現邏輯\n```python\n# 假設都以日期為索引\naapl = pd.DataFrame({'AAPL': [100, 101, 102]},\n                    index=pd.date_range('2024-01-01', periods=3))\ngoogl = pd.DataFrame({'GOOGL': [2500, 2510, 2520]},\n                     index=pd.date_range('2024-01-01', periods=3))\n\n# 橫向拼接\ncombined = aapl.join(googl)\n\n# 多表 join\nmsft = pd.DataFrame({'MSFT': [300, 305, 298]},\n                    index=pd.date_range('2024-01-01', periods=3))\ncombined = aapl.join([googl, msft])\n\n# 處理部分重疊\ncombined = aapl.join(googl, how='outer')  # 聯集索引\n\n# 用 column 作為 join key\ndf1.join(df2.set_index('date'), on='date')\n```\n\n#### 常見陷阱與注意事項\n- **索引必須設定**：join 預設用 index，column join 需先 `set_index`\n- **重複 column 名**：需指定 `lsuffix`/`rsuffix`\n- **排序**：join 不保證結果順序，可能需要 `.sort_index()`\n\n#### 實務應用場景\n- 建立多資產價格大寬表\n- 合併同一資產的不同欄位（價格、成交量、波動率）\n- 時間序列的橫向擴展\n\n#### 與其他章節的關聯\nJoin 和 Merge 互補使用，Ch5 的 reindex 可預先統一索引。\n\n---\n\n### 6.5 DataFrame 拼接 (Concat)\n\n#### 概念定義\n**`pd.concat()`** 沿軸向堆疊多個物件：\n- `axis=0`：縱向（增加行）\n- `axis=1`：橫向（增加列）\n\n與 merge/join 的區別：concat 是「堆疊」，不是「匹配」。\n\n#### 財金理論背景\n數據拼接的典型場景：\n- 多個月份的交易記錄縱向堆疊\n- 多個數據源的相同指標橫向拼接\n- 批量處理後的結果合併\n\n#### Python 實現邏輯\n```python\n# 縱向拼接：多月數據\njan = pd.DataFrame({'price': [100, 101]}, index=['2024-01-01', '2024-01-02'])\nfeb = pd.DataFrame({'price': [102, 103]}, index=['2024-02-01', '2024-02-02'])\n\nyearly = pd.concat([jan, feb], axis=0)\n\n# 橫向拼接：多資產\naapl = pd.Series([100, 101, 102], name='AAPL')\ngoogl = pd.Series([2500, 2510, 2520], name='GOOGL')\n\nportfolio = pd.concat([aapl, googl], axis=1)\n\n# 添加來源標識\nq1 = pd.DataFrame({'return': [0.01, 0.02]})\nq2 = pd.DataFrame({'return': [0.03, 0.04]})\n\ncombined = pd.concat([q1, q2], keys=['Q1', 'Q2'])  # MultiIndex\n\n# 忽略原索引\ncombined = pd.concat([q1, q2], ignore_index=True)  # 重建數字索引\n```\n\n#### 常見陷阱與注意事項\n- **索引重複**：縱向 concat 可能產生重複索引，用 `ignore_index=True`\n- **列不匹配**：`axis=0` 時列名不同會產生 NaN\n- **效能**：避免在迴圈中逐次 concat，先收集再一次性 concat\n\n#### 實務應用場景\n- 合併多年歷史數據\n- 批量回測結果的彙總\n- 將多個特徵表橫向拼接成特徵矩陣\n\n#### 與其他章節的關聯\nConcat 常用於準備 Ch7 繪圖的輸入數據，也用於 Ch8-Ch9 統計分析的數據準備。\n\n---\n\n### 6.6 分組分析 (GroupBy)\n\n#### 概念定義\n**`.groupby()`** 實現 **Split-Apply-Combine** 範式：\n1. **Split**：按鍵分組\n2. **Apply**：對每組應用函數\n3. **Combine**：合併結果\n\n這是 Pandas 最強大的功能之一。\n\n#### 財金理論背景\n風險分析需要多維度聚合：\n- 按產業別計算平均報酬\n- 按信用評等計算違約率\n- 按交易對手計算風險敞口\n\n#### Python 實現邏輯\n```python\n# 基本分組\ndf = pd.DataFrame({\n    'sector': ['Tech', 'Tech', 'Finance', 'Finance'],\n    'ticker': ['AAPL', 'GOOGL', 'JPM', 'GS'],\n    'return': [0.05, 0.03, 0.02, 0.04]\n})\n\n# 單鍵分組 + 單函數\nsector_avg = df.groupby('sector')['return'].mean()\n\n# 多函數\nsector_stats = df.groupby('sector')['return'].agg(['mean', 'std', 'count'])\n\n# 多鍵分組\ndf.groupby(['sector', 'rating'])['return'].mean()\n\n# 自定義函數\ndf.groupby('sector')['return'].apply(lambda x: (1 + x).prod() - 1)\n\n# Transform（保持原形狀）\ndf['sector_avg'] = df.groupby('sector')['return'].transform('mean')\ndf['z_score'] = df.groupby('sector')['return'].transform(\n    lambda x: (x - x.mean()) / x.std()\n)\n\n# Filter（過濾整組）\nlarge_sectors = df.groupby('sector').filter(lambda g: len(g) >= 2)\n```\n\n#### 常見陷阱與注意事項\n- **返回類型**：單 column + 單函數返回 Series，否則返回 DataFrame\n- **缺失值處理**：NaN 分組鍵會被忽略\n- **reset_index()**：groupby 結果常需 `reset_index()` 重建 column\n\n#### 實務應用場景\n- 按產業計算投資組合權重\n- 按信用評等分析違約頻率\n- 計算各交易對手的 CVA 暴露\n\n#### 與其他章節的關聯\nGroupBy 是 Ch6.7 Pivot Table 的底層機制，也常用於準備 Ch9 統計分析的分組樣本。\n\n---\n\n### 6.7 樞紐分析表 (Pivot Table)\n\n#### 概念定義\n**`pivot_table()`** 將長格式數據轉為寬格式，並進行聚合計算。類似 Excel 樞紐表，但更強大靈活：\n- **index**：行標籤\n- **columns**：列標籤\n- **values**：聚合欄位\n- **aggfunc**：聚合函數\n\n#### 財金理論背景\n多維度風險報告的標準格式：\n- 行：資產類別，列：信用評等\n- 行：地區，列：產業\n- 值：VaR 或風險敞口\n\n#### Python 實現邏輯\n```python\n# 原始數據（長格式）\ntrades = pd.DataFrame({\n    'date': ['2024-01-01', '2024-01-01', '2024-01-02', '2024-01-02'],\n    'sector': ['Tech', 'Finance', 'Tech', 'Finance'],\n    'pnl': [100, -50, 150, 80]\n})\n\n# 基本樞紐表\npivot = trades.pivot_table(\n    index='date',\n    columns='sector',\n    values='pnl',\n    aggfunc='sum'\n)\n\n# 多聚合函數\npivot = trades.pivot_table(\n    index='date',\n    columns='sector',\n    values='pnl',\n    aggfunc=['sum', 'mean', 'count']\n)\n\n# 添加邊際合計\npivot = trades.pivot_table(\n    index='date',\n    columns='sector',\n    values='pnl',\n    aggfunc='sum',\n    margins=True,      # 添加 All 行/列\n    margins_name='Total'\n)\n\n# 填充缺失值\npivot = trades.pivot_table(..., fill_value=0)\n\n# 多層索引\npivot = trades.pivot_table(\n    index=['date', 'region'],\n    columns='sector',\n    values='pnl',\n    aggfunc='sum'\n)\n```\n\n#### 常見陷阱與注意事項\n- **與 pivot() 區別**：`pivot()` 不聚合，要求無重複值\n- **NaN 處理**：無數據的格子為 NaN，使用 `fill_value`\n- **列名層級**：多聚合函數會產生 MultiIndex columns\n\n#### 實務應用場景\n- 生成按產業 × 評等的風險敞口矩陣\n- 製作每日損益的多維報表\n- 分析不同維度的績效歸因\n\n#### 與其他章節的關聯\nPivot Table 的輸出常用於 Ch7 的熱力圖視覺化，也是風險報告的核心數據格式。"
      }
    },
    "examples": []
  },
  {
    "id": "b1_ch7",
    "title": "第7章：資料視覺化",
    "number": 7,
    "content": {
      "intro": {
        "title": "第 7 章：資料視覺化 - 詳解",
        "roadmap": {
          "guide": "將複雜的數據洞察具象化。本章旨在掌握 Matplotlib 與 Seaborn 這兩個可視化支柱。",
          "objectives": "將複雜的數據洞察具象化。本章旨在掌握 Matplotlib 與 Seaborn 這兩個可視化支柱，建立隨機過程走勢圖、損失分佈圖以及三維波動率曲面。",
          "topics": "*   7.1 Matplotlib 繪圖函數庫基礎\n*   7.2 二維線圖製作與屬性調整\n*   7.3 子圖繪製 (Subplots)\n*   7.4 繪製輔助線與標註\n*   7.5 在圖表中加入數學公式\n*   7.6 常見二維影像 (Scatter, Bar, Histogram)\n*   7.7 常見三維影像 (3D Surface)\n*   7.8 統計資料視覺化 (Seaborn 整合)\n*   7.9 互動式繪圖簡介"
        },
        "value": {
          "practical": "*   **實務場景**：製作給投資委員會（Investment Committee）看的策略回測淨值曲線。\n*   **考試重點**：識別統計圖表中的偏度方向及峰值含義。",
          "theory": "*   **風險視覺化的心理學**：在風險限額觸碰時，直覺的圖形提醒優於表格。\n*   **分佈的呈現**：損失分佈（Loss Distribution）的厚尾（Fat-tail）特性透過 Seaborn 的直方圖與 KDE（核密度估計）能清晰展現，這直接關乎 VaR 或 Expected Shortfall 的預測邊界。",
          "further_reading": "*   互動式視覺化：Plotly 在量化交易面板（Dashboard）中的應用。"
        },
        "implementation": {
          "python": "*   **自定義圖表**：Matplotlib 的細粒度控制允許我們繪製帶有「止損位」與「交易區間」的專業畫布。\n*   **統計可視化**：Seaborn 能直接對 DataFrame 進行統計特徵提取並繪圖。",
          "logic": "*   `plt.plot()`、`plt.hist()`：二維基礎繪圖。\n*   `sns.distplot()`：展示收益率的偏度（Skewness）與峰度（Kurtosis）。\n*   `mpl_toolkits.mplot3d`：繪製資產價格與時間對應的波動率曲面（Volatility Surface）。",
          "scenarios": "| 腳本名稱 | 核心使命 |\n| :--- | :--- |\n| **B1_Ch7_1.py** | 基礎繪圖：演示 Matplotlib 繪製簡單折線圖與座標軸標籤設定。 |\n| **B1_Ch7_2.py** | 進階繪圖：實作雙 Y 軸 (Twinx) 配置，對比不同量級的金融指標。 |\n| **B1_Ch7_3.py** | 演示圖表美化：自定義線條樣式、顏色與圖例 (Legend) 位置。 |\n| **B1_Ch7_4.py** | 實作圖形標註 (Annotation)，在圖表上標出特定風險事件點。 |\n| **B1_Ch7_5.py** | 演示區域填充 (Fill_between)，視覺化呈現風險值 (VaR) 的置信區間。 |\n| **B1_Ch7_6.py** | 繪製基礎散佈圖 (Scatter Plot)，分析兩項資產回報率的相關性。 |\n| **B1_Ch7_7.py** | 繪製直方圖 (Histogram)，演示收益率分佈的頻率統計。 |\n| **B1_Ch7_8.py** | 演示子圖 (Subplots) 佈局，在同一畫面上對比多個技術指標。 |\n| **B1_Ch7_9.py** | 實作互動式繪圖基礎：動態更新座標軸範圍。 |\n| **B1_Ch7_10.py** | 繪製等高線圖 (Contour) 與填充等高線圖 (Contourf)，視覺化二維函數曲面。 |\n| **B1_Ch7_11.py** | 繪製 3D 螺旋線曲線 (Helix)，演示參數化曲線的空間呈現。 |\n| **B1_Ch7_12.py** | 繪製 3D 散佈圖與柱狀圖 (Stem Plot)，演示三維數據的離散分佈展示。 |\n| **B1_Ch7_13.py** | 計算並繪製歐式期權 Gamma 的 3D 曲面圖與等高線切面，分析時間與標的價格的影響。 |\n| **B1_Ch7_14.py** | 繪製圓餅圖 (Pie Chart)，演示公司營運費用的組成比例分析。 |\n| **B1_Ch7_15.py** | 繪製分組柱狀圖 (Grouped Bar Chart)，使用 Matplotlib、Seaborn 與 Pandas 對比股價季度均值。 |\n| **B1_Ch7_16.py** | 繪製六種常見機率分佈的直方圖：均勻、常態、指數、對數常態、卡方與 Beta 分佈。 |\n| **B1_Ch7_17.py** | 實作互動式正弦波圖形，使用滑桿 (Slider) 動態調整振幅、頻率、相位與偏移。 |\n| **B1_Ch7_18.py** | 實作 Black-Scholes 歐式期權定價互動圖，使用滑桿即時調整參數並更新價格曲線與等高線圖。 |"
        },
        "body": "### 7.1 Matplotlib 繪圖函數庫基礎\n\n#### 概念定義\n**Matplotlib** 是 Python 最基礎的繪圖庫，採用類似 MATLAB 的狀態機模式。核心概念：\n- **Figure**：整張畫布\n- **Axes**：單個子圖區域\n- **Artist**：所有可視化元素（線條、文字、標籤）\n\n#### 財金理論背景\n視覺化是風險溝通的核心：\n- 向投資委員會展示績效曲線\n- 在風險報告中呈現損失分佈\n- 即時監控 VaR 突破情況\n\n#### Python 實現邏輯\n```python\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# 最簡單的繪圖\nplt.plot([1, 2, 3, 4], [1, 4, 2, 3])\nplt.title('Basic Plot')\nplt.show()\n\n# OO 風格（推薦）\nfig, ax = plt.subplots(figsize=(10, 6))\nax.plot(x, y, label='Price')\nax.set_xlabel('Date')\nax.set_ylabel('Price ($)')\nax.set_title('Stock Price')\nax.legend()\nplt.tight_layout()\nplt.savefig('chart.png', dpi=150)\n```\n\n#### 常見陷阱與注意事項\n- **兩種風格**：pyplot（狀態機）vs OO（物件導向），大型專案推薦 OO\n- **中文支援**：需設定 `plt.rcParams['font.sans-serif'] = ['Microsoft JhengHei']`\n- **記憶體洩漏**：用 `plt.close()` 關閉不需要的 figure\n\n#### 實務應用場景\n- 製作專業的投資簡報圖表\n- 自動化生成每日風險報告\n- 開發交易監控面板\n\n#### 與其他章節的關聯\nPandas 的 `.plot()` (Ch6) 底層調用 Matplotlib，Ch7.8 Seaborn 進一步封裝。\n\n---\n\n### 7.2 二維線圖製作與屬性調整\n\n#### 概念定義\n線圖 (Line Plot) 用於展示時間序列的連續變化。可調整：\n- 顏色 (`color`)、線型 (`linestyle`)、線寬 (`linewidth`)\n- 標記 (`marker`)、標記大小 (`markersize`)\n- 透明度 (`alpha`)\n\n#### 財金理論背景\n線圖是金融分析的標準工具：\n- 股價走勢、淨值曲線\n- 技術指標（MA, MACD）\n- VaR 時間序列\n\n#### Python 實現邏輯\n```python\nfig, ax = plt.subplots(figsize=(10, 5))\n\n# 基本線圖\nax.plot(dates, prices, 'b-', linewidth=1.5, label='Price')\n\n# 多條線\nax.plot(dates, ma_20, 'r--', linewidth=1, label='MA20')\nax.plot(dates, ma_50, 'g-.', linewidth=1, label='MA50')\n\n# 設定屬性\nax.set_xlim(dates[0], dates[-1])\nax.set_ylim(0, None)  # 自動上限\n\n# 網格線\nax.grid(True, linestyle='--', alpha=0.7)\n\n# 雙 Y 軸\nax2 = ax.twinx()\nax2.bar(dates, volume, alpha=0.3, label='Volume')\nax2.set_ylabel('Volume')\n\nax.legend(loc='upper left')\n```\n\n#### 常見陷阱與注意事項\n- **日期軸格式**：使用 `mdates.DateFormatter('%Y-%m')` 格式化\n- **圖例遮擋**：使用 `bbox_to_anchor` 移出繪圖區域\n- **線型字串**：`'b-'` = 藍色實線，`'ro'` = 紅色圓點\n\n#### 實務應用場景\n- 策略回測的淨值曲線\n- 多資產價格對比\n- 帶成交量的 K 線圖\n\n#### 與其他章節的關聯\n線圖技術在 Ch10-Ch11 用於展示定價函數，Ch12 展示殖利率曲線。\n\n---\n\n### 7.3 子圖繪製 (Subplots)\n\n#### 概念定義\n**Subplots** 在同一畫布上創建多個獨立圖區，支援：\n- 規則網格：`plt.subplots(nrows, ncols)`\n- 共享軸：`sharex=True`, `sharey=True`\n- 不規則佈局：`gridspec`\n\n#### 財金理論背景\n金融分析常需多維度對比：\n- 上圖：價格走勢\n- 下圖：對應的波動率或成交量\n- 多資產並排對比\n\n#### Python 實現邏輯\n```python\n# 2 行 1 列，共享 X 軸\nfig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 8), sharex=True,\n                               gridspec_kw={'height_ratios': [3, 1]})\n\n# 上圖：價格\nax1.plot(dates, prices, 'b-')\nax1.set_ylabel('Price')\nax1.set_title('Stock Analysis')\n\n# 下圖：成交量\nax2.bar(dates, volume, color='gray', alpha=0.7)\nax2.set_ylabel('Volume')\nax2.set_xlabel('Date')\n\nplt.tight_layout()\n\n# 2x2 網格\nfig, axes = plt.subplots(2, 2, figsize=(12, 8))\naxes[0, 0].plot(x1, y1)\naxes[0, 1].hist(data, bins=50)\naxes[1, 0].scatter(x2, y2)\naxes[1, 1].bar(categories, values)\n```\n\n#### 常見陷阱與注意事項\n- **axes 索引**：2D 時用 `axes[i, j]`，1D 時直接 `axes[i]`\n- **間距調整**：`plt.subplots_adjust()` 或 `plt.tight_layout()`\n- **共享軸標籤**：只有邊緣子圖需要標籤\n\n#### 實務應用場景\n- 股價+成交量+RSI 的多層分析\n- 多資產績效的並排對比\n- 投資報告的多面板設計\n\n#### 與其他章節的關聯\n子圖技術用於 Ch10-Ch11 對比不同履約價的選擇權定價。\n\n---\n\n### 7.4 繪製輔助線與標註\n\n#### 概念定義\n輔助元素增強圖表可讀性：\n- **參考線**：`axhline()`, `axvline()`\n- **文字標註**：`annotate()`, `text()`\n- **區域標記**：`axhspan()`, `axvspan()`\n\n#### 財金理論背景\n金融圖表需要標記關鍵資訊：\n- 支撐位 / 壓力位\n- 重大新聞日期\n- VaR 限額線\n- 最大回撤點\n\n#### Python 實現邏輯\n```python\nfig, ax = plt.subplots(figsize=(10, 6))\nax.plot(dates, prices)\n\n# 水平參考線（VaR 限額）\nax.axhline(y=100, color='r', linestyle='--', linewidth=2, label='VaR Limit')\n\n# 垂直線（事件日期）\nax.axvline(x='2024-03-15', color='g', linestyle=':', alpha=0.8)\n\n# 標註最低點\nmin_idx = prices.argmin()\nax.annotate(f'Min: ${prices[min_idx]:.2f}',\n            xy=(dates[min_idx], prices[min_idx]),\n            xytext=(dates[min_idx], prices[min_idx] + 10),\n            arrowprops=dict(arrowstyle='->', color='red'),\n            fontsize=10)\n\n# 區域填充\nax.axhspan(95, 105, alpha=0.2, color='yellow', label='Target Range')\n```\n\n#### 常見陷阱與注意事項\n- **座標系統**：`annotate` 的 `xycoords` 參數控制座標系\n- **箭頭樣式**：`arrowprops` 字典控制外觀\n- **層次順序**：用 `zorder` 控制元素前後\n\n#### 實務應用場景\n- 標記風險限額突破點\n- 註釋重大市場事件\n- 視覺化交易入場/出場點\n\n#### 與其他章節的關聯\n標註技術在 Ch10-Ch11 用於標記選擇權行權價。\n\n---\n\n### 7.5 在圖表中加入數學公式\n\n#### 概念定義\nMatplotlib 支援 **LaTeX** 渲染，可在標題、軸標籤、圖例中顯示數學公式：\n- 使用 `r'$...$'` 語法\n- 支援希臘字母、分數、積分等\n\n#### 財金理論背景\n學術報告和專業簡報需要精確的公式展示：\n- Black-Scholes 公式\n- VaR 計算公式\n- 投資組合風險方程\n\n#### Python 實現邏輯\n```python\nfig, ax = plt.subplots()\n\n# 標題中使用 LaTeX\nax.set_title(r'Black-Scholes: $C = S_0 N(d_1) - K e^{-rT} N(d_2)$', fontsize=14)\n\n# 軸標籤\nax.set_xlabel(r'Stock Price $S$')\nax.set_ylabel(r'Option Value $C(S)$')\n\n# 圖例\nax.plot(S, call_price, label=r'$\\Delta = N(d_1)$')\n\n# 圖中文字\nax.text(50, 15, r'$d_1 = \\frac{\\ln(S/K) + (r + \\sigma^2/2)T}{\\sigma\\sqrt{T}}$',\n        fontsize=12, bbox=dict(boxstyle='round', facecolor='wheat'))\n\n# 啟用完整 LaTeX\nplt.rcParams['text.usetex'] = True  # 需要 LaTeX 環境\n```\n\n#### 常見陷阱與注意事項\n- **原始字串**：必須使用 `r'...'` 避免轉義問題\n- **跳脫字符**：`\\\\` 表示單個反斜線\n- **usetex**：完整 LaTeX 需要系統安裝 TeX\n\n#### 實務應用場景\n- 學術論文圖表標註\n- 量化策略白皮書\n- 風險模型說明文檔\n\n#### 與其他章節的關聯\nCh4 SymPy 的符號表達式可轉為 LaTeX 格式直接嵌入圖表。\n\n---\n\n### 7.6 常見二維影像 (Scatter, Bar, Histogram)\n\n#### 概念定義\n三種核心二維圖表：\n- **Scatter**：散佈圖，展示變數間關係\n- **Bar**：長條圖，比較分類數據\n- **Histogram**：直方圖，展示分佈形狀\n\n#### 財金理論背景\n- **散佈圖**：資產報酬率相關性\n- **長條圖**：產業/評等維度的風險敞口\n- **直方圖**：報酬率分佈的厚尾特徵\n\n#### Python 實現邏輯\n```python\nfig, axes = plt.subplots(1, 3, figsize=(15, 4))\n\n# 散佈圖\naxes[0].scatter(returns_A, returns_B, alpha=0.5, c='blue', s=20)\naxes[0].set_xlabel('Asset A Return')\naxes[0].set_ylabel('Asset B Return')\naxes[0].set_title('Return Correlation')\n\n# 長條圖\nsectors = ['Tech', 'Finance', 'Energy']\nexposure = [30, 25, 15]\naxes[1].bar(sectors, exposure, color=['blue', 'green', 'orange'])\naxes[1].set_ylabel('Exposure (%)')\naxes[1].set_title('Sector Exposure')\n\n# 直方圖\naxes[2].hist(returns, bins=50, density=True, alpha=0.7, edgecolor='black')\naxes[2].axvline(x=var_95, color='r', linestyle='--', label='VaR 95%')\naxes[2].set_xlabel('Daily Return')\naxes[2].set_title('Return Distribution')\naxes[2].legend()\n```\n\n#### 常見陷阱與注意事項\n- **直方圖 bins**：太少失去細節，太多產生噪音\n- **density=True**：歸一化為機率密度\n- **顏色一致性**：專案內保持配色標準\n\n#### 實務應用場景\n- 視覺化資產間的相關係數\n- 風險敞口的產業分佈\n- 識別報酬率的厚尾特徵\n\n#### 與其他章節的關聯\n直方圖用於驗證 Ch8-Ch9 的分佈假設，散佈圖用於 Ch4 的相關性分析。\n\n---\n\n### 7.7 常見三維影像 (3D Surface)\n\n#### 概念定義\n三維繪圖使用 `mplot3d` 工具包：\n- **Surface**：連續曲面\n- **Wireframe**：線框圖\n- **Contour**：等高線投影\n\n#### 財金理論背景\n衍生品定價天然是多維問題：\n- **波動率曲面**：隱含波動率 vs (履約價, 到期日)\n- **Gamma 曲面**：Gamma vs (標的價格, 時間)\n- **敏感度分析**：價值 vs (因子A, 因子B)\n\n#### Python 實現邏輯\n```python\nfrom mpl_toolkits.mplot3d import Axes3D\n\nfig = plt.figure(figsize=(10, 7))\nax = fig.add_subplot(111, projection='3d')\n\n# 網格\nK = np.linspace(80, 120, 50)\nT = np.linspace(0.1, 2, 50)\nK_grid, T_grid = np.meshgrid(K, T)\nvol_grid = implied_volatility(K_grid, T_grid)  # 計算隱含波動率\n\n# 曲面圖\nsurf = ax.plot_surface(K_grid, T_grid, vol_grid, cmap='viridis', alpha=0.8)\nax.set_xlabel('Strike Price')\nax.set_ylabel('Time to Maturity')\nax.set_zlabel('Implied Volatility')\nax.set_title('Volatility Surface')\n\nfig.colorbar(surf, shrink=0.5, aspect=10)\n\n# 等高線\nax.contour(K_grid, T_grid, vol_grid, zdir='z', offset=vol_grid.min(), cmap='coolwarm')\n```\n\n#### 常見陷阱與注意事項\n- **視角調整**：`ax.view_init(elev, azim)` 設定觀察角度\n- **網格密度**：太密會降低效能\n- **顏色映射**：選擇適合數據特性的 colormap\n\n#### 實務應用場景\n- 展示隱含波動率曲面\n- 分析 Greeks 的多因子敏感度\n- 視覺化損失曲面\n\n#### 與其他章節的關聯\n3D 曲面用於 Ch10-Ch11 展示選擇權定價函數。\n\n---\n\n### 7.8 統計資料視覺化 (Seaborn 整合)\n\n#### 概念定義\n**Seaborn** 是建立在 Matplotlib 上的高階統計繪圖庫：\n- 預設美觀風格\n- 直接處理 DataFrame\n- 內建統計計算\n\n#### 財金理論背景\n統計視覺化讓模式更易識別：\n- 相關性矩陣熱力圖\n- 分佈對比（正態 vs 實際）\n- 多變數關係探索\n\n#### Python 實現邏輯\n```python\nimport seaborn as sns\n\n# 熱力圖：相關係數矩陣\ncorr = returns.corr()\nfig, ax = plt.subplots(figsize=(8, 6))\nsns.heatmap(corr, annot=True, cmap='RdYlBu_r', center=0,\n            vmin=-1, vmax=1, ax=ax)\nax.set_title('Asset Correlation Matrix')\n\n# 分佈圖（含 KDE）\nfig, ax = plt.subplots()\nsns.histplot(returns['AAPL'], kde=True, ax=ax)\nax.set_title('Return Distribution with KDE')\n\n# 成對關係圖\nsns.pairplot(returns[['AAPL', 'GOOGL', 'MSFT']], diag_kind='kde')\n\n# 箱形圖\nsns.boxplot(data=returns, orient='h')\n```\n\n#### 常見陷阱與注意事項\n- **風格設定**：`sns.set_style('whitegrid')` 設定全局風格\n- **與 plt 混用**：Seaborn 返回 Axes，可繼續用 plt 修改\n- **性能**：大數據量時 heatmap 可能很慢\n\n#### 實務應用場景\n- 視覺化多資產相關性矩陣\n- 識別報酬率的分佈特徵（偏度、峰度）\n- 對比不同策略的績效分佈\n\n#### 與其他章節的關聯\nSeaborn 熱力圖用於展示 Ch9 的相關係數矩陣計算結果。\n\n---\n\n### 7.9 互動式繪圖簡介\n\n#### 概念定義\n互動式繪圖允許用戶動態操作圖表：\n- **Matplotlib Widgets**：滑桿、按鈕\n- **Plotly**：網頁互動圖表\n- **ipywidgets**：Jupyter 整合\n\n#### 財金理論背景\n互動式工具提升分析效率：\n- 動態調整模型參數觀察影響\n- 縮放檢視特定時期細節\n- 懸停顯示數據點資訊\n\n#### Python 實現邏輯\n```python\n# Matplotlib 滑桿\nfrom matplotlib.widgets import Slider\n\nfig, ax = plt.subplots()\nplt.subplots_adjust(bottom=0.25)\n\n# 初始圖\nline, = ax.plot(S, call_price(S, sigma=0.2))\n\n# 滑桿\nax_slider = plt.axes([0.2, 0.1, 0.6, 0.03])\nslider = Slider(ax_slider, 'Volatility', 0.1, 0.5, valinit=0.2)\n\ndef update(val):\n    line.set_ydata(call_price(S, sigma=slider.val))\n    fig.canvas.draw_idle()\n\nslider.on_changed(update)\nplt.show()\n\n# Plotly（推薦用於網頁）\nimport plotly.express as px\nfig = px.line(df, x='date', y='price', title='Interactive Price Chart')\nfig.show()\n```\n\n#### 常見陷阱與注意事項\n- **環境相容**：Matplotlib widgets 不適用於非互動環境\n- **Plotly 檔案大小**：內嵌數據會使 HTML 很大\n- **發布**：靜態報告用 Matplotlib，互動儀表板用 Plotly/Dash\n\n#### 實務應用場景\n- Black-Scholes 定價的參數敏感度展示\n- 交易監控即時儀表板\n- 策略參數調優介面\n\n#### 與其他章節的關聯\n互動式圖表可用於探索 Ch10-Ch11 的選擇權定價敏感度。"
      }
    },
    "examples": [
      {
        "id": "ex1",
        "title": "7.1 B1_Ch7_1.py",
        "filename": "B1_Ch7_1.py",
        "code": "# B1_Ch7_1.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\nimport numpy as np\nimport matplotlib as mp\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import MultipleLocator\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nt = np.arange(0, 30, 0.01)\nnse1 = np.random.randn(len(t))                 # white noise 1\nnse2 = np.random.randn(len(t))                 # white noise 2\n\n# Two signals with a coherent part at 2Hz and a random part\ns1 = np.sin(2 * np.pi * 2 * t) + nse1\ns2 = np.sin(2 * np.pi * 2 * t) + nse2\n\nfig,ax = plt.subplots(figsize=(11/2.54,7/2.54))\nplt.plot(t, s1, t, s2)\n\nfont = {'family':'Times New Roman','weight':'normal', 'size'   : 8}\nmp.rc('font', **font)\nmp.rcParams['axes.linewidth'] = 0.5\nax.set_xlim(0,2)\nax.set_ylim(-4,4)\nax.set(xlabel='Time [s]', ylabel='Magnitude',title='Figure Title: White Noise')\nax.xaxis.set_major_locator(MultipleLocator(0.5))\nax.xaxis.set_minor_locator(MultipleLocator(0.25))\nax.yaxis.set_major_locator(MultipleLocator(1))\nax.yaxis.set_minor_locator(MultipleLocator(0.5))\nax.tick_params(which='major', length=7,width = 0.5)\nax.tick_params(which='minor', length=4,width = 0.5)\nax.grid(linewidth=0.5,linestyle='--')\nplt.legend(['White noise 1', 'White noise 2'],edgecolor = 'none', facecolor = 'none',loc='upper center')\nplt.show()\n"
      },
      {
        "id": "ex2",
        "title": "7.2 B1_Ch7_2.py",
        "filename": "B1_Ch7_2.py",
        "code": "# B1_Ch7_2.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport math\n \nx1 = np.linspace(0, 6, 20)\nx2 = np.linspace(0,4*math.pi,60)\ny1 = np.exp(x1)-5\ny2 = np.sin(x2)*5\n\nfig,ax1 = plt.subplots(figsize=(11/2.54,7/2.54))\nax1.plot(x1, y1,'b',linewidth = 1)\nax1.set_xlabel('X',color = 'b')\nax1.set_ylabel('Y1',color='b')\n#Add the second y axis\nax2=ax1.twinx()\nax2.set_ylabel('Y1',color='r')\nax2.plot(x2, y2,'r:')\nplt.show()\n"
      },
      {
        "id": "ex3",
        "title": "7.3 B1_Ch7_3.py",
        "filename": "B1_Ch7_3.py",
        "code": "# B1_Ch7_3.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport math\n \nx1 = np.linspace(0, 6, 20)\nx2 = np.linspace(0,4*math.pi,60)\ny1 = np.exp(x1)-5\ny2 = np.sin(x2)*5\n\nfig,ax1 = plt.subplots(figsize=(11/2.54,7/2.54))\nax1.plot(x1, y1,'b',linewidth = 1)\nax1.set_xlabel('X1',color = 'b')\nax1.set_ylabel('Y1',color='b')\n#Add the second y axis\nax2=ax1.twiny()\nax2.set_xlabel('X2',color='r')\nax2.plot(x2, y2,'r:')\n\nplt.show()\n"
      },
      {
        "id": "ex4",
        "title": "7.4 B1_Ch7_4.py",
        "filename": "B1_Ch7_4.py",
        "code": "# B1_Ch7_4.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib as mp\n\nplt.close('all')\nfont = {'family':'Times New Roman','weight':'normal', 'size'   : 10}\nmp.rc('font', **font)\n\nt = np.linspace(-5,5,300)\ny1 = np.sin(t)+np.random.ranf(size = t.size)*0.2\ny2 = np.sin(t ** 2)\nn = 500\nnormal_2D_data =  np.random.normal(0, 2, (n, 2)) \nT = np.arctan2(normal_2D_data[:, 0],normal_2D_data[:, 1]) # for color value\n\n#plot #1\nfig, axs = plt.subplots(1, 2,figsize=(8,5))\naxs[0].plot(t,y1)\naxs[0].set_xlim(-6,6)\naxs[0].set_ylim(-1,2)\naxs[0].set_xlabel(r'$\\mathit{x}_1$')\naxs[0].set_ylabel(r'$\\mathit{y}_1$')\naxs[0].set_title('Plot#1')\naxs[0].set_yticks([-1.5,-1,0,1,1.5])\naxs[1].scatter(normal_2D_data[:, 0], normal_2D_data[:, 1], s=10, c=T, edgecolors = 'none',alpha=.6, cmap='Set1')\naxs[1].set_xlim(-7,7)\naxs[1].set_ylim(-6,6)\naxs[1].set_xlabel(r'$\\mathit{x}_2$')\naxs[1].set_ylabel(r'$\\mathit{y}_2$')\naxs[1].set_title('Plot#2')\n\n#plot #2\nplt.figure(2,figsize=(8,6))\nplt.subplot(211)\nplt.xlim(-6,6)\nplt.ylim(-1.5,1.5)\nplt.xlabel(r'$\\mathit{x}_1$')\nplt.ylabel(r'$\\mathit{y}_1$')\nplt.title('Plot#1')\nplt.plot(t,y1)\nplt.show()\n\nplt.subplot(212)\nplt.scatter(normal_2D_data[:, 0], normal_2D_data[:, 1], s=10, c=T, edgecolors = 'none',alpha=.6, cmap='Set1')\nplt.show()\nplt.xlim(-7,7)\nplt.ylim(-6,6)\nplt.xlabel(r'$\\mathit{x}_2$')\nplt.ylabel(r'$\\mathit{y}_2$')\nplt.title('Plot#2')\n\n#plot #3\nfig, axs = plt.subplots(1, 3,sharex=True,sharey=True,figsize=(8,5))\naxs[0].plot(t,y1*5)\naxs[0].set_xlim(-6,6)\naxs[0].set_ylim(-7,7)\naxs[0].set_xlabel(r'$\\mathit{x}_1$')\naxs[0].set_ylabel(r'$\\mathit{y}_1$')\naxs[0].set_title('Plot#1')\n\naxs[1].plot(t,y2*5)\naxs[1].set_xlim(-6,6)\naxs[1].set_ylim(-6,6)\naxs[1].set_xlabel(r'$\\mathit{x}_2$')\naxs[1].set_ylabel(r'$\\mathit{y}_2$')\naxs[1].set_title('Plot#2')\n\naxs[2].scatter(normal_2D_data[:, 0], normal_2D_data[:, 1], s=10, c=T, edgecolors = 'none',alpha=.6, cmap='Set1')\naxs[2].set_xlim(-7,7)\naxs[2].set_ylim(-6,6)\naxs[2].set_xlabel(r'$\\mathit{x}_3$')\naxs[2].set_ylabel(r'$\\mathit{y}_3$')\naxs[2].set_title('Plot#3')\n\n#plot #4\nfig,ax=plt.subplots(figsize=(8,8))\nax.axis('off')\nfig.add_subplot(3,1,1) \nplt.plot(t,y1*5)\nplt.xlim(-5,5)\nplt.ylim(-5,5)\nplt.yticks([-5,0,5])\nplt.xlabel(r'$\\mathit{x}_1$')\nplt.ylabel(r'$\\mathit{y}_1$')\nplt.title('Plot#1')\n\nfig.add_subplot(3,1,2) \nplt. plot(t,y2*5)\nplt.xlim(-5,5)\nplt.ylim(-5,5)\nplt.yticks([-5,0,5])\nplt.xlabel(r'$\\mathit{x}_2$')\nplt.ylabel(r'$\\mathit{y}_2$')\nplt.title('Plot#2')\n\nfig.add_subplot(3,1,3) \nplt.scatter(normal_2D_data[:, 0], normal_2D_data[:, 1], s=10, c=T, edgecolors = 'none',alpha=.6, cmap='Set1')\nplt.xlim(-7,7)\nplt.ylim(-6,6)\nplt.xlabel(r'$\\mathit{x}_3$')\nplt.ylabel(r'$\\mathit{y}_3$')\nplt.yticks([-6,-2,2,6])\nplt.title('Plot#3')\n\n#plot #5\nfig,ax=plt.subplots()\nfig.add_subplot()\nax.axis('off')\nax.set_xlabel('x')\nax.set_ylabel('y')\nplt.plot(t,y1*5)\nplt.xlim(-5,5)\nplt.title('Plot')\nleft, bottom, width, height = 0.3, 0.65, 0.25, 0.2\nax2=fig.add_axes([left,bottom,width,height])\nax2.plot(t,y1*5)\nax2.set_xlabel('x')\nax2.set_ylabel('y')\n"
      },
      {
        "id": "ex5",
        "title": "7.5 B1_Ch7_5.py",
        "filename": "B1_Ch7_5.py",
        "code": "# B1_Ch7_5.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\nimport matplotlib.pyplot as plt\n\nfig, axs = plt.subplots(2, 2)\n\naxs[0,0].plot([0, 10], [2, 2])\naxs[0,0].plot([3, 3], [0, 5])\naxs[0,0].set_xlim([0,10])\naxs[0,0].set_ylim([0,5])\n\naxs[0,1].axhline(3)\naxs[0,1].axvline(5)\naxs[0,1].set_xlim([0,10])\naxs[0,1].set_ylim([0,5])\n\naxs[1,0].vlines([3, 7],[0],[5],'r',linestyle = ':')\naxs[1,0].hlines([1, 4],[0],[10],'b',linestyle = '--')\naxs[1,0].set_xlim([0,10])\naxs[1,0].set_ylim([0,5])\n\naxs[1,1].axhspan(2.5,3, color = 'r')\naxs[1,1].axvspan(5,6,color = 'b')\naxs[1,1].set_xlim([0,10])\naxs[1,1].set_ylim([0,5])\n"
      },
      {
        "id": "ex6",
        "title": "7.6 B1_Ch7_6.py",
        "filename": "B1_Ch7_6.py",
        "code": "# B1_Ch7_6.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\nimport pandas_datareader as pdr\nimport numpy as np\nimport matplotlib.pyplot as plt\nplt.close('all')\n\ntickers = ['goog', 'amzn']\ndf = pdr.DataReader(tickers, data_source='yahoo', start='2020-01-01', end='2020-12-30')\nfig, ax = plt.subplots()\nax.plot(df.index,df['Adj Close']['goog'],label='Google')\nax.plot(df.index,df['Adj Close']['amzn'],label='Amazon')\ngoog_mean= np.mean(df['Adj Close']['goog'])\namzn_mean = np.mean(df['Adj Close']['amzn'])\nax.set_xlabel('Date')\nax.set_ylabel('Adjusted closing price')\n[ax.axhline(y=i, color = j) for i,j in zip([goog_mean,amzn_mean],['blue','orange']) ]\nfig.text(0.15,0.62,'The average price of Amazon')\nfig.text(0.67,0.22,'The average price of Google')\nax.legend(loc='upper left')\n"
      },
      {
        "id": "ex7",
        "title": "7.7 B1_Ch7_7.py",
        "filename": "B1_Ch7_7.py",
        "code": "# B1_Ch7_7.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport scipy.stats\nimport matplotlib as mp\nplt.close('all')\n\nfont = {'family':'Times New Roman','weight':'normal', 'size'   : 10}\nmp.rc('font', **font)\n\nplt.figure(1)\nplt.subplot()\ndata = np.random.normal(10, 3, 1200)\n_, bins, _ = plt.hist(data, 20, density=1, alpha=1,fill=0)\nmu, sigma = scipy.stats.norm.fit(data)\nbest_fit_line = scipy.stats.norm.pdf(bins, mu, sigma)\nplt.plot(bins, best_fit_line,'b--')\nplt.xlabel('x')\nplt.ylabel('PDF of a Normal Disctribution')\nfig_title = r'$\\frac{1}{3\\sqrt{2\\pi}}e^{-\\frac{1}{2}(\\frac{\\mathit{x}-10}{3})^2}$'\nplt.title(fig_title)\n\ndf_list = [1,2,6,20]\nlinstyles = ['k:','-b','r--','g-.']\nx = np.linspace(-4,4,100)\nfig, axs = plt.subplots(2, 1)\npdf_title = (r'$pdf(x)=\\frac{\\Gamma(\\frac{\\nu+1}{2})}{\\sqrt{\\nu\\pi}\\Gamma(\\frac{\\nu}{2})}(1+\\frac{x^2}{\\nu})^{-(\\frac{\\nu+1}{2})}$')\naxs[0].set_xlabel(r'$\\mathit{x}$')\naxs[0].set_ylabel('pdf(x) of student t distribution')\naxs[0].set_title(pdf_title)\nax_legend=[r'$\\nu=1$',r'$\\nu=2$',r'$\\nu=6$',r'$\\nu=20$']\naxs[1].set_xlabel (r'$\\mathit{x}$')\naxs[1].set_title('cdf(x) of student t distribution')\naxs[1].set_ylabel('cdf(x) of student t distribution')\nfig.tight_layout(pad=1)\nfor mu,line,legend in zip(df_list,linstyles,ax_legend):\n    norm_pdf = scipy.stats.t.pdf(x, mu)\n    axs[0].plot(x, norm_pdf,line,label=legend)\n    norm_cdf = scipy.stats.t.cdf(x, mu)\n    axs[1].plot(x, norm_cdf,line,label=legend)\n\naxs[0].legend(loc=\"upper right\")\naxs[1].legend(loc=\"lower right\")\n"
      },
      {
        "id": "ex8",
        "title": "7.8 B1_Ch7_8.py",
        "filename": "B1_Ch7_8.py",
        "code": "# B1_Ch7_8.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib\nplt.close('all')\nfig,ax = plt.subplots(2,1,figsize=(13/2.54,2*7/2.54))\nfont = {'family':'Times New Roman','weight':'normal', 'size'   : 8}\nmatplotlib.rc('font', **font)\nx = np.linspace(0, 2 * np.pi)\ny_sin = np.sin(x)\ny_cos = np.cos(x)\n#subplot_1\nax[0].errorbar(x, y_sin, 0.2)\nax[0].errorbar(x, y_cos, 0.2)\nax[0].set(xlabel='X', ylabel='Y')\n#subplot_2\nax[1].plot(x,y_sin,x,y_cos)\nax[1].fill_between(x,y_sin+0.2, y_sin-0.2,alpha=0.2)\nax[1].fill_between(x,y_cos+0.2, y_cos-0.2,alpha=0.2)\nax[1].set(xlabel='X', ylabel='Y')\n"
      },
      {
        "id": "ex9",
        "title": "7.9 B1_Ch7_9.py",
        "filename": "B1_Ch7_9.py",
        "code": "# B1_Ch7_9.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport matplotlib\n\nplt.close('all')\nx1 = np.linspace(0, 2 * np.pi, 50)\ny1 = np.exp(0.5*np.sin(x1))*np.sin(3*x1)\n\nfig,ax = plt.subplots(2,1,figsize=(13/2.54,2*7/2.54))\nfont = {'family':'Times New Roman','weight':'normal', 'size'   : 8}\nmatplotlib.rc('font', **font)\n\n#subplot#1\nmarkerline1, stemlines1, baseline1 =ax[0].stem(x1, y1, use_line_collection=False,bottom = -0.5)\nplt.setp(markerline1, fillstyle = 'none',mec = 'g')\nplt.setp(stemlines1, color = 'b',linewidth = 1)\nplt.setp(baseline1,color = 'r',linestyle = '--')\n\n#subplot#2\nx2 = np.linspace(0.1,2*np.pi,10)\nx3 = np.linspace(0.5,2*np.pi,9)\nmarkerline2, stemlines2, baseline2 =ax[1].stem(x2, np.cos(x2), use_line_collection=False)\nmarkerline3, stemlines3, baseline2 =ax[1].stem(x3, np.sin(x3), use_line_collection=False)\nplt.setp(markerline2, marker = 'v',fillstyle = 'none',mec = 'c')\nplt.setp(stemlines2, color = 'm',linewidth = 1)\n"
      },
      {
        "id": "ex10",
        "title": "7.10 B1_Ch7_10.py",
        "filename": "B1_Ch7_10.py",
        "code": "# B1_Ch7_10.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport math\nimport matplotlib\nplt.close('all')\ndx = 0.01; dy = 0.01\nx = np.linspace(-2*math.pi,2*math.pi,100)\ny = np.linspace(0,4*math.pi,100)\nX,Y = np.meshgrid(x,y)\ndef f1(x,y):\n    return (np.sin(x)+np.cos(y))\ndef f2(x,y):\n    return (x*np.sin(x)+y*np.cos(y))\nfig,ax = plt.subplots(2,1,figsize=(13/2.54,2*7/2.54))\n#subplot #1\nC1 = ax[0].contour(X,Y,f1(X,Y),cmap = 'cool')\n#plt.clabel(C, inline=1, fontsize=10)\nax[0].set(xlabel='X', ylabel='Y')\n# The following code is used to plot the continuous colorbar\nnorm= matplotlib.colors.Normalize(vmin=C1.cvalues.min(), vmax=C1.cvalues.max())\nsm = plt.cm.ScalarMappable(norm=norm, cmap = C1.cmap)\nsm.set_array([])\nfig.colorbar(sm, ax=ax[0],ticks=C1.levels)\n#subplot #2\nC2 = ax[1].contourf(X,Y,f2(X,Y),cmap = 'RdBu_r')\nax[1].set(xlabel='X', ylabel='Y')\nfig.colorbar(C2,ax=ax[1])\n"
      },
      {
        "id": "ex11",
        "title": "7.11 B1_Ch7_11.py",
        "filename": "B1_Ch7_11.py",
        "code": "# B1_Ch7_11.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\nimport matplotlib as mpl\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport math\n\nmpl.rcParams['legend.fontsize'] = 10\n\nfig = plt.figure(figsize=plt.figaspect(0.5))\nax1 = fig.add_subplot(1, 2, 1, projection='3d')\nt = np.linspace(0, 10*math.pi, 100)\nx = np.sin(t)\ny = np.cos(t)\nax1.plot(x, y, t, 'o-',markerfacecolor='#D9FFFF')\nax1.set_xticks([-1,0,1])\nax1.set_yticks([-1,0,1])\nax1.set_zticks([0,10,20,30])\n\nax2 = fig.add_subplot(1, 2, 2, projection='3d')\nt = np.linspace(-10, 10, 1000)\nx = np.exp(-1*t/10)*np.sin(5*t)\ny = np.exp(-1*t/10)*np.cos(5*t)\nax2.plot(x, y, t, markerfacecolor='#D9FFFF')\nax2.set_xticks([-2,-1,0,1,2])\nax2.set_yticks([-2,-1,0,1,2])\nax2.set_zticks([-10,-5,0,5,10])\nplt.show()\n"
      },
      {
        "id": "ex12",
        "title": "7.12 B1_Ch7_13.py",
        "filename": "B1_Ch7_12.py",
        "code": "# B1_Ch7_13.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport mpl_toolkits.mplot3d.art3d as art3d\n\nz = np.linspace(0,4*np.pi,300)\nx = 2*np.cos(z) + np.random.rand(1,300)\ny = np.cos(x) + np.random.rand(1,300)\n\nfig = plt.figure()\nax = fig.add_subplot(121, projection='3d')\nax.scatter(x, y, z)\n\nax = fig.add_subplot(1, 2, 2, projection='3d')\nN = 100\ntheta = np.linspace(0, 2*np.pi, N, endpoint=False)\nx = np.cos(theta)\ny = np.sin(theta)\nz = range(N)\nfor xi, yi, zi in zip(x, y, z):        \n    line=art3d.Line3D(*zip((xi, yi, 0), (xi, yi, zi)), marker='o', markevery=(1, 1))\n    ax.add_line(line)\nax.set_xlim3d(-1, 1)\nax.set_ylim3d(-1, 1)\nax.set_zlim3d(0, N)    \nplt.show()\n"
      },
      {
        "id": "ex13",
        "title": "7.13 B1_Ch7_13.py",
        "filename": "B1_Ch7_13.py",
        "code": "# B1_Ch7_13.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\nimport math\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import norm\nfrom matplotlib import cm,ticker\n\nplt.close('all')\n# Gamma of European option\n\ndef blsgamma(St, K, tau, r, vol, q):\n    d1 = (math.log(St / K) + (r - q + 0.5 * vol ** 2)\\\n          *tau) / (vol * math.sqrt(tau));\n        \n    Gamma = math.exp(-q*tau)*norm.pdf(d1)/St/vol/math.sqrt(tau);\n\n    return Gamma\n    \n# Initialize\ntau_array = np.linspace(0.1,1,20);\nSt_array  = np.linspace(20,80,20);\ntau_Matrix,St_Matrix = np.meshgrid(tau_array,St_array)\n\nDelta_call_Matrix = np.empty(np.size(tau_Matrix))\nDelta_put_Matrix  = np.empty(np.size(tau_Matrix))\n\nK = 60;    # strike price\nr = 0.025;  # risk-free rate\nvol = 0.45; # volatility \nq = 0;     # continuously compounded yield of the underlying asset\n\nblsgamma_vec = np.vectorize(blsgamma)\nGamma_Matrix = blsgamma_vec(St_Matrix, K, tau_Matrix, r, vol, q)\n\nfig = plt.figure(figsize=(8,12))\nax1 = fig.add_subplot(2, 1, 1, projection='3d')\nsur=ax1.plot_surface(tau_Matrix, St_Matrix, Gamma_Matrix, cmap='coolwarm')\nsur.set_facecolor((0,0,0,0))\ncb = fig.colorbar(sur,ax=ax1, shrink=0.4, aspect=10)\ntick_locator = ticker.MaxNLocator(nbins=5)\ncb.locator = tick_locator\ncb.update_ticks()\n\nax1.set_xticks([0,0.2,0.4,0.6,0.8])\nax1.set_yticks([10,30,50,70,90])\nax1.set_zticks([0,0.02,0.04])\nax1.set_xlabel('Time to maturity (year)')\nax1.set_ylabel('Underlying price')\nax1.set_zlabel('Gamma')\n\nax2 = fig.add_subplot(2, 1, 2, projection='3d')\nax2.plot_wireframe(tau_Matrix, St_Matrix, Gamma_Matrix, linewidth=1)\nax2.set_xlabel('Time to maturity (year)')\nax2.set_ylabel('Underlying price')\nax2.set_zlabel('Gamma')\n#%%\nfig = plt.figure(figsize=(8,12))\nax1 = fig.add_subplot(2, 1, 1, projection='3d')\nax1.contour(tau_Matrix, St_Matrix, Gamma_Matrix, levels = 20, zdir='x', \\\n          offset=0.2, cmap=cm.coolwarm)\nax1.view_init(azim=0, elev=0)\nax1.set_xticks([])\nax1.w_xaxis.line.set_lw(0.)\nax1.set_ylabel('Underlying price')\nax1.set_zlabel('Gamma')\n\nnorm = plt.Normalize(Gamma_Matrix.min(), Gamma_Matrix.max())\ncolors = cm.coolwarm(norm(Gamma_Matrix))\nax2 = fig.add_subplot(2, 1, 2, projection='3d')\nsur=ax2.plot_surface(tau_Matrix, St_Matrix, Gamma_Matrix, facecolors=colors, shade=False)\nsur.set_facecolor((0,0,0,0))\nax2.contour(tau_Matrix, St_Matrix, Gamma_Matrix, levels = 20, zdir='x', \\\n          offset=0, cmap=cm.coolwarm)\nax2.set_xlabel('Time to maturity (year)')\nax2.set_ylabel('Underlying price')\nax2.set_zlabel('Gamma')\n"
      },
      {
        "id": "ex14",
        "title": "7.14 B1_Ch7_14.py",
        "filename": "B1_Ch7_14.py",
        "code": "# B1_Ch7_14.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\nimport matplotlib.pyplot as plt\n# Pie chart, where the slices will be ordered and plotted counter-clockwise:\nlabels = 'Salaries and Wages', 'Office Equipment and Supplies', 'Rents', 'Marketing'\nsizes = [40, 20, 25, 15]\nexplode = (0.1, 0.1, 0, 0)  # only \"explode\" the 2nd slice (i.e. 'Hogs')\n\nfig1, ax1 = plt.subplots()\nax1.pie(sizes, labels=labels, autopct='%1.1f%%',\n        shadow=True, startangle=90)\nax1.axis('equal')  # Equal aspect ratio ensures that pie is drawn as a circle.\nax1.set_title('Operating Expenses of a company, unexploded')\nplt.show()\n\nfig1, ax1 = plt.subplots()\nax1.pie(sizes, explode=explode, labels=labels, autopct='%1.1f%%',\n        shadow=True, startangle=90)\nax1.axis('equal')  # Equal aspect ratio ensures that pie is drawn as a circle.\nax1.set_title('Operating Expenses of a company, partially exploded')\nplt.show()\n"
      },
      {
        "id": "ex15",
        "title": "7.15 B1_Ch7_15.py",
        "filename": "B1_Ch7_15.py",
        "code": "# B1_Ch7_15.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport pandas_datareader as pdr\nplt.close('all')\n\ntickers = ['goog', 'amzn']\ndf = pdr.DataReader(tickers, data_source='yahoo', start='2020-01-01', end='2020-12-30')\n\ngoog_Q1_mean= np.mean(df['Adj Close']['goog']['2020-01-02':'2020-03-31'])\ngoog_Q2_mean= np.mean(df['Adj Close']['goog']['2020-04-01':'2020-06-30'])\ngoog_Q3_mean= np.mean(df['Adj Close']['goog']['2020-07-01':'2020-08-30'])\ngoog_Q4_mean= np.mean(df['Adj Close']['goog']['2020-09-01':'2020-12-30'])\namzn_Q1_mean= np.mean(df['Adj Close']['amzn']['2020-01-02':'2020-03-31'])\namzn_Q2_mean= np.mean(df['Adj Close']['amzn']['2020-04-01':'2020-06-30'])\namzn_Q3_mean= np.mean(df['Adj Close']['amzn']['2020-07-01':'2020-08-30'])\namzn_Q4_mean= np.mean(df['Adj Close']['amzn']['2020-09-01':'2020-12-30'])\n\nlabels = ['Q1', 'Q2', 'Q3', 'Q4']\ngoog_means = [goog_Q1_mean, goog_Q2_mean, goog_Q3_mean, goog_Q4_mean]\namazn_means = [amzn_Q1_mean, amzn_Q2_mean, amzn_Q3_mean, amzn_Q4_mean]\n\nx = np.arange(len(labels))  # the label locations\nwidth = 0.35  # the width of the bars\n\n#Bar chart using Matplotlib\nfig, ax = plt.subplots(2,1)\nax[0].bar(x - width/2, goog_means, width, label='Google')\nax[0].bar(x + width/2, amazn_means, width, label='Amazon')\nax[0].set_ylabel('Adjusted closing price')\nax[0].set_xticks(x)\nax[0].set_xticklabels(labels)\nax[0].legend()\n\nax[1].barh(x - width/2, goog_means, width, label='Google')\nax[1].barh(x + width/2, amazn_means, width, label='Amazon')\nax[1].set_xlabel('Adjusted closing price')\nax[1].set_yticks(x)\nax[1].set_yticklabels(labels)\nax[1].legend()\n#%% bar chart by using seaborn\nplt.subplot\nprice = goog_means + amazn_means\nstock = ['Google']*4 + ['Amazon']*4\nQuarter = labels*2\ndf = pd.DataFrame({'Quarter':Quarter,'Adjusted closing price':price,'Stock':stock})\nfig, ax = plt.subplots(2,1)\nsns.barplot(x='Quarter', y='Adjusted closing price',hue='Stock',data=df,ci=None,palette=\"Set2\",ax=ax[0])\nsns.barplot(y='Quarter', x='Adjusted closing price',hue='Stock',data=df,ci=None,palette=\"Set2\",ax=ax[1])\n#%% bar chart by using pandas\ndf = pd.DataFrame({'Google':goog_means,'Amazon':amazn_means},index=labels)\nfig, ax = plt.subplots(2,1)\ndf.plot.bar(rot=0,color={'Google':'red','Amazon':'blue'},ax=ax[0])\nax[0].set_ylabel(\"Adjusted closing price\")\ndf.plot.barh(rot=0,color={'Google':'red','Amazon':'blue'},ax=ax[1])\nax[1].set_xlabel(\"Adjusted closing price\")\n"
      },
      {
        "id": "ex16",
        "title": "7.16 B1_Ch7_16.py",
        "filename": "B1_Ch7_16.py",
        "code": "# B1_Ch7_16.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\nimport numpy as np\nimport matplotlib.pyplot as plt\ndist_list = ['uniform','normal','exponential','lognormal','chisquare','beta']\nparam_list = ['-2,2','0,1','1','0,1','2','0.5,0.9']\ncolors_list = ['green','blue','yellow','cyan','magenta','pink']\nfig,ax = plt.subplots(nrows=2, ncols=3,figsize=(12,7))\nplt_ind_list = np.arange(6)+231\n\nfor dist, plt_ind, param, colors in zip(dist_list, plt_ind_list, param_list, colors_list):\n    x = eval('np.random.'+dist+'('+param+',5000)') \n    plt.subplot(plt_ind)\n    plt.hist(x,bins=50,color=colors)\n    plt.title(dist)\n\nfig.subplots_adjust(hspace=0.4,wspace=.3) \nplt.suptitle('Random Data from Various Distributions',fontsize=20)\nplt.show()\n"
      },
      {
        "id": "ex17",
        "title": "7.17 B1_Ch7_17.py",
        "filename": "B1_Ch7_17.py",
        "code": "# B1_Ch7_17.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport math\nfrom matplotlib.widgets import Slider, Button\n\nfig, ax = plt.subplots()\nplt.subplots_adjust(bottom=0.4)\nt = np.arange(0.0, 1.0, 0.001)\na0,f0,fi0,p0 = 7,4,0,0\ndelta_f = 5.0\ns = a0 * np.sin(2 * np.pi * f0 * t + fi0) + p0\nl, = plt.plot(t, s, lw=2)\nax.margins(x=0)\nplt.xlabel('Time [s]')\nplt.ylabel(r'$\\it{sin(t)}$')\n\naxcolor = 'lightgoldenrodyellow'\naxfreq = plt.axes([0.25, 0.1, 0.65, 0.03], facecolor=axcolor)\naxamp = plt.axes([0.25, 0.15, 0.65, 0.03], facecolor=axcolor)\naxfi = plt.axes([0.25, 0.2, 0.65, 0.03], facecolor=axcolor)\naxp = plt.axes([0.25, 0.25, 0.65, 0.03], facecolor=axcolor)\n\nsfreq = Slider(axfreq, 'Frequency', 0.1, 30.0, valinit=f0, valstep=delta_f)\nsamp = Slider(axamp, 'Amplitude', 0.1, 10.0, valinit=a0,valstep = 0.5)\nsfi = Slider(axfi,'Phase',0,2*math.pi,valinit=fi0,valstep = math.pi/20)\nsp = Slider(axp,'Offset',0,4,valinit=p0,valstep = 0.5)\n\ndef update(val):\n    amp = samp.val\n    freq = sfreq.val\n    fi = sfi.val\n    p = sp.val\n    l.set_ydata(amp*np.cos(2*np.pi*freq*t+fi)+p)\n    fig.canvas.draw_idle()\nsfreq.on_changed(update)\nsamp.on_changed(update)\nsfi.on_changed(update)\nsp.on_changed(update)\n\nresetax = plt.axes([0.8, 0.025, 0.1, 0.04])\nbutton = Button(resetax, 'Reset', color=axcolor, hovercolor='0.975')\n\ndef reset(event):\n    sfreq.reset()\n    samp.reset()\nbutton.on_clicked(reset)\nplt.show()\n"
      },
      {
        "id": "ex18",
        "title": "7.18 B1_Ch7_18.py",
        "filename": "B1_Ch7_18.py",
        "code": "# B1_Ch7_18.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\nimport matplotlib.pyplot as plt\nfrom matplotlib.widgets import Slider, Button\nimport math\nimport numpy as np\nfrom scipy.stats import norm\nfrom matplotlib.font_manager import FontProperties\n\nfont = FontProperties()\nfont.set_family('serif')\nfont.set_name('Times New Roman')\nfont.set_size(12)\n\nS0 = 50;    # spot price\nS_array  = np.linspace(20,80,26);\ndelta_S = S_array[1]-S_array[0];\n\nK0 = 50;    # strike price\nK_array  = np.linspace(20,80,26);\ndelta_K = K_array[1]-K_array[0];\n\nr0 = 0.03;  # risk-free rate\nr_array  = np.linspace(0.01,0.05,26);\ndelta_r = r_array[1]-r_array[0];\n\nvol0 = 0.5; # volatility \nvol_array  = np.linspace(0.01,0.9,26);\ndelta_vol = vol_array[1]-vol_array[0];\n\nq0 = 0;     # continuously compounded yield of the underlying asset\nq_array  = np.linspace(0,0.02,26);\ndelta_q = q_array[2]-q_array[1];\n\ntau0 = 1;     # time to maturity\ntau_array  = np.linspace(0.1,1,26);\ndelta_tau = tau_array[2]-tau_array[1];\n\n# Delta of European option\n\ndef blsprice(St, K, tau, r, vol, q):\n    \n    d1 = (math.log(St / K) + (r - q + 0.5 * vol ** 2)\\\n          *tau) / (vol * math.sqrt(tau));\n    d2 = d1 - vol*math.sqrt(tau);\n    \n    Call = norm.cdf(d1, loc=0, scale=1)*St*math.exp(-q*tau) - \\\n        norm.cdf(d2, loc=0, scale=1)*K*math.exp(-r*tau)\n        \n    Put  = -norm.cdf(-d1, loc=0, scale=1)*St*math.exp(-q*tau) + \\\n        norm.cdf(-d2, loc=0, scale=1)*K*math.exp(-r*tau)\n        \n    return Call, Put\n\ndef plot_curve(S_array,Call_array,Put_array,text):\n    \n    fig, axs = plt.subplots(1,3,figsize=(13,7))\n\n    a1, = axs[0].plot(S_array, Call_array)\n    x_label = '$\\it{' + text + '}$'\n    axs[0].set_xlabel(x_label, fontname=\"Times New Roman\", fontsize=12)\n    y_label = '$\\it{C}$($\\it{' + text + '}$)'\n    axs[0].set_ylabel(y_label, family=\"Times New Roman\", fontsize=12)\n    axs[0].grid(linestyle='--', linewidth=0.25, color=[0.5,0.5,0.5])\n\n    a2,=axs[1].plot(S_array, Put_array)\n    axs[1].set_xlabel(x_label, family=\"Times New Roman\", fontsize=12)\n    y_label = '$\\it{P}$($\\it{' + text + '}$)'\n    axs[1].set_ylabel(y_label, fontname=\"Times New Roman\", fontsize=12)\n    axs[1].grid(linestyle='--', linewidth=0.25, color=[0.5,0.5,0.5])\n    axs[2].axis('off')\n    return fig,a1,a2,axs[2]\n\ndef plot_contour(S_array,Call_array,Put_array,label1,label2):\n    \n    fig, axs = plt.subplots(1,3,figsize=(13,7))\n    cntr1 = axs[0].contourf(S_Matrix, tau_Matrix, Call_Matrix, levels = 20, cmap=\"RdBu_r\")\n    cntr2 = axs[1].contourf(S_Matrix, tau_Matrix, Put_Matrix, levels = 20, cmap=\"RdBu_r\")\n    fig.colorbar(cntr2, ax=axs[1])\n    fig.colorbar(cntr1, ax=axs[0])\n    axs[2].axis('off')\n    x_label1 = '$\\it{' + label1 + '}$'\n    axs[0].set_xlabel(x_label1, fontname=\"Times New Roman\", fontsize=12)\n    y_label1 = '$\\it{C}$($\\it{' + label1+','+label2+ '}$)'\n    axs[0].set_ylabel(y_label1, family=\"Times New Roman\", fontsize=12)\n    x_label2 = '$\\it{' + label2 + '}$'\n    axs[1].set_xlabel(x_label2, fontname=\"Times New Roman\", fontsize=12)\n    y_label1 = '$\\it{P}$($\\it{' + label1+','+label2+ '}$)'\n    axs[1].set_ylabel(y_label1, family=\"Times New Roman\", fontsize=12)    \n    plt.show()\n    return fig,axs[0],axs[1],axs[2]\n\nblsprice_vec = np.vectorize(blsprice)\n#%% option vs S\n\nplt.close('all')\n\nCall_array, Put_array = blsprice_vec(S_array, K0, tau0, r0, vol0, q0)\n\nS_plot,S_ax1,S_ax2,a3 = plot_curve(S_array,Call_array,Put_array,'S')\n\naxcolor = 'lightgoldenrodyellow'\nax_K = plt.axes([0.7, 0.7+0.1, 0.2, 0.03], facecolor=axcolor)\nax_r = plt.axes([ 0.7,0.55+0.1, 0.2, 0.03], facecolor=axcolor)\nax_vol = plt.axes([ 0.7,0.4+0.1, 0.2, 0.03], facecolor=axcolor)\nax_q = plt.axes([ 0.7, 0.25+0.1,0.2, 0.03], facecolor=axcolor)\nax_tau = plt.axes([ 0.7, 0.1+0.1,0.2, 0.03], facecolor=axcolor)\n\nK_slider = Slider(ax_K, r'$\\it{K}$', K_array[0], K_array[-1], valinit=K0, valstep=delta_K)\nr_slider = Slider(ax_r, r'$\\it{r}$', r_array[0], r_array[-1], valinit=r0, valstep=delta_r)\nvol_slider = Slider(ax_vol, r'$\\it{vol}$', vol_array[0], vol_array[-1], valinit=vol0, valstep=delta_vol)\nq_slider = Slider(ax_q, r'$\\it{q}$', q_array[0], q_array[-1], valinit=q0, valstep=delta_q)\ntau_slider = Slider(ax_tau,  r'$\\it{tau}$', tau_array[0], tau_array[-1], valinit=tau0, valstep=delta_tau)\n\ndef update(val):\n    K = K_slider.val\n    tau = tau_slider.val\n    r = r_slider.val\n    vol = vol_slider.val\n    q = q_slider.val\n    Call_array, Put_array = blsprice_vec(S_array, K, tau, r, vol, q)\n    S_ax1.set_ydata(Call_array)\n    S_ax2.set_ydata(Put_array)\n    S_plot.canvas.draw_idle()\n\nK_slider.on_changed(update)\ntau_slider.on_changed(update)\nr_slider.on_changed(update)\nq_slider.on_changed(update)\nvol_slider.on_changed(update)\n\nresetax = plt.axes([0.75, 0.1, 0.1, 0.04])\nbutton1 = Button(resetax, 'Reset', color=axcolor, hovercolor='0.975')\n\ndef reset1(event):\n    K_slider.reset()\n    tau_slider.reset()\n    r_slider.reset()\n    vol_slider.reset()\n    q_slider.reset()\n    \nbutton1.on_clicked(reset1)\n#%%\nS_Matrix,tau_Matrix = np.meshgrid(S_array,tau_array)\nCall_Matrix, Put_Matrix = blsprice_vec(S_Matrix, K0, tau_Matrix, r0, vol0, q0)\nC_plot,C_ax1,C_ax2,C_ax3 = plot_contour(S_array,Call_Matrix,Put_Matrix,'S','Tau')\n\n\nax_K2 = plt.axes([0.7, 0.7+0.1, 0.2, 0.03], facecolor=axcolor)\nax_r2 = plt.axes([ 0.7,0.55+0.1, 0.2, 0.03], facecolor=axcolor)\nax_vol2 = plt.axes([ 0.7,0.4+0.1, 0.2, 0.03], facecolor=axcolor)\nax_q2 = plt.axes([ 0.7, 0.25+0.1,0.2, 0.03], facecolor=axcolor)\n\nK_slider2 = Slider(ax_K2, r'$\\it{K}$', K_array[0], K_array[-1], valinit=K0, valstep=delta_K)\nr_slider2 = Slider(ax_r2, r'$\\it{r}$', r_array[0], r_array[-1], valinit=r0, valstep=delta_r)\nvol_slider2 = Slider(ax_vol2, r'$\\it{vol}$', vol_array[0], vol_array[-1], valinit=vol0, valstep=delta_vol)\nq_slider2 = Slider(ax_q2, r'$\\it{q}$', q_array[0], q_array[-1], valinit=q0, valstep=delta_q)\n\ndef update(val):\n    K = K_slider2.val\n    r = r_slider2.val\n    vol = vol_slider2.val\n    q = q_slider2.val\n    Call_Matrix, Put_Matrix = blsprice_vec(S_Matrix, K, tau_Matrix, r, vol, q)\n    C_ax1.cla()\n    C_ax2.cla()\n    C_ax1.contourf(S_Matrix, tau_Matrix, Call_Matrix, levels = 20, cmap=\"RdBu_r\")\n    C_ax2.contourf(S_Matrix, tau_Matrix, Put_Matrix, levels = 20, cmap=\"RdBu_r\")\n\nK_slider2.on_changed(update)\nr_slider2.on_changed(update)\nq_slider2.on_changed(update)\nvol_slider2.on_changed(update)\n\nresetax = plt.axes([0.75, 0.2, 0.1, 0.04])\nbutton2 = Button(resetax, 'Reset', color=axcolor, hovercolor='0.975')\n\ndef reset2(event):\n    K_slider2.reset()\n    r_slider2.reset()\n    vol_slider2.reset()\n    q_slider2.reset() \nbutton2.on_clicked(reset2)\n"
      }
    ]
  },
  {
    "id": "b1_ch8",
    "title": "第8章：機率與統計 I",
    "number": 8,
    "content": {
      "intro": {
        "title": "第 8 章：機率與統計 I - 詳解",
        "roadmap": {
          "guide": "",
          "objectives": "掌握金融建模的機率論基石。本章深入探討隨機變數、常見分布（正態、對數正態）以及貝氏定理，為風險度量與模型預測提供嚴謹的統計支撐。",
          "topics": "*   8.1 基礎機率概念與隨機事件\n*   8.2 貝氏定理 (Bayes' Theorem) 金融應用\n*   8.3 隨機變數 (Random Variables) 定義\n*   8.4 離散型隨機變數的機率分佈\n*   8.5 連續型隨機變數的機率分佈\n*   8.6 正態分佈 (Normal) 與對數正態分佈應用"
        },
        "value": {
          "practical": "*   **實務場景**：計算特定置信度下的最大潛在損失（VaR）。\n*   **考試重點**：正態分布的性質（68-95-99.7 法則）及貝氏定理的考算。",
          "theory": "*   **正態分布與金融悖論**：金融領域常假設資產收益率服從正態分布，但實務中存在「厚尾」現象。理解 $\\mu$（期望）與 $\\sigma$（風險）的統計意義及其在計算 95% 或 99% 置信度下的資產波動範圍。\n*   **對數正態分布 (Lognormal Distribution)**：解釋為何資產價格通常使用對數正態分布建模（價格不能為負且具有連乘屬性）。",
          "further_reading": "*   t 分布與單極值理論 (EVT)：解決厚尾風險的進階模型。"
        },
        "implementation": {
          "python": "*   **隨機性模擬**：使用 Python 的 `random` 與 `scipy.stats` 模組可以瞬間模擬出上萬條資產價格路徑。\n*   **分布擬合**：自動檢測歷史數據最符合哪種理論分布。",
          "logic": "*   `scipy.stats.norm.cdf()` / `ppf()`：累積密度函數與分位數函數，這是計算 VaR 的核心函數。\n*   貝氏公式實作：在獲得新信息（如：公司營收優於預期）時，如何使用 Python 更新違約機率估計。",
          "scenarios": "| 腳本名稱 | 核心使命 |\n| :--- | :--- |\n| **B1_Ch8_1.py** | 演示伯努利分佈 (Bernoulli) 實驗與大數法則驗證。 |\n| **B1_Ch8_2.py** | 實作三門問題 (Monty Hall Problem) 的蒙地卡羅模擬實驗。 |\n| **B1_Ch8_3.py** | 應用貝氏定理 (Bayes Theorem) 計算信用違約的後驗機率。 |\n| **B1_Ch8_4.py** | 演示隨機數種子 (Seed) 對模擬結果可重複性的重要性。 |\n| **B1_Ch8_5.py** | 計算離散隨機變數的期望值與變異數。 |\n| **B1_Ch8_6.py** | 利用 SciPy 計算二項分佈 (Binomial Distribution) 的 PMF 與 CDF。 |\n| **B1_Ch8_7.py** | 演示常態分佈的概率密度函數曲線及其對稱性特徵。 |\n| **B1_Ch8_8.py** | 實作泊松分佈 (Poisson Distribution) 模型，模擬稀有風險事件次數。 |\n| **B1_Ch8_9.py** | 演示幾何分佈 (Geometric Distribution) 在等待時間模型中的應用。 |\n| **B1_Ch8_10.py** | 繪製泊松分佈 (Poisson Distribution) 的 PMF 圖形，視覺化離散機率分佈。 |\n| **B1_Ch8_11.py** | 演示連續均勻分佈 (Uniform Distribution) 的 PDF 與 CDF 曲線。 |\n| **B1_Ch8_12.py** | 繪製指數分佈 (Exponential Distribution) 的 PDF 與 CDF，應用於事件等待時間。 |\n| **B1_Ch8_13.py** | 演示 Beta 分佈在不同 Alpha/Beta 參數下的 PDF 形狀變化。 |\n| **B1_Ch8_14.py** | 繪製 Gamma 分佈的 PDF 曲線，分析形狀參數對分佈的影響。 |\n| **B1_Ch8_15.py** | 視覺化標準常態分佈的 PDF 曲線，計算其統計動差。 |\n| **B1_Ch8_16.py** | 實作 68-95-99.7 法則圖解，演示常態分佈的標準差區間機率。 |\n| **B1_Ch8_17.py** | 繪製對數常態分佈 (Lognormal Distribution) 的 PDF 與 CDF，應用於資產價格建模。 |"
        },
        "body": "### 8.1 基礎機率概念與隨機事件\n\n#### 概念定義\n機率是度量不確定性的數學語言，核心概念包括：\n- **樣本空間 (Ω)**：所有可能結果的集合\n- **事件 (Event)**：樣本空間的子集\n- **機率公理**：非負性、正規性、可加性\n- **條件機率**：$P(A|B) = \\frac{P(A \\cap B)}{P(B)}$\n\n#### 財金理論背景\n金融本質上是不確定的：\n- 股價變動是隨機事件\n- 違約是二元事件\n- 市場狀態是多值事件\n\n機率論是量化這些不確定性的基礎。\n\n#### 數學公式或模型\n條件機率與獨立性：\n$$\nP(A \\cap B) = P(A|B) \\cdot P(B)\n$$\n\n若 A, B 獨立：$P(A \\cap B) = P(A) \\cdot P(B)$\n\n#### Python 實現邏輯\n```python\nimport numpy as np\nfrom itertools import product\n\n# 樣本空間：擲兩個骰子\nomega = list(product(range(1, 7), repeat=2))\nprint(f\"樣本空間大小: {len(omega)}\")  # 36\n\n# 事件：點數和為 7\nevent_7 = [x for x in omega if sum(x) == 7]\nprob_7 = len(event_7) / len(omega)  # 6/36 = 1/6\n\n# 蒙地卡羅估計\nn_sims = 100000\nrolls = np.random.randint(1, 7, size=(n_sims, 2))\nmc_prob = (rolls.sum(axis=1) == 7).mean()\n```\n\n#### 常見陷阱與注意事項\n- **獨立 vs 互斥**：互斥事件不可能獨立\n- **條件機率方向**：$P(A|B) \\neq P(B|A)$\n- **小樣本偏差**：蒙地卡羅需足夠多次模擬\n\n#### 實務應用場景\n- 計算違約事件的聯合機率\n- 評估多重風險因子的獨立性\n- 情境分析的機率權重\n\n#### 與其他章節的關聯\n條件機率是 Ch8.2 貝氏定理的基礎，蒙地卡羅模擬貫穿 Ch10-Ch11。\n\n---\n\n### 8.2 貝氏定理 (Bayes' Theorem) 金融應用\n\n#### 概念定義\n**貝氏定理**描述如何根據新資訊更新機率信念：\n$$\nP(A|B) = \\frac{P(B|A) \\cdot P(A)}{P(B)}\n$$\n\n- **先驗機率 $P(A)$**：觀察前的信念\n- **後驗機率 $P(A|B)$**：觀察後更新的信念\n- **似然 $P(B|A)$**：在 A 條件下觀察到 B 的機率\n\n#### 財金理論背景\n信用風險分析的核心：\n- 已知公司過去財報好壞，更新違約機率\n- 收到評等調降消息，修正風險評估\n- 結合市場資訊與歷史數據\n\n#### 數學公式或模型\n全機率公式展開：\n$$\nP(A|B) = \\frac{P(B|A) \\cdot P(A)}{P(B|A) \\cdot P(A) + P(B|\\bar{A}) \\cdot P(\\bar{A})}\n$$\n\n#### Python 實現邏輯\n```python\n# 信用風險貝氏更新範例\n# 假設：\n#   P(違約) = 0.02 (先驗)\n#   P(財報差|違約) = 0.8\n#   P(財報差|不違約) = 0.1\n\np_default = 0.02\np_bad_report_given_default = 0.8\np_bad_report_given_no_default = 0.1\n\n# 觀察到財報差，更新違約機率\np_bad_report = (p_bad_report_given_default * p_default + \n                p_bad_report_given_no_default * (1 - p_default))\n\np_default_given_bad_report = (p_bad_report_given_default * p_default) / p_bad_report\nprint(f\"後驗違約機率: {p_default_given_bad_report:.2%}\")  # ~14%\n```\n\n#### 常見陷阱與注意事項\n- **基底率謬誤**：忽略先驗機率會導致錯誤判斷\n- **資訊品質**：似然估計依賴歷史數據準確性\n- **多次更新**：後驗可作為下次更新的先驗\n\n#### 實務應用場景\n- 信用評等遷移機率更新\n- 結合市場資訊的違約預測\n- 詐欺偵測系統的機率校準\n\n#### 與其他章節的關聯\n貝氏思維在 Ch9 的參數估計中延伸為貝氏估計方法。\n\n---\n\n### 8.3 隨機變數 (Random Variables) 定義\n\n#### 概念定義\n**隨機變數**是將隨機實驗結果映射到數值的函數：\n- **離散型**：取值可數（如：違約次數 0, 1, 2, ...）\n- **連續型**：取值連續（如：報酬率 -∞ 到 +∞）\n\n核心描述：\n- **PMF/PDF**：機率質量/密度函數\n- **CDF**：累積分佈函數\n\n#### 財金理論背景\n金融模型的基礎元素：\n- 報酬率 $R$ 是連續隨機變數\n- 違約指標 $1_{default}$ 是 Bernoulli 隨機變數\n- 損失次數 $N$ 是離散隨機變數\n\n#### 數學公式或模型\n期望值與變異數：\n$$\nE[X] = \\sum_{x} x \\cdot P(X=x) \\quad \\text{(離散)}\n$$\n$$\nE[X] = \\int_{-\\infty}^{\\infty} x \\cdot f(x) dx \\quad \\text{(連續)}\n$$\n\n#### Python 實現邏輯\n```python\nfrom scipy import stats\n\n# 離散隨機變數：二項分佈\nn, p = 10, 0.3\nbinom_rv = stats.binom(n, p)\nprint(f\"PMF P(X=3): {binom_rv.pmf(3):.4f}\")\nprint(f\"CDF P(X<=3): {binom_rv.cdf(3):.4f}\")\nprint(f\"期望值: {binom_rv.mean()}\")  # n*p = 3\n\n# 連續隨機變數：常態分佈\nmu, sigma = 0.05, 0.20\nnorm_rv = stats.norm(mu, sigma)\nprint(f\"PDF at x=0: {norm_rv.pdf(0):.4f}\")\nprint(f\"CDF P(X<0): {norm_rv.cdf(0):.4f}\")  # 虧損機率\nprint(f\"分位數 VaR_95: {norm_rv.ppf(0.05):.4f}\")  # 5% 分位數\n```\n\n#### 常見陷阱與注意事項\n- **PDF 不是機率**：連續分佈中 $P(X=x)=0$，PDF 可以 >1\n- **CDF 方向**：$F(x) = P(X \\le x)$\n- **分位數定義**：`ppf(0.05)` 返回左尾 5% 的值\n\n#### 實務應用場景\n- 定義資產報酬率的隨機模型\n- 計算 VaR 和 ES\n- 模擬蒙地卡羅路徑\n\n#### 與其他章節的關聯\n隨機變數是 Ch8.4-8.6 各種分佈的載體，也是 Ch4 Cholesky 模擬的基礎。\n\n---\n\n### 8.4 離散型隨機變數的機率分佈\n\n#### 概念定義\n常見離散分佈：\n- **Bernoulli**：單次二元實驗（成功/失敗）\n- **Binomial**：n 次獨立 Bernoulli 的成功總數\n- **Poisson**：單位時間內稀有事件次數\n- **Geometric**：首次成功前的失敗次數\n\n#### 財金理論背景\n- **Bernoulli**：單一對手是否違約\n- **Binomial**：n 個對手中違約的數量\n- **Poisson**：一年內操作風險事件次數\n- **Geometric**：首次違約發生在第幾期\n\n#### 數學公式或模型\nPoisson 分佈（$\\lambda$ = 期望次數）：\n$$\nP(X=k) = \\frac{\\lambda^k e^{-\\lambda}}{k!}\n$$\n\n#### Python 實現邏輯\n```python\nfrom scipy import stats\n\n# Bernoulli：單次違約\ndefault_rv = stats.bernoulli(p=0.02)\nprint(f\"違約機率: {default_rv.pmf(1)}\")\n\n# Binomial：100 個對手中違約數\nn, p = 100, 0.02\nbinom_rv = stats.binom(n, p)\nprint(f\"正好 2 個違約: {binom_rv.pmf(2):.4f}\")\nprint(f\"超過 5 個違約: {1 - binom_rv.cdf(5):.4f}\")\n\n# Poisson：年損失次數\nlambda_ = 3.5  # 年平均 3.5 次\npoisson_rv = stats.poisson(lambda_)\nprint(f\"0 次損失: {poisson_rv.pmf(0):.4f}\")\nprint(f\"超過 5 次: {1 - poisson_rv.cdf(5):.4f}\")\n\n# Geometric：首次違約期數\ngeom_rv = stats.geom(p=0.02)  # 每期違約機率 2%\nprint(f\"期望等待期數: {geom_rv.mean():.1f}\")  # 1/p = 50\n```\n\n#### 常見陷阱與注意事項\n- **Poisson 近似**：當 n 大、p 小時，Binomial ≈ Poisson\n- **scipy.stats.geom**：定義可能與教科書不同，確認起始值\n- **過度離散**：實務數據可能比 Poisson 更分散\n\n#### 實務應用場景\n- 計算 loan pool 的預期損失次數\n- 操作風險的損失頻率模型\n- 信用組合的違約數量模擬\n\n#### 與其他章節的關聯\n離散分佈用於 Ch10-Ch11 的二項樹選擇權定價。\n\n---\n\n### 8.5 連續型隨機變數的機率分佈\n\n#### 概念定義\n常見連續分佈：\n- **Uniform**：[a, b] 區間等機率\n- **Exponential**：事件間隔時間\n- **Beta**：描述機率本身的分佈\n- **Gamma**：等待 k 次事件的時間\n\n#### 財金理論背景\n- **Uniform**：蒙地卡羅的 CDF 反函數法\n- **Exponential**：信用違約的存活時間模型\n- **Beta**：Loss Given Default (LGD) 的分佈\n- **Gamma**：多次損失的總等待時間\n\n#### 數學公式或模型\n指數分佈（$\\lambda$ = 事件率）：\n$$\nf(x) = \\lambda e^{-\\lambda x}, \\quad x \\ge 0\n$$\n\n期望值 = $1/\\lambda$（平均等待時間）\n\n#### Python 實現邏輯\n```python\nfrom scipy import stats\nimport numpy as np\n\n# Uniform：[0, 1] 均勻分佈\nuniform_rv = stats.uniform(0, 1)\nsamples = uniform_rv.rvs(10000)\n\n# Exponential：平均 5 年發生一次\nrate = 1/5  # lambda = 0.2\nexp_rv = stats.expon(scale=5)  # scale = 1/lambda\nprint(f\"3 年內違約機率: {exp_rv.cdf(3):.4f}\")\n\n# Beta：LGD 的分佈（集中在 0.3-0.5）\na, b = 2, 5  # 形狀參數\nbeta_rv = stats.beta(a, b)\nprint(f\"LGD 期望值: {beta_rv.mean():.2f}\")  # a/(a+b)\n\n# Gamma：等待 3 次事件的時間\nshape, scale = 3, 2  # k=3, theta=2\ngamma_rv = stats.gamma(shape, scale=scale)\n```\n\n#### 常見陷阱與注意事項\n- **參數化差異**：Exponential 有些用 rate，有些用 scale\n- **Beta 範圍**：預設 [0, 1]，需線性變換到其他範圍\n- **Gamma 特例**：當 shape=1 時退化為 Exponential\n\n#### 實務應用場景\n- 模擬違約時間（信用調整估值 CVA）\n- 建模回收率的不確定性\n- 蒙地卡羅的均勻隨機數生成\n\n#### 與其他章節的關聯\nUniform 分佈是 Ch10-Ch11 蒙地卡羅模擬的基礎（逆變換法）。\n\n---\n\n### 8.6 正態分佈 (Normal) 與對數正態分佈應用\n\n#### 概念定義\n- **正態分佈**：鐘形曲線，完全由均值 $\\mu$ 和標準差 $\\sigma$ 決定\n- **對數正態分佈**：若 $\\ln(X) \\sim N(\\mu, \\sigma^2)$，則 $X$ 服從對數正態\n\n#### 財金理論背景\n金融模型的核心假設：\n- **報酬率**常假設正態分佈（VaR 計算）\n- **價格**因不能為負，假設對數正態（Black-Scholes）\n- **68-95-99.7 法則**：標準差範圍的機率\n\n#### 數學公式或模型\n標準正態 $Z \\sim N(0, 1)$：\n$$\nP(-1.96 < Z < 1.96) = 95\\%\n$$\n\nVaR 計算：\n$$\nVaR_{95\\%} = -\\mu + 1.645 \\times \\sigma\n$$\n\n#### Python 實現邏輯\n```python\nfrom scipy import stats\nimport numpy as np\n\n# 標準正態\nz = stats.norm(0, 1)\nprint(f\"95% VaR z-score: {z.ppf(0.05):.4f}\")  # -1.645\n\n# 資產報酬率\nmu_daily = 0.0005  # 0.05%\nsigma_daily = 0.02  # 2%\nnorm_rv = stats.norm(mu_daily, sigma_daily)\n\n# VaR 計算\nVaR_95 = -norm_rv.ppf(0.05)\nprint(f\"日 VaR 95%: {VaR_95:.4%}\")\n\n# 對數正態：股價模擬\nS0 = 100\nT = 1\nn_sims = 10000\nmu_annual = 0.10\nsigma_annual = 0.20\n\n# GBM 模擬\nZ = np.random.randn(n_sims)\nS_T = S0 * np.exp((mu_annual - 0.5*sigma_annual**2)*T + sigma_annual*np.sqrt(T)*Z)\n\n# 對數正態分佈\nlognorm_rv = stats.lognorm(s=sigma_annual*np.sqrt(T), \n                            scale=S0*np.exp((mu_annual-0.5*sigma_annual**2)*T))\n```\n\n#### 常見陷阱與注意事項\n- **肥尾問題**：實際報酬率的尾部比正態更厚\n- **對數正態參數**：scipy 的參數化與直覺不同，需小心\n- **年化轉換**：$\\sigma_{annual} = \\sigma_{daily} \\times \\sqrt{252}$\n\n#### 實務應用場景\n- 參數化 VaR 計算\n- Black-Scholes 選擇權定價\n- 蒙地卡羅價格路徑生成\n\n#### 與其他章節的關聯\n正態分佈是 Ch9 CLT 的極限分佈，對數正態是 Ch10-Ch11 BS 定價的核心假設。"
      }
    },
    "examples": [
      {
        "id": "ex1",
        "title": "8.1 B1_Ch8_1.py",
        "filename": "B1_Ch8_1.py",
        "code": "# B1_Ch8_1.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport random\nimport pandas as pd\n\n# total trial number\ntrials_total = 1000\n# number of outcome 3\noutcome_freq = 0 \n# define seed random number generator\nrandom.seed(1)\n# generate random integer in [1,6]\noutcomes=pd.Series([], dtype=int)\nfor _ in range (trials_total):\n    outcome = random.randint(1,6)\n    if outcome == 3:\n        outcome_freq = outcome_freq + 1\nprint('Probability of outcome 3: ', outcome_freq/trials_total)\n"
      },
      {
        "id": "ex2",
        "title": "8.2 B1_Ch8_2.py",
        "filename": "B1_Ch8_2.py",
        "code": "# B1_Ch8_2.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport random\n   \ntrials = 1000 # total number of simulations/trials\n \nwins_stick = 0  # number of wins if stick to the door picked initially\nwins_switch = 0 # number of wins if switch the door \n\nrandom.seed(1) \n\nfor _ in range(trials):\n    # 0: door with goat behind\n    # 1: door with car behind\n    doors = [1,0,0]           # one car and two goats\n    random.shuffle(doors)     # shuffling doors randomly\n \n    initial_pick = random.randrange(3) # picking a random door\n \n    door_initial_pick = doors[initial_pick] # storing initially picked door \n \n    del(doors[initial_pick]) # remaining doors (excluding initial pick)\n \n    counter = 0\n    for door in doors: \n        if door == 0:\n            del(doors[counter]) # deleting a door if a goat behind: door == 0\n            break\n        counter+=1\n \n    if door_initial_pick == 1: # wins_stick adds 1 if initial pick is 1 (goat)\n        wins_stick+=1\n \n    if doors[0] == 1: # wins_switch adds 1 if it is goat after switch\n        wins_switch+=1\n \nprint(\"Probablity of Stay to Win =\", wins_stick/trials)\nprint(\"Probablity of Switch to Win = \", wins_switch/trials)"
      },
      {
        "id": "ex3",
        "title": "8.3 B1_Ch8_3.py",
        "filename": "B1_Ch8_3.py",
        "code": "# B1_Ch8_3.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\n# calculate the probability of Monty Hall problem\n\n# function of Bayes theorem\ndef bayes_theorem(p_x, p_y_given_x, p_y):\n    p_x_given_y = p_x * (p_y_given_x / p_y)\n    return p_x_given_y\n \n# P(CarA) P(CarB) P(CarC)\np_a = 1/3\np_b = 1/3\np_c = 1/3\n\n# P(B|CarA) P(B|CarB) P(B|CarC)\np_b_given_a = 1/2\np_b_given_b = 0\np_b_given_c = 1\n\n# calculate P(B)\np_b = p_b_given_a*p_a + p_b_given_b*p_b + p_b_given_c*p_c\n\n# calculate P(A|B)\np_a_given_b = bayes_theorem(p_a, p_b_given_a, p_b)\n\n# calculate P(C|B)\np_c_given_b = bayes_theorem(p_c, p_b_given_c, p_b)\n\n# summary\nprint('Probability of Stay to Win : P(A|B) = %.3f%%' % (p_a_given_b * 100))\nprint('Probability of Switch to Win : P(C|B) = %.3f%%' % (p_c_given_b * 100))"
      },
      {
        "id": "ex4",
        "title": "8.4 B1_Ch8_4.py",
        "filename": "B1_Ch8_4.py",
        "code": "# B1_Ch8_4.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\n# B1_CH8_4_A.py\n\nimport random\nimport pandas as pd\n\n# define seed random number generator\nrandom.seed(1)\n# generate random integer in [1,6]\noutcomes=pd.Series([], dtype=int)\nfor _ in range (10):\n    outcome = random.randint(1,6)\n    print(outcome)\n    outcomes[len(outcomes)] = outcome\n\n\n\n# B1_CH8_4_B.py\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nplt.figure(figsize=(14, 3))\ntoss = ('1st','2nd','3rd','4th','5th','6th','7th','8th','9th','10th')\n# bar graph\nplt.subplot(131)\nplt.xticks(np.arange(10), toss)\nplt.bar(np.arange(10), outcomes) \n# scatter graph\nplt.subplot(132)\nplt.scatter(np.arange(10), outcomes)\nplt.xticks(np.arange(10), toss)\n# line graph\nplt.subplot(133)\nplt.plot(outcomes)\nplt.xticks(np.arange(10), toss)\n# graph title\nplt.suptitle('Outcome of 10 Tosses')\nplt.show()\n"
      },
      {
        "id": "ex5",
        "title": "8.5 B1_Ch8_5.py",
        "filename": "B1_Ch8_5.py",
        "code": "# B1_Ch8_5.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport pandas as pd\nimport matplotlib.ticker as mticker\nimport matplotlib.pyplot as plt\n\nf = pd.Series()\nF = pd.Series()\nF.at[0] = 0.0\nfor x in range(1, 7):\n    f.at[x]= 1/6\n    F.at[x] = F.at[x-1] + f[x]  \n\nfig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, figsize=(14, 5))\n# set up positions and labels for y ticks\npositions = [1/6, 2/6, 3/6, 4/6, 5/6, 1] \nlabels = ['1/6', '2/6', '3/6', '4/6', '5/6', '1']    \n\n# PDF figure\nax1_xticks = range(1,7)\n\nax1.plot(ax1_xticks, f, 'bo')   \nax1.vlines(ax1_xticks, 0, f, color='blue')\n\nax1.set_xlabel('x')\nax1.set_ylabel('f(x)')\nax1.set_ylim(0.0, 1.0)\n\nax1.yaxis.set_major_locator(mticker.FixedLocator(positions))\nax1.yaxis.set_major_formatter(plt.FixedFormatter(labels))\nax1.set_title('PMF')\n\n# CDF figure\nax2_xticks = range(0,8)\n\nax2.hlines(y=F, xmin=ax2_xticks[:-1], xmax=ax2_xticks[1:], color='red', zorder=1)\nax2.vlines(x=ax2_xticks[1:-1], ymin=F[:-1], ymax=F[1:], color='red', linestyle='dashed', zorder=1)\n\nax2.scatter(ax2_xticks[1:-1], F[1:], color='red', s=20, zorder=2)\nax2.scatter(ax2_xticks[1:-1], F[:-1], color='white', s=20, zorder=2, edgecolor='red')\n\nax2.set_xlabel('x')\nax2.set_ylabel('F(x)')\n\nax2.yaxis.set_major_locator(mticker.FixedLocator(positions))\nax2.yaxis.set_major_formatter(plt.FixedFormatter(labels))\nax2.set_title('CDF')"
      },
      {
        "id": "ex6",
        "title": "8.6 B1_Ch8_6.py",
        "filename": "B1_Ch8_6.py",
        "code": "# B1_Ch8_6.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nfrom scipy.stats import randint \nimport numpy as np\nimport matplotlib.pyplot as plt\n\nfig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, figsize=(14, 5))\n\nlow, high = 1, 7\nmean, var, skew, kurt = randint.stats(low, high, moments='mvsk')\n\nx = np.arange(low, high)\n\n# plot from a \"frozen\" object (holding the given parameters fixed) of discrete uniform random variable\nrv = randint(low, high)\nax1.plot(x, rv.pmf(x), 'ro', label='frozen PMF')\nax1.set_xlabel('x')\nax1.set_ylabel('p(x)')\nax1.set_title('PMF--frozen object')\nax1.spines['right'].set_visible(False)\nax1.spines['top'].set_visible(False)\nax1.yaxis.set_ticks_position('left')\nax1.xaxis.set_ticks_position('bottom')\n\n# plot from random variates\nax2.plot(x, randint.pmf(x, low, high), 'bo', label='randint PMF')\nax2.set_xlabel('x')\nax2.set_ylabel('p(x)')\nax2.set_title('PMF--randint')\nax2.spines['right'].set_visible(False)\nax2.spines['top'].set_visible(False)\nax2.yaxis.set_ticks_position('left')\nax2.xaxis.set_ticks_position('bottom')"
      },
      {
        "id": "ex7",
        "title": "8.7 B1_Ch8_7.py",
        "filename": "B1_Ch8_7.py",
        "code": "# B1_Ch8_7.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nfrom scipy.stats import bernoulli  \nimport numpy as np  \nimport matplotlib.pyplot as plt  \n\np = 0.5\nmean, var, skew, kurt = bernoulli.stats(p, moments='mvsk')\nprint('Expectation, Variance, Skewness, Kurtosis: ', mean, var, skew, kurt)\n\nx = np.linspace(0, 1, 6)     \nplt.plot(x, bernoulli.pmf(x, p), '*') \nplt.title('PMF--Bernoulli Distribution (p=0.5)')\nplt.xlabel('x')\nplt.ylabel('P(x)')\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.gca().yaxis.set_ticks_position('left')\nplt.gca().xaxis.set_ticks_position('bottom')"
      },
      {
        "id": "ex8",
        "title": "8.8 B1_Ch8_8.py",
        "filename": "B1_Ch8_8.py",
        "code": "# B1_Ch8_8.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nfrom scipy.stats import binom\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nn = 250\np = 0.6\n\nmean,var,skew,kurt = binom.stats(n,p,moments='mvsk')\nprint('Expectation, Variance, Skewness, Kurtosis: ', mean, var, np.around(skew,4), np.around(kurt,4))\n\nx = np.arange(0, 251)\n# scatter graph\nplt.plot(x, binom.pmf(x, n, p),'o')\n\nplt.title('Binomial Distribution (n=250, p=0.6)')\nplt.xlabel('Number of Stock Price Increase')\nplt.ylabel('Probability of Stock Price Increase')\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.gca().yaxis.set_ticks_position('left')\nplt.gca().xaxis.set_ticks_position('bottom')"
      },
      {
        "id": "ex9",
        "title": "8.9 B1_Ch8_9.py",
        "filename": "B1_Ch8_9.py",
        "code": "# B1_Ch8_9.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nfrom scipy.stats import geom\nimport matplotlib.pyplot as plt\nimport numpy as np\n\np = 0.5\n\nmean,var,skew,kurt = geom.stats(p,moments='mvsk')\nprint('Expectation, Variance, Skewness, Kurtosis: ', mean, var, skew, kurt)\n\nx = np.arange(geom.ppf(0.01, p), geom.ppf(0.99, p))\n\nplt.plot(x, geom.pmf(x, p),'o')\nplt.title('Geometric Distribution (p=0.5)')\nplt.xlabel('x')\nplt.ylabel('Probability')\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.gca().yaxis.set_ticks_position('left')\nplt.gca().xaxis.set_ticks_position('bottom')"
      },
      {
        "id": "ex10",
        "title": "8.10 B1_Ch8_10.py",
        "filename": "B1_Ch8_10.py",
        "code": "# B1_Ch8_10.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nfrom scipy.stats import poisson\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nlamb = 2\nmean,var,skew,kurt = poisson.stats(lamb, moments='mvsk')\n\nx = np.arange(0, 15)\n\nplt.plot(x, poisson.pmf(x, lamb), 'ro', label=r'$\\mathit{\\lambda}=%i$' % lamb)\nplt.title('Poisson Distribution'+r' ($\\mathit{\\lambda}=%i$)' % lamb)\nplt.xlabel('x')\nplt.ylabel('Probability')\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.gca().yaxis.set_ticks_position('left')\nplt.gca().xaxis.set_ticks_position('bottom')"
      },
      {
        "id": "ex11",
        "title": "8.11 B1_Ch8_11.py",
        "filename": "B1_Ch8_11.py",
        "code": "# B1_Ch8_11.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nfrom scipy.stats import uniform\nimport numpy as np\nimport seaborn as sns\n\nmean,var,skew,kurt = uniform.stats(moments='mvsk')\nprint('Expectation, Variance, Skewness, Kurtosis: ', mean, np.around(var,2), skew, kurt)\n\nx = np.linspace(-0.5, 1.5, 1000)\nax = sns.lineplot(x=x, y=uniform.pdf(x), color='dodgerblue', label='PDF')\nax.fill_between(x,uniform.pdf(x), color='lightblue', alpha=0.5)\n\nax = sns.lineplot(x=x, y=uniform.cdf(x), color='red', label='CDF')\n\nax.set_title('Continuous Uniform Distribution')\nax.set_xlabel('x')\nax.set_ylabel('Probability')\n\nax.spines['right'].set_visible(False)\nax.spines['top'].set_visible(False)\nax.yaxis.set_ticks_position('left')\nax.xaxis.set_ticks_position('bottom')"
      },
      {
        "id": "ex12",
        "title": "8.12 B1_Ch8_12.py",
        "filename": "B1_Ch8_12.py",
        "code": "# B1_Ch8_12.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nfrom scipy.stats import expon\nimport numpy as np\nimport seaborn as sns\n\nlam = 6\nloc = 0\nscale = 1.0/lam\n\nmean,var,skew,kurt = expon.stats(loc, scale, moments='mvsk')\nprint('Expectation, Variance, Skewness, Kurtosis: ', np.around(mean,2), np.around(var,2), skew, kurt)\n\nx = np.linspace(0,2,1000)\nax = sns.lineplot(x=x, y=expon.pdf(x, loc, scale), color='dodgerblue', label='PDF')\nax.fill_between(x,expon.pdf(x, loc, scale), color='lightblue', alpha=0.5)\n\nax = sns.lineplot(x=x, y=expon.cdf(x, loc, scale), color='red', label='CDF')\n\nax.set_title('Exponential Distribution -- $\\lambda=$' + str(lam))\nax.set_xlabel('x')\nax.set_ylabel('Probability')\n\nax.spines['right'].set_visible(False)\nax.spines['top'].set_visible(False)\nax.yaxis.set_ticks_position('left')\nax.xaxis.set_ticks_position('bottom')"
      },
      {
        "id": "ex13",
        "title": "8.13 B1_Ch8_13.py",
        "filename": "B1_Ch8_13.py",
        "code": "# B1_Ch8_13.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nfrom scipy.stats import beta \nimport numpy as np \nimport seaborn as sns\n\nx = np.linspace(0, 1.0, 100)   \n# varying alpha and beta \nbeta1 = beta.pdf(x, 0.5, 0.5) \nbeta2 = beta.pdf(x, 2.0, 2.0) \nbeta3 = beta.pdf(x, 1.0, 5.0)\nbeta4 = beta.pdf(x, 5.0, 1.0) \nbeta5 = beta.pdf(x, 5.0, 5.0)\nax = sns.lineplot(x=x, y=beta1, label=r'$\\alpha=0.5, \\beta=0.5$')\nax = sns.lineplot(x=x, y=beta2, label=r'$\\alpha=2.0, \\beta=2.0$')\nax = sns.lineplot(x=x, y=beta3, label=r'$\\alpha=1.0, \\beta=5.0$')\nax = sns.lineplot(x=x, y=beta4, label=r'$\\alpha=5.0, \\beta=1.0$')\nax = sns.lineplot(x=x, y=beta5, label=r'$\\alpha=5.0, \\beta=5.0$')\n\nax.set_title('Beta Distribution')\nax.set_xlabel('x')\nax.set_ylabel('PDF')\nax.spines['right'].set_visible(False)\nax.spines['top'].set_visible(False)\nax.yaxis.set_ticks_position('left')\nax.xaxis.set_ticks_position('bottom')"
      },
      {
        "id": "ex14",
        "title": "8.14 B1_Ch8_14.py",
        "filename": "B1_Ch8_14.py",
        "code": "# B1_Ch8_14.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nfrom scipy.stats import gamma \nimport numpy as np \nimport seaborn as sns\n\nx = np.linspace(0, 10.0, 100)   \n# varying alpha and beta \ngamma1 = gamma.pdf(x, 1.0, 0.0, 1.0) \ngamma2 = gamma.pdf(x, 2.0, 0.0, 1/0.5) \n\nax = sns.lineplot(x=x, y=gamma1, label=r'$\\alpha=1.0, \\beta=1.0$')\nax = sns.lineplot(x=x, y=gamma2, label=r'$\\alpha=2.0, \\beta=0.5$')\n\nax.set_title('Gamma Distribution')\nax.set_xlabel('x')\nax.set_ylabel('PDF')\nax.spines['right'].set_visible(False)\nax.spines['top'].set_visible(False)\nax.yaxis.set_ticks_position('left')\nax.xaxis.set_ticks_position('bottom')"
      },
      {
        "id": "ex15",
        "title": "8.15 B1_Ch8_15.py",
        "filename": "B1_Ch8_15.py",
        "code": "# B1_Ch8_15.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nfrom scipy.stats import norm\nimport seaborn as sns\nimport numpy as np\n\nmean,var,skew,kurt = norm.stats(moments='mvsk')\nprint('Expectation, Variance, Skewness, Kurtosis: ', mean, var, skew, kurt)\n\nx = np.linspace(-4,4,1000)\nax = sns.lineplot(x=x, y=norm.pdf(x), color='dodgerblue')\nax.fill_between(x,norm.pdf(x), color='lightblue', alpha=0.2)\n\nax.set_title('Normal Distribution')\nax.set_xlabel('x')\nax.set_ylabel('PDF')\nax.spines['right'].set_visible(False)\nax.spines['top'].set_visible(False)\nax.yaxis.set_ticks_position('left')\nax.xaxis.set_ticks_position('bottom')"
      },
      {
        "id": "ex16",
        "title": "8.16 B1_Ch8_16.py",
        "filename": "B1_Ch8_16.py",
        "code": "# B1_Ch8_16.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nfrom scipy.integrate import quad\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import norm\nimport seaborn as sns\n\n# integrate pdf to 68%, 95%, and 99.7%\npercent68, _ = quad(norm.pdf, -1, 1, limit = 1000)\npercent95, _ = quad(norm.pdf, -2, 2, limit = 1000)\npercent99, _ = quad(norm.pdf, -3, 3, limit = 1000)\n\n# plot normal profile\nx = np.linspace(-3.5, 3.5)\ny = norm.pdf(x)\n\nfig, ax = plt.subplots(figsize=(14, 8))\nax.plot(x, y, 'k', linewidth=.5)\nax.set_ylim(ymin=0, ymax=0.53)\nax = sns.lineplot(x=x, y=y, color='#3C9DFF')\nax.vlines(0, 0, norm.pdf(0), color='coral')\n\n# 68% region\na, b = -1, 1 \n\n# make shaded region\nix = np.linspace(-1, 1)\niy = norm.pdf(ix)\nax = sns.lineplot(x=ix, y=iy, color='#3C9DFF')\nax.fill_between(ix,norm.pdf(ix), color='#DBEEF4', alpha=0.5)\n\ntextheight = 0.41\nax.text(0.0, textheight+0.01, r'{0:.2f}%'.format((percent68)*100),\n         horizontalalignment='center', fontsize=18);\n\nax.annotate(r'',\n            xy=(-1, textheight), xycoords='data',\n            xytext=(1, textheight), textcoords='data',\n            arrowprops=dict(arrowstyle=\"<|-|>\",\n                            connectionstyle=\"arc3\",\n                            mutation_scale=20,\n                            fc=\"w\")\n            );\nax.vlines(a, 0, textheight+0.025, color='coral')\nax.vlines(b, 0, textheight+0.025, color='coral')\n\n# 95% region\na, b = 1, 2 \n# make shaded region\nix = np.linspace(1, 2)\niy = norm.pdf(ix)\nax.fill_between(ix,norm.pdf(ix), color='#DBEEF4', alpha=0.5)\n\na, b = -2, -1\n# make shaded region\nix = np.linspace(-2, -1)\niy = norm.pdf(ix)\nax.fill_between(ix,norm.pdf(ix), color='#DBEEF4', alpha=0.5)\n\ntextheight = 0.45\nax.text(0.0, textheight+0.01, r'{0:.2f}%'.format((percent95)*100),\n         horizontalalignment='center', fontsize=18);\n\nax.annotate(r'',\n            xy=(-2, textheight), xycoords='data',\n            xytext=(2, textheight), textcoords='data',\n            arrowprops=dict(arrowstyle=\"<|-|>\",\n                            connectionstyle=\"arc3\",\n                            mutation_scale=20,\n                            fc=\"w\")\n            );\nax.vlines(-2, 0, textheight+0.025, color='coral')\nax.vlines(2, 0, textheight+0.025, color='coral')\n\n# 95% region\na, b = 2, 3\n# make shaded region\nix = np.linspace(2, 3)\niy = norm.pdf(ix)\nax.fill_between(ix,norm.pdf(ix), color='#DBEEF4', alpha=0.5)\n\na, b = -3, -2 \n# make shaded region\nix = np.linspace(-3, -2)\niy = norm.pdf(ix)\nax.fill_between(ix,norm.pdf(ix), color='#DBEEF4', alpha=0.5)\n\ntextheight = 0.49\nax.text(0.0, textheight+0.01, r'{0:.2f}%'.format((percent99)*100),\n         horizontalalignment='center', fontsize=18);\n\nax.annotate(r'',\n            xy=(-3, textheight), xycoords='data',\n            xytext=(3, textheight), textcoords='data',\n            arrowprops=dict(arrowstyle=\"<|-|>\",\n                            connectionstyle=\"arc3\",\n                            mutation_scale=20,\n                            fc=\"w\")\n            );\n\nax.vlines(-3, 0, textheight+0.025, color='coral')\nax.vlines(3, 0, textheight+0.025, color='coral')\n\n# title, labels and ticks\nax.set_title(r'68-95-99.7 Rule', fontsize = 24)\nax.set_ylabel(r'Probability Density', fontsize = 18)\n\nxTickLabels = ['',\n               r'$\\mu - 3\\sigma$',\n               r'$\\mu - 2\\sigma$',\n               r'$\\mu - \\sigma$',\n               r'$\\mu$',\n               r'$\\mu + \\sigma$',\n               r'$\\mu + 2\\sigma$',\n               r'$\\mu + 3\\sigma$']\n\nax.set_xticklabels(xTickLabels, fontsize = 16)\n\nax.spines['right'].set_visible(False)\nax.spines['top'].set_visible(False)\nax.yaxis.set_ticks_position('left')\nax.xaxis.set_ticks_position('bottom')\n"
      },
      {
        "id": "ex17",
        "title": "8.17 B1_Ch8_17.py",
        "filename": "B1_Ch8_17.py",
        "code": "# B1_Ch8_17.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nfrom scipy.stats import lognorm\nimport numpy as np\nimport seaborn as sns\n\n# shape parameter\ns = 0.9\n\nmean,var,skew,kurt = lognorm.stats(s, moments='mvsk')\nprint('Expectation, Variance, Skewness, Kurtosis: ', mean, var, skew, kurt)\n\nx = np.linspace(0,4,1000)\nax = sns.lineplot(x=x, y=lognorm.pdf(x, s), color='dodgerblue', label='PDF')\nax.fill_between(x, lognorm.pdf(x, s), color='lightblue', alpha=0.5)\nax = sns.lineplot(x=x, y=lognorm.cdf(x, s), color='red', label='CDF')\n\nax.set_title('Lognormal Distribution')\nax.set_xlabel('x')\nax.set_ylabel('Probability')\nax.spines['right'].set_visible(False)\nax.spines['top'].set_visible(False)\nax.yaxis.set_ticks_position('left')\nax.xaxis.set_ticks_position('bottom')\n"
      }
    ]
  },
  {
    "id": "b1_ch9",
    "title": "第9章：機率與統計 II",
    "number": 9,
    "content": {
      "intro": {
        "title": "第 9 章：機率與統計 II - 詳解",
        "roadmap": {
          "guide": "",
          "objectives": "建立統計推論與驗證的科學方法。本章聚焦於中心極限定理 (CLT)、區間估計（置信區間）與假設檢驗，旨在教會學習者如何科學地檢驗策略是否具有「顯著性」而非偶然。",
          "topics": "*   9.1 隨機變數數位特徵 (Moment, Skewness, Kurtosis)\n*   9.2 整體與樣本概念\n*   9.3 抽樣分佈 (Sampling Distribution)\n*   9.4 大數定律與中心極限定理驗證\n*   9.5 參數估計 (Parameter Estimation)\n*   9.6 假設檢定 (Hypothesis Testing) 流程\n*   9.7 置信區間、p-值與結論解釋"
        },
        "value": {
          "practical": "*   **實務場景**：對交易策略進行回測後，檢驗其索提諾比率 (Sortino Ratio) 的統計顯著性。\n*   **考試重點**：理解第一類錯誤（棄真）與第二類錯誤（存偽）在風險限額設定中的影響。",
          "theory": "*   **中心極限定理 (CLT) 的實踐**：不論資產原始分布如何，大量樣本均值的分布趨於正態。這是蒙地卡羅模擬能有效收斂的數學根據。\n*   **假設檢驗與策略偽顯著**：金融市場充滿噪聲，理解 p 值與顯著水平 $\\alpha$，避免將隨機的獲利誤判為具有預測能力。",
          "further_reading": "*   非參數檢驗：當數據分布極度不對稱時的替代方案。"
        },
        "implementation": {
          "python": "*   **抽樣實驗**：利用 Python 進行上千次的重複抽樣，直觀觀察 CLT 的收斂過程。\n*   **統計檢驗工具**：使用 `scipy.stats` 進行一鍵式的 t 檢驗或 z 檢驗。",
          "logic": "*   `scipy.stats.ttest_1samp()`：檢驗策略平均收益是否顯著大於零。\n*   `scipy.stats.norm.interval()`：計算波動率背景下的置信區間。",
          "scenarios": "| 腳本名稱 | 核心使命 |\n| :--- | :--- |\n| **B1_Ch9_1.py** | 實作基礎描述性統計：計算均值、中位數、眾數與極差。 |\n| **B1_Ch9_2.py** | 計算樣本偏差 (Variance) 與標準差，衡量資產波動率。 |\n| **B1_Ch9_3.py** | 演示偏度 (Skewness) 與峰度 (Kurtosis) 的計算，分析收益分佈的肥尾現象。 |\n| **B1_Ch9_4.py** | 實作樣本共變異數矩陣與相關係數矩陣的計算。 |\n| **B1_Ch9_5.py** | 演示中央極限定理 (CLT) 的數值模擬與視覺化驗證。 |\n| **B1_Ch9_6.py** | 計算置信區間 (Confidence Interval)，預估參數估計的精確範圍。 |\n| **B1_Ch9_7.py** | 實作單樣本 t 檢定，驗證策略回報是否顯著異於零。 |\n| **B1_Ch9_8.py** | 實作雙樣本 t 檢定，對比兩組不同風險模型的效果差異。 |\n| **B1_Ch9_9.py** | 演示卡方檢定 (Chi-Square) 的擬合優度分析。 |"
        },
        "body": "### 9.1 隨機變數數位特徵 (Moment, Skewness, Kurtosis)\n\n#### 概念定義\n**矩 (Moment)** 是描述分佈形狀的關鍵統計量：\n- **一階矩：期望值 (Mean)**：中心位置\n- **二階矩：變異數 (Variance)**：離散程度\n- **三階矩：偏度 (Skewness)**：不對稱性\n- **四階矩：峰度 (Kurtosis)**：厚尾程度\n\n#### 財金理論背景\n風險管理需要理解報酬率的完整分佈特徵：\n- **負偏度**：暴跌比暴漲更常見（股票市場特徵）\n- **正峰度（厚尾）**：極端事件機率高於正態分佈預測\n- **風險量化**：VaR 和 ES 依賴尾部特徵\n\n#### 數學公式或模型\n偏度：\n$$\n\\text{Skewness} = \\frac{E[(X-\\mu)^3]}{\\sigma^3}\n$$\n\n超額峰度：\n$$\n\\text{Excess Kurtosis} = \\frac{E[(X-\\mu)^4]}{\\sigma^4} - 3\n$$\n\n正態分佈的偏度=0，超額峰度=0。\n\n#### Python 實現邏輯\n```python\nimport numpy as np\nfrom scipy import stats\n\nreturns = np.array([...])  # 報酬率數據\n\n# 基本統計量\nmean = np.mean(returns)\nvariance = np.var(returns, ddof=1)  # 樣本變異數\nstd = np.std(returns, ddof=1)\n\n# 偏度與峰度\nskewness = stats.skew(returns)\nkurtosis = stats.kurtosis(returns)  # 預設是超額峰度\n\nprint(f\"均值: {mean:.4f}\")\nprint(f\"標準差: {std:.4f}\")\nprint(f\"偏度: {skewness:.4f}\")  # 負值 = 左偏\nprint(f\"超額峰度: {kurtosis:.4f}\")  # 正值 = 厚尾\n\n# Jarque-Bera 正態性檢定\njb_stat, jb_pvalue = stats.jarque_bera(returns)\nprint(f\"JB p-value: {jb_pvalue:.4f}\")  # 小於 0.05 則拒絕正態假設\n```\n\n#### 常見陷阱與注意事項\n- **樣本 vs 母體**：使用 `ddof=1` 計算無偏估計\n- **峰度定義**：有些套件返回\"excess kurtosis\"，有些返回\"kurtosis\"\n- **小樣本偏差**：樣本偏度和峰度估計在小樣本下偏差大\n\n#### 實務應用場景\n- 識別報酬率分佈的非正態特徵\n- 選擇適合的風險模型（正態 vs t 分佈）\n- 壓力測試情境的機率校準\n\n#### 與其他章節的關聯\n高階矩用於 Ch8 分佈選擇，峰度校正可改進 Ch10-Ch11 的 VaR 計算。\n\n---\n\n### 9.2 整體與樣本概念\n\n#### 概念定義\n統計推論的核心區分：\n- **母體 (Population)**：所有可能觀察的完整集合（通常無法觀察）\n- **樣本 (Sample)**：從母體中抽取的子集（實際可觀察）\n- **參數 vs 統計量**：母體參數（μ, σ）vs 樣本統計量（x̄, s）\n\n#### 財金理論背景\n金融分析只能觀察歷史數據（樣本），但要推斷未來行為（母體）：\n- 歷史波動率是σ的估計，不是真實值\n- 過去 5 年數據≠未來的完整分佈\n- 參數不確定性是模型風險的來源\n\n#### 數學公式或模型\n樣本均值是母體均值的無偏估計：\n$$\nE[\\bar{X}] = \\mu\n$$\n\n樣本標準差：\n$$\ns = \\sqrt{\\frac{1}{n-1}\\sum_{i=1}^{n}(x_i - \\bar{x})^2}\n$$\n\n#### Python 實現邏輯\n```python\nimport numpy as np\n\n# 假設這是我們的「母體」（實際中無法完全觀察）\npopulation = np.random.normal(0.05, 0.20, size=100000)\ntrue_mean = np.mean(population)\ntrue_std = np.std(population, ddof=0)  # 母體標準差\n\n# 抽取樣本\nsample_size = 250  # 約一年交易日\nsample = np.random.choice(population, size=sample_size, replace=False)\n\n# 樣本統計量\nsample_mean = np.mean(sample)\nsample_std = np.std(sample, ddof=1)  # 樣本標準差\n\nprint(f\"母體均值: {true_mean:.4f}, 樣本均值: {sample_mean:.4f}\")\nprint(f\"母體標準差: {true_std:.4f}, 樣本標準差: {sample_std:.4f}\")\n```\n\n#### 常見陷阱與注意事項\n- **ddof 參數**：母體用 `ddof=0`，樣本用 `ddof=1`\n- **抽樣偏誤**：金融數據常有存活偏誤（survivorship bias）\n- **時間相依性**：金融時間序列不是 i.i.d.\n\n#### 實務應用場景\n- 使用歷史數據估計波動率\n- 評估模型參數的估計誤差\n- 設計回測的樣本分割\n\n#### 與其他章節的關聯\n母體/樣本概念是 Ch9.5 參數估計和 Ch9.6 假設檢定的前提。\n\n---\n\n### 9.3 抽樣分佈 (Sampling Distribution)\n\n#### 概念定義\n**抽樣分佈**是統計量（如樣本均值）本身的機率分佈：\n- 每次抽樣得到不同的樣本均值 → 這些均值形成一個分佈\n- **標準誤 (Standard Error)**：樣本均值的標準差\n\n$$\nSE = \\frac{\\sigma}{\\sqrt{n}}\n$$\n\n#### 財金理論背景\n抽樣分佈解釋了估計的不確定性：\n- 基於更多數據的估計更精確（SE 下降）\n- 策略回測結果的隨機性可量化\n- 信賴度取決於樣本量\n\n#### 數學公式或模型\n樣本均值的抽樣分佈：\n$$\n\\bar{X} \\sim N\\left(\\mu, \\frac{\\sigma^2}{n}\\right)\n$$\n\n當σ未知時，使用 t 分佈：\n$$\n\\frac{\\bar{X} - \\mu}{s/\\sqrt{n}} \\sim t_{n-1}\n$$\n\n#### Python 實現邏輯\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# 模擬抽樣分佈\npopulation = np.random.exponential(scale=1.0, size=100000)  # 非正態母體\nsample_size = 50\nn_samples = 10000\n\nsample_means = [np.mean(np.random.choice(population, size=sample_size, replace=True)) \n                for _ in range(n_samples)]\n\n# 觀察抽樣分佈（趨於正態！）\nplt.hist(sample_means, bins=50, density=True, alpha=0.7)\nplt.xlabel('Sample Mean')\nplt.title('Sampling Distribution of Mean')\n\n# 標準誤\ntrue_se = np.std(population) / np.sqrt(sample_size)\nobserved_se = np.std(sample_means)\nprint(f\"理論 SE: {true_se:.4f}, 觀察 SE: {observed_se:.4f}\")\n```\n\n#### 常見陷阱與注意事項\n- **SE ≠ std**：標準誤是均值的誤差，不是數據的離散\n- **n 的效果**：標準誤與 √n 成反比，要減半誤差需 4 倍樣本\n- **相依樣本**：時間序列的有效樣本量可能小於實際筆數\n\n#### 實務應用場景\n- 計算 Sharpe Ratio 的置信區間\n- 評估策略 Alpha 估計的穩定性\n- 設計回測所需的最小樣本量\n\n#### 與其他章節的關聯\n抽樣分佈是 Ch9.6 假設檢定和 Ch9.7 置信區間的理論基礎。\n\n---\n\n### 9.4 大數定律與中心極限定理驗證\n\n#### 概念定義\n兩大基礎定理：\n- **大數法則 (LLN)**：樣本均值隨 n 增大趨近母體均值\n- **中心極限定理 (CLT)**：無論母體分佈為何，大樣本均值趨近正態分佈\n\n#### 財金理論背景\n- **LLN**：長期投資的理論依據，風險會被分\n\n散\n- **CLT**：解釋為何正態分佈在金融模型中如此重要\n- **蒙地卡羅模擬有效**的數學保證\n\n#### 數學公式或模型\n大數法則：\n$$\n\\bar{X}_n \\xrightarrow{P} \\mu \\quad \\text{as } n \\to \\infty\n$$\n\n中心極限定理：\n$$\n\\frac{\\bar{X}_n - \\mu}{\\sigma/\\sqrt{n}} \\xrightarrow{d} N(0, 1)\n$$\n\n#### Python 實現邏輯\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# LLN 示範\npopulation = np.random.exponential(1.0, 100000)  # 指數分佈\ntrue_mean = 1.0\n\nsample_sizes = range(10, 10000, 10)\nrunning_means = [np.mean(np.random.choice(population, n)) for n in sample_sizes]\n\nplt.plot(sample_sizes, running_means)\nplt.axhline(y=true_mean, color='r', linestyle='--')\nplt.xlabel('Sample Size')\nplt.ylabel('Sample Mean')\nplt.title('Law of Large Numbers')\n\n# CLT 示範\nsample_means_30 = [np.mean(np.random.exponential(1.0, 30)) for _ in range(10000)]\nsample_means_100 = [np.mean(np.random.exponential(1.0, 100)) for _ in range(10000)]\n\nfig, axes = plt.subplots(1, 2)\naxes[0].hist(sample_means_30, bins=50, density=True)\naxes[0].set_title('n=30')\naxes[1].hist(sample_means_100, bins=50, density=True)\naxes[1].set_title('n=100')  # 更加正態\n```\n\n#### 常見陷阱與注意事項\n- **CLT 需要有限變異數**：厚尾分佈（如 Cauchy）不滿足 CLT\n- **「足夠大」的 n**：對稱分佈 n≈30 可能足夠，偏態分佈需更多\n- **獨立性假設**：時間序列自相關會影響 CLT 收斂速度\n\n#### 實務應用場景\n- 蒙地卡羅模擬結果的收斂判斷\n- 長期投資策略的風險分散效果\n- VaR 模型使用正態假設的理論依據\n\n#### 與其他章節的關聯\nCLT 支持 Ch8 正態分佈的使用，LLN 保證 Ch10-Ch11 蒙地卡羅的收斂。\n\n---\n\n### 9.5 參數估計 (Parameter Estimation)\n\n#### 概念定義\n用樣本數據推估母體參數：\n- **點估計**：單一值估計（如 MLE, MOM）\n- **區間估計**：帶置信水平的區間\n- **估計量性質**：無偏性、有效性、一致性\n\n#### 財金理論背景\n風險模型需要估計多個參數：\n- 波動率 σ 的估計\n- 相關係數 ρ 的估計\n- GARCH 模型的 α, β 參數\n\n#### 數學公式或模型\n最大似然估計 (MLE)：\n$$\n\\hat{\\theta}_{MLE} = \\arg\\max_\\theta L(\\theta|x) = \\arg\\max_\\theta \\prod_{i=1}^n f(x_i|\\theta)\n$$\n\nFor Normal: $\\hat{\\mu} = \\bar{x}$, $\\hat{\\sigma}^2 = \\frac{1}{n}\\sum(x_i-\\bar{x})^2$\n\n#### Python 實現邏輯\n```python\nfrom scipy import stats\nfrom scipy.optimize import minimize\nimport numpy as np\n\ndata = np.random.normal(0.05, 0.20, 1000)\n\n# 矩方法估計\nmom_mu = np.mean(data)\nmom_sigma = np.std(data, ddof=1)\n\n# MLE 估計（使用 scipy）\nmle_params = stats.norm.fit(data)  # 返回 (mu, sigma)\nprint(f\"MLE: mu={mle_params[0]:.4f}, sigma={mle_params[1]:.4f}\")\n\n# 自定義 MLE\ndef neg_log_likelihood(params, data):\n    mu, sigma = params\n    return -np.sum(stats.norm.logpdf(data, mu, sigma))\n\nresult = minimize(neg_log_likelihood, x0=[0, 0.1], args=(data,), \n                  bounds=[(None, None), (0.001, None)])\nprint(f\"Custom MLE: {result.x}\")\n```\n\n#### 常見陷阱與注意事項\n- **MLE 偏差**：σ 的 MLE 估計有偏，需校正\n- **數值問題**：最佳化可能陷入局部最優\n- **模型誤設**：如果真實分佈不是假設的分佈，MLE 可能誤導\n\n#### 實務應用場景\n- 估計歷史波動率用於 VaR\n- 校準信用風險模型的違約機率\n- GARCH 模型參數估計\n\n#### 與其他章節的關聯\n參數估計用於 Ch10-Ch11 Black-Scholes 波動率輸入。\n\n---\n\n### 9.6 假設檢定 (Hypothesis Testing) 流程\n\n#### 概念定義\n科學決策的系統化流程：\n1. **建立假設**：$H_0$（虛無）vs $H_1$（對立）\n2. **選擇檢定統計量**\n3. **計算 p 值或臨界值**\n4. **做出結論**\n\n兩類錯誤：\n- **Type I**：誤判（拒絕真的 $H_0$），機率 = α\n- **Type II**：漏判（接受假的 $H_0$），機率 = β\n\n#### 財金理論背景\n避免過度擬合和偽發現：\n- 策略 Alpha 是否真的顯著異於零？\n- 新風險模型是否真的優於舊模型？\n- 市場行為是否發生結構性改變？\n\n#### 數學公式或模型\nt 檢定統計量：\n$$\nt = \\frac{\\bar{x} - \\mu_0}{s/\\sqrt{n}}\n$$\n\n決策：若 $|t| > t_{\\alpha/2, n-1}$ 則拒絕 $H_0$\n\n#### Python 實現邏輯\n```python\nfrom scipy import stats\nimport numpy as np\n\n# 策略回報是否顯著大於零？\nreturns = np.array([0.02, -0.01, 0.03, 0.015, ...])  # 日報酬率\n\n# 單樣本 t 檢定\nt_stat, p_value = stats.ttest_1samp(returns, 0)  # H0: mu = 0\nprint(f\"t = {t_stat:.4f}, p = {p_value:.4f}\")\n\n# 單尾檢定（策略是否大於零）\np_one_tail = p_value / 2 if t_stat > 0 else 1 - p_value / 2\nprint(f\"單尾 p = {p_one_tail:.4f}\")\n\n# 雙樣本 t 檢定（兩策略比較）\nreturns_A = np.array([...])\nreturns_B = np.array([...])\nt_stat, p_value = stats.ttest_ind(returns_A, returns_B)\nprint(f\"兩策略差異 p = {p_value:.4f}\")\n```\n\n#### 常見陷阱與注意事項\n- **p 值誤解**：p 值不是「$H_0$ 為真」的機率\n- **多重檢定**：測試多個策略需要 Bonferroni 校正\n- **效應量**：統計顯著不等於經濟顯著\n\n#### 實務應用場景\n- 策略 Alpha 的顯著性驗證\n- 風險因子的解釋力檢定\n- 市場效率的統計檢驗\n\n#### 與其他章節的關聯\n假設檢定用於驗證 Ch8-Ch9 分佈假設的適切性。\n\n---\n\n### 9.7 置信區間、p-值與結論解釋\n\n#### 概念定義\n- **置信區間 (CI)**：參數落入該區間的信心水準（如 95%）\n- **p-值**：在 $H_0$ 為真時，觀察到當前（或更極端）結果的機率\n- **經濟顯著 vs 統計顯著**：效應量的實際意義\n\n#### 財金理論背景\n決策需要量化不確定性：\n- Sharpe Ratio 的 95% CI 是多少？\n- VaR 回測的例外數是否在預期範圍？\n- Alpha 估計值即使顯著，是否足夠大？\n\n#### 數學公式或模型\n均值的 95% 置信區間：\n$$\nCI = \\bar{x} \\pm t_{\\alpha/2, n-1} \\times \\frac{s}{\\sqrt{n}}\n$$\n\n#### Python 實現邏輯\n```python\nfrom scipy import stats\nimport numpy as np\n\nreturns = np.array([...])  # 樣本數據\n\n# 均值的置信區間\nmean = np.mean(returns)\nse = stats.sem(returns)  # 標準誤\nci_95 = stats.t.interval(0.95, len(returns)-1, loc=mean, scale=se)\nprint(f\"95% CI: ({ci_95[0]:.4f}, {ci_95[1]:.4f})\")\n\n# Sharpe Ratio 的 Bootstrap CI\ndef sharpe_ratio(r):\n    return np.mean(r) / np.std(r, ddof=1) * np.sqrt(252)\n\nn_bootstrap = 10000\nboot_sr = [sharpe_ratio(np.random.choice(returns, len(returns), replace=True)) \n           for _ in range(n_bootstrap)]\nsr_ci = np.percentile(boot_sr, [2.5, 97.5])\nprint(f\"Sharpe Ratio 95% CI: ({sr_ci[0]:.2f}, {sr_ci[1]:.2f})\")\n\n# p 值解讀\nif p_value < 0.05:\n    print(\"p < 0.05: 統計顯著，但需評估經濟意義\")\nelse:\n    print(\"p >= 0.05: 無法拒絕 H0，可能樣本不足或效應太小\")\n```\n\n#### 常見陷阱與注意事項\n- **CI 的解讀**：是「過程」的 95% 準確，不是「這個區間」包含參數的機率\n- **Bootstrap 限制**：樣本量太小時 Bootstrap 可能不可靠\n- **顯著性門檻**：0.05 只是慣例，不是神聖數字\n\n#### 實務應用場景\n- 報告策略績效指標的不確定性\n- VaR 模型的回測驗證\n- 投資決策的風險量化\n\n#### 與其他章節的關聯\n置信區間和 p 值用於總結 Ch9 統計分析的結論可靠性。"
      }
    },
    "examples": [
      {
        "id": "ex1",
        "title": "9.1 B1_Ch9_1.py",
        "filename": "B1_Ch9_1.py",
        "code": "# B1_Ch9_1.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\n# B1_Ch9_1_A.py\nfrom pandas_datareader import data\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nstocks = ['FB', 'NFLX', 'AMZN', 'GLD', 'GE', 'NKE', 'FORD']\ndf = data.DataReader(stocks, 'yahoo', '2019-1-1', '2019-12-31')['Adj Close']\ndflog = np.log(df)\nstockreturn= dflog.pct_change()\nstockreturn = stockreturn[1:]\n\n# covariance and correlation\nstockcov = stockreturn.cov()\nstockcorr = stockreturn.corr()\npd.options.display.float_format = '${:,.6f}'.format\nprint(stockcov)\nprint(stockcorr)\n\n\n# B1_Ch9_1_B.py\n# generate heat map\nfrom  matplotlib.colors import LinearSegmentedColormap\nimport seaborn as sns\n\ncmap=LinearSegmentedColormap.from_list('rb',[\"r\", \"w\", \"b\"], N=256) \n\nsns.heatmap(stockreturn.corr(), cmap=cmap, vmax=1.0, vmin=-1.0)\nplt.yticks(rotation=0) \nplt.xticks(rotation=90) \n\n\n\n"
      },
      {
        "id": "ex2",
        "title": "9.2 B1_Ch9_2.py",
        "filename": "B1_Ch9_2.py",
        "code": "# B1_Ch9_2.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nfrom scipy.stats import chi2 \nimport numpy as np\nimport seaborn as sns\n\nlistn = [1, 5, 10, 30, 50]\nx = np.linspace(0, 70, 500)\nsns.set_palette('pastel')\n\nfor n in listn: \n    ax = sns.lineplot(x=x, y=chi2.pdf(x, n), label='n = '+str(n))\n    ax.fill_between(x, chi2.pdf(x, n), alpha=0.58)\n\nax.set_title('Chi-square Distribution')\nax.legend(frameon=False)\nax.set_ylim(0.0, 0.2)\nax.set_yticks([0.0, 0.1, 0.2])\nax.spines['right'].set_visible(False)\nax.spines['top'].set_visible(False)\nax.yaxis.set_ticks_position('left')\nax.xaxis.set_ticks_position('bottom')\n\nax.spines['left'].set_position('zero')\nax.spines['bottom'].set_position('zero')"
      },
      {
        "id": "ex3",
        "title": "9.3 B1_Ch9_3.py",
        "filename": "B1_Ch9_3.py",
        "code": "# B1_Ch9_3.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nfrom scipy.stats import t, norm \nimport matplotlib.pyplot as plt\nimport numpy as np\nimport seaborn as sns\n\nlistn = [1, 5, 10, 30, 50, 100]\nx = np.linspace(-6, 6, 1000)\n\nrows = 2\ncols = 3\nfig, ax = plt.subplots(rows, cols, figsize=(14,8))\nfign = 0\n\nfor i in range(0, rows):\n    for j in range(0, cols):\n        sns.lineplot(x=x, y=t.pdf(x, listn[fign]), label='t', ax=ax[i, j], color='b', alpha=0.58)\n        ax[i, j].fill_between(x, t.pdf(x, listn[fign]), alpha=0.58, color='lightblue')\n        sns.lineplot(x=x, y=norm.pdf(x, 0, 1), label='Std Norm', ax=ax[i, j], color='red')\n        ax[i, j].set_xticks([-4, 0, 4])\n        ax[i, j].set_xticklabels(['-4', '0', '4'])\n        ax[i, j].set_yticks([0.0, 0.4, 0.2])\n        ax[i, j].set_title(label= \"df = \" + str(listn[fign]))\n        fign+=1\n\nfig.suptitle('t Distribution')\n"
      },
      {
        "id": "ex4",
        "title": "9.4 B1_Ch9_4.py",
        "filename": "B1_Ch9_4.py",
        "code": "# B1_Ch9_4.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nfrom scipy.stats import f \nimport numpy as np\nimport seaborn as sns\n\nlistmn = [[5,10], [10,5], [50, 50], [100, 100]]\n\ncustomized_palette = [\"#3C9DFF\",\"#B7DEE8\", \"#0070C0\",\"#313695\"]\nsns.set_palette(customized_palette)\n\nx = np.linspace(0, 5, 1000)\nfor mn in listmn: \n    ax = sns.lineplot(x=x, y=f.pdf(x, mn[0], mn[1]), label='m='+str(mn[0])+',n='+str(mn[1]))\n\nax.set_title('F Distribution')\nax.legend(frameon=False)\nax.spines['right'].set_visible(False)\nax.spines['top'].set_visible(False)\nax.yaxis.set_ticks_position('left')\nax.xaxis.set_ticks_position('bottom')\n\nax.spines['left'].set_position('zero')\nax.spines['bottom'].set_position('zero')"
      },
      {
        "id": "ex5",
        "title": "9.5 B1_Ch9_5.py",
        "filename": "B1_Ch9_5.py",
        "code": "# B1_Ch9_5.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# maximum toss number\nN = 500\n# list of trial numbers\ntrials_total = []\n# list of faceup probablity in each trial\nprob_faceup = []\nfor trialnumber in range(1, N+1):\n    # np.random.binomial(trialnumber, 0.5) = number of heads in trialnumber coin tosses\n    faceup = np.random.binomial(trialnumber, 0.5)\n    prob_faceup.append(faceup/trialnumber)\n    trials_total.append(trialnumber)\n# plot\nplt.plot(trials_total, prob_faceup, linewidth = 0.5)\n\nplt.gca().spines['left'].set_position('zero')\nplt.gca().spines['bottom'].set_position('zero')\n# draw y=0.5 red line\nplt.axhline(y=0.5, xmin=0.03, xmax=1, color='r', linestyle='--')\nplt.yticks(np.arange(0.0, 1.1, step=0.1))\nplt.gca().get_yticklabels()[5].set_color('r')\n\nplt.title('Probability of face up in coin toss')\nplt.xlabel('Toss number')\nplt.ylabel('Probability of face up')\n\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.gca().yaxis.set_ticks_position('left')\nplt.gca().xaxis.set_ticks_position('bottom')"
      },
      {
        "id": "ex6",
        "title": "9.6 B1_Ch9_6.py",
        "filename": "B1_Ch9_6.py",
        "code": "# B1_Ch9_6.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\n# Central Limit Theorem\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# sample size\nsamplesize = 30\n\n# different number of sampling\nnumofsample = [10,50,100,500,1000,5000]\n# a list of sample mean\nmeansample = []\n\n# for each number of sampling (10 to 5000)\nfor i in numofsample:\n    # collect mean of each sample\n    eachmeansample = []\n    # for each sampling\n    for j in range(0,i):\n        # sampling 30 sample\n        rvs = np.random.uniform(size=samplesize)\n        # collect mean of each sample\n        eachmeansample.append(sum(rvs)/len(rvs))\n    # add mean of each sampling to the list\n    meansample.append(eachmeansample)\n\n# draw the graphs\nrows = 2\ncols = 3\nfig, ax = plt.subplots(rows, cols, figsize=(14,8))\nn = 0\n\nfor i in range(0, rows):\n    for j in range(0, cols):\n        ax[i, j].hist(meansample[n], bins=200, density=True, alpha=0.2)\n        ax[i, j].set_title(label=\"N: \" + str(numofsample[n]))\n        n+=1"
      },
      {
        "id": "ex7",
        "title": "9.7 B1_Ch9_7.py",
        "filename": "B1_Ch9_7.py",
        "code": "# B1_Ch9_7.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nfrom  pandas_datareader import data\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.stats import norm \n\ndf = data.DataReader('AAPL', 'yahoo', '2019-1-1', '2019-12-31')['Adj Close']\n# log return\ndflog = np.log(df)\nstockreturn = dflog.pct_change()\nstockreturn = stockreturn[1:]\n# mean and std\nmean, sigma = np.mean(stockreturn), np.std(stockreturn, ddof=1)\n\nconfidence_level_list = [0.68, 0.95, 0.997]\ncustomized_palette = [\"#3C9DFF\",\"#B7DEE8\", \"#0070C0\"]\ni=0\nfor confidence_level in confidence_level_list:    \n    confidence_interval = norm.interval(confidence_level, loc=mean, scale=sigma)\n    interval_label = str(confidence_level_list[i])+' confidence interval: ['+str(r'{0:.3f}'.format(confidence_interval[0]))+','+str(r'{0:.3f}'.format(confidence_interval[1]))+']'\n    plt.plot((confidence_interval[0], confidence_interval[0]), (0, norm.pdf(confidence_interval[0], loc=mean, scale=sigma)), color=customized_palette[i], linestyle='--')\n\n    plt.plot((confidence_interval[1], confidence_interval[1]), (0, norm.pdf(confidence_interval[1], loc=mean, scale=sigma)), color=customized_palette[i], linestyle='--')\n    plt.annotate(interval_label, \n                  xy=(confidence_interval[0], norm.pdf(confidence_interval[1], loc=mean, scale=sigma)), xycoords='data',\n                  xytext=(confidence_interval[1], norm.pdf(confidence_interval[1], loc=mean, scale=sigma)), textcoords='data',\n                  arrowprops=dict(arrowstyle=\"<|-|>\",\n                                  connectionstyle=\"arc3\",\n                                  mutation_scale=20,\n                                  fc=\"w\")\n                    )   \n\n    i+=1\n\n    print(str(confidence_level*100)+\"% \"+\"Confidence Interval: [\"+ str(round(confidence_interval[0],3))+\",\"+str(round(confidence_interval[1],3))+\"]\")\n\nx = np.linspace(norm.ppf(0.0001, loc=mean, scale=sigma),\n                norm.ppf(0.9999, loc=mean, scale=sigma), 1000)\nplt.plot(x, norm.pdf(x, loc=mean, scale=sigma), color='r', label='norm pdf')\n\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.gca().yaxis.set_ticks_position('left')\nplt.gca().xaxis.set_ticks_position('bottom')\nplt.gca().spines['bottom'].set_position('zero')\n"
      },
      {
        "id": "ex8",
        "title": "9.8 B1_Ch9_8.py",
        "filename": "B1_Ch9_8.py",
        "code": "# B1_Ch9_8.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nfrom scipy.stats import ttest_ind, t\n\nalpha = 0.05\n\nstockreturn1 = [-0.020809662379123517, 0.00846703325245679, -0.000447501087096569, 0.0037943429167992537, 0.00337077454971646, 0.0006366568709006426, -0.001967167012908333, -0.003026737458921125, 0.0040596182036833905, 0.0024232318939352293, 0.0011785909968373698, 0.0012210301746806707, -0.004508716349038044, 0.0008052363515955729, 0.006508926423269834]\n\nstockreturn2 = [-0.001844371674326828, -0.002070621212762691, 0.01316396325231195, 0.0014103778581735504, 9.433813027959204e-05, 0.005497221072897629, 0.003311408623482226, 6.701621195870366e-05, -0.0037197388299609058, 0.00022932086310833988, -0.0011259319781000698, 0.0016769041143169794, -0.0008123268983916132, 0.0007101444324377759, -0.00043462154134144004]\n\n# calculate cirtical value\ndf = len(stockreturn1)+len(stockreturn2)-2\ncritical_value = t.ppf(1.0-alpha, df)\nprint('critical_value=%.3f' % (critical_value))\n\n# calculate t stastics and p value\nt_stat, p = ttest_ind(stockreturn1, stockreturn2)\nprint('t-statistic=%.3f, p_value=%.3f' % (t_stat, p))\n\n# conclusion via t statastics\nif abs(t_stat) <= critical_value:\n    print('Cannot reject Null Hypothesis -- The mean of these two samples are the same.')\nelse:\n    print('Reject Null Hypothesis -- The mean of these two samples are different.')\n    \n# conclusion via p value\nif p <= alpha:\n    print('Reject Null Hypothesis -- The mean of these two samples are different.')\nelse:\n    print('Cannot reject Null Hypothesis -- The mean of these two samples are the same.')\n"
      },
      {
        "id": "ex9",
        "title": "9.9 B1_Ch9_9.py",
        "filename": "B1_Ch9_9.py",
        "code": "# B1_Ch9_9.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\n# B1_Ch9_9_A.py\nfrom scipy import stats\n\nalpha = 0.05\n\np_value = stats.binom_test(14, n=20, p=0.5, alternative='greater')\nprint('p_value=%.3f' % p_value)\n\nif p_value <= alpha:\n    print('Reject Null Hypothesis -- Unfair coin')\nelse:\n    print('Cannot reject Null Hypothesis -- Fair coin')\n\n    \n    \n# B1_Ch9_9_B.py\np_value = stats.binom_test(14, n=20, p=0.5, alternative='two-sided')\nprint('p_value=%.3f' % p_value)\n\nif p_value <= alpha/2:\n    print('Reject Null Hypothesis -- Unfair coin')\nelse:\n    print('Cannot reject Null Hypothesis -- Fair coin')\n"
      }
    ]
  },
  {
    "id": "b1_ch10",
    "title": "第10章：金融計算 I",
    "number": 10,
    "content": {
      "intro": {
        "title": "第 10 章：金融計算 I - 詳解",
        "roadmap": {
          "guide": "",
          "objectives": "掌握金融工程的演算基礎。本章專注於利率換算（複利與連續複利）、報酬率計算、以及數值分析中的重要工具：線性插值（Interpolation）與非線性求根（Root Finding）。",
          "topics": "*   10.1 利率基礎與計算\n*   10.2 簡單收益率計算\n*   10.3 對數收益率計算\n*   10.4 多項式函數模型\n*   10.5 插值法 (Interpolation) 應用\n*   10.6 數列與求和\n*   10.7 方程式求根 (Root-finding)\n*   10.8 分段函數"
        },
        "value": {
          "practical": "*   **實務場景**：構建債券定價模型及隱含波動率 (Implied Volatility) 掃描器。\n*   **考試重點**：離散複利與連續複利的換算公式考點。",
          "theory": "*   **貨幣時間價值與利率度量**：理解季度複利、半年複利與連續複利之間的轉換公式。連續複利在衍生品定價中是標準假設。\n*   **插值與收益率曲線**：市場上通常只有特定期限的利率，需透過插值技術補全整條收益率曲線。",
          "further_reading": "*   三維樣條插值 (Spline Interpolation) 在波動率曲面平滑中的應用。"
        },
        "implementation": {
          "python": "*   **求根運算**：解決無法解出解析解的手算難題（如：計算 IRR 內部收益率或選擇權的隱含波動率）。\n*   **數值逼近**：利用 Python 的 `scipy.optimize` 高速尋找最優解。",
          "logic": "*   `numpy.interp()`：線性插值。\n*   `scipy.optimize.newton()` / `bisect()`：牛頓法與二分法求根。\n*   報酬率對數化：利用 $\\ln(P_t/P_{t-1})$ 實現報酬率的可加性。",
          "scenarios": "| 腳本名稱 | 核心使命 |\n| :--- | :--- |\n| **B1_Ch10_1.py** | 計算有效年利率 (Effective Annual Rate, EAR) 與連續複利轉換。 |\n| **B1_Ch10_2.py** | 實作單期與多期現值 (PV) 與終值 (FV) 的折現計算。 |\n| **B1_Ch10_3.py** | 利用 QuantLib 構建基礎 Yield Curve 收益率曲線。 |\n| **B1_Ch10_4.py** | 演示年金 (Annuity) 平等支付金額的序列生成邏輯。 |\n| **B1_Ch10_5.py** | 實作內部報酬率 (IRR) 的數值求解法。 |\n| **B1_Ch10_6.py** | 演示定息債券 (Fixed-rate Bond) 的全價與淨價計算邏輯。 |\n| **B1_Ch10_7.py** | 實作債券存續期間 (Duration) 與凸性 (Convexity) 的靈敏度分析。 |\n| **B1_Ch10_8.py** | 演示浮動利率票據 (FRN) 的重設機制模擬。 |\n| **B1_Ch10_9.py** | 利用 QuantLib 進行簡單的互換合約 (SWAP) 定價基礎。 |\n| **B1_Ch10_10.py** | 利用 SymPy 繪製隱式曲線（拋物線、橢圓、雙曲線）的圖形分析。 |\n| **B1_Ch10_11.py** | 繪製雙變數線性函數的 3D 曲面與等高線圖，視覺化偏導數概念。 |\n| **B1_Ch10_12.py** | 繪製二次曲面（拋物面、鞍面、圓錐）的 3D 曲面與等高線圖。 |"
        },
        "body": "### 10.1 利率基礎與計算\n\n#### 概念定義\n利率類型：\n- **名目利率 (Nominal)**：報價利率\n- **實質利率 (Real)**：扣除通膨後的利率\n- **有效年利率 (EAR)**：考慮複利的真實年化回報\n\n複利頻率轉換：\n$$\nEAR = \\left(1 + \\frac{r}{m}\\right)^m - 1\n$$\n\n#### 財金理論背景\n利率是金融的核心變量：\n- 所有資產定價的折現基礎\n- 央行貨幣政策的主要工具\n- 風險溢價的度量參照\n\n#### 數學公式或模型\n連續複利轉換：\n$$\nr_{continuous} = m \\cdot \\ln\\left(1 + \\frac{r_{nominal}}{m}\\right)\n$$\n\n$$\nEAR = e^{r_{continuous}} - 1\n$$\n\n#### Python 實現邏輯\n```python\nimport numpy as np\n\ndef nominal_to_ear(r_nominal, m):\n    \"\"\"名目利率轉有效年利率\"\"\"\n    return (1 + r_nominal/m)**m - 1\n\ndef nominal_to_continuous(r_nominal, m):\n    \"\"\"名目利率轉連續複利\"\"\"\n    return m * np.log(1 + r_nominal/m)\n\ndef continuous_to_ear(r_continuous):\n    \"\"\"連續複利轉有效年利率\"\"\"\n    return np.exp(r_continuous) - 1\n\n# 範例：6% 半年複利\nr_nominal = 0.06\nm = 2\near = nominal_to_ear(r_nominal, m)  # 6.09%\nr_cont = nominal_to_continuous(r_nominal, m)  # 5.91%\n```\n\n#### 常見陷阱與注意事項\n- **複利頻率**：不同市場慣例不同（債券半年、房貸月付）\n- **日計基礎**：ACT/360 vs ACT/365 影響利息計算\n- **Black-Scholes**：使用連續複利，需轉換\n\n#### 實務應用場景\n- 比較不同銀行的存款利率\n- 債券收益率的年化\n- 衍生品定價的貼現\n\n#### 與其他章節的關聯\n利率計算是 Ch12 債券定價和存續期間的基礎。\n\n---\n\n### 10.2 簡單收益率計算\n\n#### 概念定義\n**簡單收益率 (Simple Return)**：\n$$\nR_t = \\frac{P_t - P_{t-1}}{P_{t-1}} = \\frac{P_t}{P_{t-1}} - 1\n$$\n\n特性：資產組合可加性，但多期不可加。\n\n#### 財金理論背景\n投資組合的收益計算：\n$$\nR_{portfolio} = \\sum_{i=1}^n w_i R_i\n$$\n\n權重加總等於 1，組合收益是個股收益的線性組合。\n\n#### Python 實現邏輯\n```python\nimport numpy as np\nimport pandas as pd\n\nprices = pd.Series([100, 102, 99, 105, 108])\n\n# 簡單收益率\nsimple_returns = prices.pct_change().dropna()\n# 或\nsimple_returns = (prices / prices.shift(1) - 1).dropna()\n\n# 累積收益\ncumulative = (1 + simple_returns).prod() - 1\n\n# 投資組合收益\nweights = np.array([0.4, 0.3, 0.3])\nstock_returns = np.array([0.05, 0.03, -0.02])\nportfolio_return = np.dot(weights, stock_returns)\n```\n\n#### 常見陷阱與注意事項\n- **多期累積**：不能直接加總，需用 $(1+R_1)(1+R_2)-1$\n- **負價格處理**：期貨可能為負，需特殊處理\n- **權重再平衡**：權重會隨價格變化，需定期調整\n\n#### 實務應用場景\n- 計算每日/月度績效\n- 投資組合歸因分析\n- 報告表現給投資人\n\n#### 與其他章節的關聯\n簡單收益率與 Ch10.3 對數收益率各有適用場景。\n\n---\n\n### 10.3 對數收益率計算\n\n#### 概念定義\n**對數收益率 (Log Return)**：\n$$\nr_t = \\ln\\left(\\frac{P_t}{P_{t-1}}\\right) = \\ln(P_t) - \\ln(P_{t-1})\n$$\n\n特性：時間可加性，多期收益 = 各期對數收益之和。\n\n#### 財金理論背景\n- 符合資產價格的對數正態假設\n- Black-Scholes 模型基於連續複利（對數收益）\n- 便於統計建模（正態分佈假設）\n\n#### 數學公式或模型\n年化對數收益率：\n$$\nr_{annual} = r_{daily} \\times 252\n$$\n\n與簡單收益率的關係：\n$$\nr = \\ln(1 + R) \\approx R \\quad \\text{(當 R 很小)}\n$$\n\n#### Python 實現邏輯\n```python\nimport numpy as np\nimport pandas as pd\n\nprices = pd.Series([100, 102, 99, 105, 108])\n\n# 對數收益率\nlog_returns = np.log(prices / prices.shift(1)).dropna()\n\n# 累積收益（對數收益率直接加總）\ncumulative_log = log_returns.sum()\ncumulative_simple = np.exp(cumulative_log) - 1\n\n# 年化波動率\ndaily_vol = log_returns.std()\nannual_vol = daily_vol * np.sqrt(252)\nprint(f\"年化波動率: {annual_vol:.2%}\")\n```\n\n#### 常見陷阱與注意事項\n- **組合不可加**：對數收益率無法直接加權求組合收益\n- **大變動差異**：當 R > 10%，對數與簡單收益差異顯著\n- **負價格問題**：對數要求價格 > 0\n\n#### 實務應用場景\n- 風險模型（VaR, ES）的收益率輸入\n- 衍生品定價的波動率估計\n- 長期績效的累積計算\n\n#### 與其他章節的關聯\n對數收益率是 Ch8 對數正態分佈和 Ch11 BS 定價的基礎。\n\n---\n\n### 10.4 多項式函數模型\n\n#### 概念定義\n用多項式擬合數據關係：\n$$\ny = a_0 + a_1 x + a_2 x^2 + ... + a_n x^n\n$$\n\n在金融中常用於曲線擬合和泰勒近似。\n\n#### 財金理論背景\n債券價格-利率關係的二階近似：\n$$\n\\Delta P \\approx -D \\cdot \\Delta y + \\frac{1}{2} C \\cdot (\\Delta y)^2\n$$\n\n這是二次多項式的形式。\n\n#### Python 實現邏輯\n```python\nimport numpy as np\n\n# 已知數據點\nx = np.array([1, 2, 3, 4, 5])\ny = np.array([2.0, 4.1, 8.9, 15.8, 25.2])\n\n# 多項式擬合（二次）\ncoeffs = np.polyfit(x, y, 2)  # 返回 [a2, a1, a0]\npoly = np.poly1d(coeffs)\n\n# 預測\ny_pred = poly(3.5)\n\n# 繪圖\nx_plot = np.linspace(0, 6, 100)\ny_plot = poly(x_plot)\n```\n\n#### 常見陷阱與注意事項\n- **過擬合**：高階多項式可能在外推時失控\n- **數值穩定**：大範圍 x 值可能導致數值問題\n- **選擇階數**：使用交叉驗證或資訊準則\n\n#### 實務應用場景\n- 收益率曲線的平滑擬合\n- Duration-Convexity 近似\n- 波動率微笑的參數化\n\n#### 與其他章節的關聯\n多項式近似是 Ch11 泰勒展開的基礎，用於 Ch12 Duration-Convexity。\n\n---\n\n### 10.5 插值法 (Interpolation) 應用\n\n#### 概念定義\n從已知點估計中間值：\n- **線性插值**：兩點連線\n- **樣條插值**：更平滑的曲線\n- **外推**：超出已知範圍（較危險）\n\n#### 財金理論背景\n收益率曲線構建的核心：\n- 市場只有 1, 2, 3, 5, 7, 10, 30 年期報價\n- 需要估計 4 年、8 年等中間期限\n- Bootstrap 方法依賴插值\n\n#### Python 實現邏輯\n```python\nimport numpy as np\nfrom scipy import interpolate\n\n# 已知利率（期限 vs 利率）\nmaturities = np.array([1, 2, 3, 5, 10])\nrates = np.array([0.02, 0.025, 0.03, 0.035, 0.04])\n\n# 線性插值\nrate_4y = np.interp(4, maturities, rates)\n\n# 三次樣條（更平滑）\nspline = interpolate.CubicSpline(maturities, rates)\nrate_4y_spline = spline(4)\n\n# 構建完整曲線\nall_maturities = np.linspace(1, 10, 100)\ncurve = spline(all_maturities)\n```\n\n#### 常見陷阱與注意事項\n- **外推風險**：樣條在範圍外行為不穩定\n- **負利率**：某些插值可能產生不合理的負值\n- **曲線平滑度**：不同方法差異明顯\n\n#### 實務應用場景\n- 構建零息曲線（Zero Curve）\n- 填補波動率曲面的缺失點\n- 歷史數據的缺失值填補\n\n#### 與其他章節的關聯\n插值用於 Ch12 的收益率曲線分析和債券定價。\n\n---\n\n### 10.6 數列與求和\n\n#### 概念定義\n- **等差數列**：$a_n = a_1 + (n-1)d$\n- **等比數列**：$a_n = a_1 \\cdot r^{n-1}$\n- **無窮等比級數**：$S = \\frac{a_1}{1-r}$（當 $|r| < 1$）\n\n#### 財金理論背景\n現金流定價的數學基礎：\n- 普通年金 PV = $\\frac{C}{r}[1 - (1+r)^{-n}]$\n- 永續年金 PV = $\\frac{C}{r}$（等比級數極限）\n- 成長型永續 PV = $\\frac{C}{r-g}$\n\n#### 數學公式或模型\n年金現值因子：\n$$\nPVIFA = \\frac{1 - (1+r)^{-n}}{r}\n$$\n\n#### Python 實現邏輯\n```python\nimport numpy as np\n\n# 年金現值\ndef pv_annuity(C, r, n):\n    \"\"\"計算普通年金現值\"\"\"\n    return C * (1 - (1+r)**(-n)) / r\n\n# 永續年金\ndef pv_perpetuity(C, r):\n    return C / r\n\n# 成長型永續\ndef pv_growing_perp(C, r, g):\n    return C / (r - g)\n\n# 向量化：多期現金流現值\ncash_flows = np.array([100, 100, 100, 1100])  # 3年期債券\nr = 0.05\nperiods = np.arange(1, len(cash_flows)+1)\npv = np.sum(cash_flows / (1+r)**periods)\n```\n\n#### 常見陷阱與注意事項\n- **時點定義**：期初 vs 期末年金\n- **成長率限制**：$g < r$ 才收斂\n- **NPV vs IRR**：不同決策準則可能有矛盾\n\n#### 實務應用場景\n- 債券和貸款的現值計算\n- 股息折現模型（DDM）\n- 專案投資評估（NPV）\n\n#### 與其他章節的關聯\n級數求和是 Ch12 債券定價的數學基礎。\n\n---\n\n### 10.7 方程式求根 (Root-finding)\n\n#### 概念定義\n尋找使 $f(x) = 0$ 的 x 值：\n- **二分法**：穩定但較慢\n- **牛頓法**：快速但需導數\n- **割線法**：不需導數的牛頓法變體\n\n#### 財金理論背景\n無解析解的金融問題：\n- 已知債券價格求 YTM\n- 已知期權價格求隱含波動率\n- 已知現金流求 IRR\n\n#### 數學公式或模型\n牛頓法迭代：\n$$\nx_{n+1} = x_n - \\frac{f(x_n)}{f'(x_n)}\n$$\n\n#### Python 實現邏輯\n```python\nfrom scipy.optimize import brentq, newton\nimport numpy as np\n\n# 求 YTM：已知價格求利率\ndef bond_price(y, cash_flows, periods):\n    return np.sum(cash_flows / (1+y)**periods)\n\ndef find_ytm(price, cash_flows, periods):\n    objective = lambda y: bond_price(y, cash_flows, periods) - price\n    return brentq(objective, 0.001, 0.50)  # 二分法\n\n# 範例\ncash_flows = np.array([5, 5, 5, 105])  # 5% 票息\nperiods = np.array([1, 2, 3, 4])\nmarket_price = 95\nytm = find_ytm(market_price, cash_flows, periods)\nprint(f\"YTM: {ytm:.4%}\")\n\n# 隱含波動率（二分法）\nfrom scipy.stats import norm\n\ndef bs_call(S, K, r, T, sigma):\n    d1 = (np.log(S/K) + (r + 0.5*sigma**2)*T) / (sigma*np.sqrt(T))\n    d2 = d1 - sigma*np.sqrt(T)\n    return S*norm.cdf(d1) - K*np.exp(-r*T)*norm.cdf(d2)\n\ndef implied_vol(C_market, S, K, r, T):\n    objective = lambda sigma: bs_call(S, K, r, T, sigma) - C_market\n    return brentq(objective, 0.01, 2.0)\n```\n\n#### 常見陷阱與注意事項\n- **初始值**：牛頓法對初始值敏感\n- **區間設定**：二分法需確保符號改變\n- **多解問題**：某些方程有多個根\n\n#### 實務應用場景\n- 債券 YTM 計算\n- 隱含波動率掃描\n- IRR 計算\n\n#### 與其他章節的關聯\n求根技術在 Ch11 隱含波動率和 Ch12 YTM 計算中大量使用。\n\n---\n\n### 10.8 分段函數\n\n#### 概念定義\n函數在不同區間有不同定義：\n$$\nf(x) = \\begin{cases} \nf_1(x) & x < a \\\\\nf_2(x) & x \\geq a\n\\end{cases}\n$$\n\n#### 財金理論背景\n金融合約充滿分段邏輯：\n- **期權 Payoff**：$\\max(S-K, 0)$\n- **可轉債轉換**：超過轉換價格才觸發\n- **保證金追繳**：低於維持保證金才觸發\n\n#### Python 實現邏輯\n```python\nimport numpy as np\n\n# 買權 Payoff\ndef call_payoff(S, K):\n    return np.maximum(S - K, 0)\n\n# 使用 np.where\ndef call_payoff_v2(S, K):\n    return np.where(S > K, S - K, 0)\n\n# 複雜分段函數\ndef tax_bracket(income):\n    result = np.zeros_like(income, dtype=float)\n    # 0   - 50K:  10%\n    # 50K - 100K: 20%\n    # 100K+:      30%\n    result = np.where(income <= 50000, income * 0.10,\n             np.where(income <= 100000, 5000 + (income - 50000) * 0.20,\n                      15000 + (income - 100000) * 0.30))\n    return result\n\n# 向量化處理\nS = np.linspace(80, 120, 100)\nK = 100\npayoff = call_payoff(S, K)\n```\n\n#### 常見陷阱與注意事項\n- **向量化**：避免在大數據集上用 if-else 迴圈\n- **邊界處理**：$\\leq$ vs $<$ 需明確\n- **連續性**：分段點的函數值需一致\n\n#### 實務應用場景\n- 期權和結構型產品定價\n- 稅務計算\n- 保證金和限額管理\n\n#### 與其他章節的關聯\n分段函數在 Ch11 期權 Payoff 圖和 Ch7 視覺化中大量出現。"
      }
    },
    "examples": [
      {
        "id": "ex1",
        "title": "10.1 B1_Ch10_1.py",
        "filename": "B1_Ch10_1.py",
        "code": "\n# B1_Ch10_1.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport math\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef eff_rr(r, m):\n    \n    '''\n    r = annual rate, scalar numeric decimal\n    m = number of compounding periods per year\n    '''\n    \n    eff_rate = (1 + r/m)**m - 1;\n    \n    return eff_rate\n    \nm_array = [1, 2, 4, 12, 52, 252]\nr = 0.05;\n\n\neff_rr_vec = np.vectorize(eff_rr)\neff_rr_array = eff_rr_vec(r,m_array)\n\neff_rr_from_continuous = math.exp(r) - 1;\n\nfig, ax = plt.subplots()\n\nplt.xlabel(\"Number of compounding periods, $\\it{m}$\") \nplt.ylabel(\"Effective rate of return\") \nplt.plot(m_array,eff_rr_array,marker = 'x', markersize = 12, linewidth = 1.5) \nplt.axhline(y=eff_rr_from_continuous, color='r', linestyle='--')\nplt.rcParams[\"font.family\"] = \"Times New Roman\"\nplt.rcParams[\"font.size\"] = 10\n\nplt.show()\nax.grid(linestyle='--', linewidth=0.25, color=[0.5,0.5,0.5])\n"
      },
      {
        "id": "ex2",
        "title": "10.2 B1_Ch10_2.py",
        "filename": "B1_Ch10_2.py",
        "code": "# B1_Ch10_2.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\n# B1_Ch10_2_A.py\n\nimport pandas as pd\nimport numpy as np\nimport pandas_datareader as web\nimport matplotlib.pyplot as plt\nimport scipy.stats as stats\nimport statsmodels.api as sm\nimport pylab\nimport matplotlib.mlab as mlab\n\ndf = web.get_data_yahoo('TSLA', start = '2020-01-01', end = '2020-12-31')\n\n#%% Plot price level of stock\nplt.close('all')\n\nfig, ax = plt.subplots()\n\ndf['Adj Close'].plot()\nplt.xlabel('Date')\nplt.ylabel('Adjusted closing price')\nplt.show()\nplt.rcParams[\"font.family\"] = \"Times New Roman\"\nplt.rcParams[\"font.size\"] = 10\n\nax.grid(linestyle='--', linewidth=0.25, color=[0.5,0.5,0.5])\n\n#%% simple return of stock price\n\n# daily returns\ndaily_simple_returns_pct = df['Adj Close'].pct_change()\n# daily returns are not in the format of percentage.\nvalues = daily_simple_returns_pct[1:]\nmu, sigma = stats.norm.fit(values)\n\nfig, ax = plt.subplots()\n\nax.plot(daily_simple_returns_pct,marker='x')\nplt.axhline(y=0, color='k', linestyle='-')\nplt.axhline(y=mu, color='r', linestyle='--')\nplt.axhline(y=mu + sigma, color='r', linestyle='--')\nplt.axhline(y=mu - sigma, color='r', linestyle='--')\nplt.axhline(y=mu + 2*sigma, color='r', linestyle='--')\nplt.axhline(y=mu - 2*sigma, color='r', linestyle='--')\nplt.xlabel('Date')\nplt.ylabel('Daily simple return')\nplt.show()\nplt.rcParams[\"font.family\"] = \"Times New Roman\"\nplt.rcParams[\"font.size\"] = 10\n\nax.grid(linestyle='--', linewidth=0.25, color=[0.5,0.5,0.5])\n\n#%% Distribution of daily simple returns\n\nlabel = '$\\it{\\mu}$ = %.4f, $\\it{\\sigma}$ = %.4f' % (mu, sigma)\n\nfig, ax = plt.subplots()\nax.hist(values, bins=30, rwidth=0.85)\ny_lim = ax.get_ylim()\nplt.plot([mu,mu],y_lim,'r')\nplt.plot([mu + sigma,mu + sigma],0.75*np.asarray(y_lim),'r')\nplt.plot([mu - sigma,mu - sigma],0.75*np.asarray(y_lim),'r')\nplt.plot([mu + 2.0*sigma,mu + 2.0*sigma],0.5*np.asarray(y_lim),'r')\nplt.plot([mu - 2.0*sigma,mu - 2.0*sigma],0.5*np.asarray(y_lim),'r')\nplt.plot([mu + 3.0*sigma,mu + 3.0*sigma],0.25*np.asarray(y_lim),'r')\nplt.plot([mu - 3.0*sigma,mu - 3.0*sigma],0.25*np.asarray(y_lim),'r')\nplt.title(label)\nax.grid(linestyle='--', linewidth=0.25, color=[0.5,0.5,0.5])\nplt.xlabel('Daily simple return')\nplt.ylabel('Frequency')\n\n# add a normal fit PDF curve\n\nfig, ax = plt.subplots()\n# the histogram of the data\nn, bins, patches = plt.hist(values, 30, density=1, rwidth=0.85)\ny_lim = ax.get_ylim()\nbest_fit_line = stats.norm.pdf(bins, mu, sigma)\nplt.plot(bins, best_fit_line, 'r-', linewidth=2)\n\nplt.plot([mu,mu],y_lim,'r')\nplt.plot([mu + sigma,mu + sigma],0.75*np.asarray(y_lim),'r')\nplt.plot([mu - sigma,mu - sigma],0.75*np.asarray(y_lim),'r')\n\nplt.show()\nplt.rcParams[\"font.family\"] = \"Times New Roman\"\nplt.rcParams[\"font.size\"] = 10\nplt.xlabel('Daily simple return')\nplt.ylabel('Probability')\nax.grid(linestyle='--', linewidth=0.25, color=[0.5,0.5,0.5])\n\n#%% weekly simple returns\n\nwkly_simple_returns_pct = df['Adj Close'].pct_change(periods = 5)\n# not percentage\nvalues = wkly_simple_returns_pct[5:]\nmu, sigma = stats.norm.fit(values)\n\nfig, ax = plt.subplots()\n\nax.plot(wkly_simple_returns_pct,marker='x')\nplt.axhline(y=0, color='k', linestyle='-')\nplt.xlabel('Date')\nplt.ylabel('Weekly simple return')\n\nplt.axhline(y=mu, color='r', linestyle='--')\nplt.axhline(y=mu + sigma, color='r', linestyle='--')\nplt.axhline(y=mu - sigma, color='r', linestyle='--')\nplt.axhline(y=mu + 2*sigma, color='r', linestyle='--')\nplt.axhline(y=mu - 2*sigma, color='r', linestyle='--')\n\nplt.show()\nplt.rcParams[\"font.family\"] = \"Times New Roman\"\nplt.rcParams[\"font.size\"] = 10\n\nax.grid(linestyle='--', linewidth=0.25, color=[0.5,0.5,0.5])\n\n\n# B1_Ch10_2_B.py\n\n#%% daily log return of stock price\n\ndf_adj_close = df['Adj Close']; \n\n# shift moves dates back by 1\n# daily log returns\ndf_log_r = df.apply(lambda x: np.log(x) - np.log(x.shift(1)))\ndaily_log_returns = df_log_r['Adj Close'];\n\nfig, ax = plt.subplots()\n\nax.plot(daily_log_returns,marker='x')\nplt.axhline(y=0, color='k', linestyle='-')\nplt.xlabel('Date')\nplt.ylabel('Daily log return')\nplt.show()\nplt.rcParams[\"font.family\"] = \"Times New Roman\"\nplt.rcParams[\"font.size\"] = 10\n\nax.grid(linestyle='--', linewidth=0.25, color=[0.5,0.5,0.5])\n\n#%% distribution of daily log returns\n\nvalues = daily_log_returns[1:]\nmu, sigma = stats.norm.fit(values)\n\nlabel = '$\\it{\\mu}$ = %.4f, $\\it{\\sigma}$ = %.4f' % (mu, sigma)\n\nfig, ax = plt.subplots()\nax.hist(values, bins=30, rwidth=0.85)\ny_lim = ax.get_ylim()\nplt.plot([mu,mu],y_lim,'r')\nplt.plot([mu + sigma,mu + sigma],0.75*np.asarray(y_lim),'r')\nplt.plot([mu - sigma,mu - sigma],0.75*np.asarray(y_lim),'r')\nplt.plot([mu + 2.0*sigma,mu + 2.0*sigma],0.5*np.asarray(y_lim),'r')\nplt.plot([mu - 2.0*sigma,mu - 2.0*sigma],0.5*np.asarray(y_lim),'r')\nplt.plot([mu + 3.0*sigma,mu + 3.0*sigma],0.25*np.asarray(y_lim),'r')\nplt.plot([mu - 3.0*sigma,mu - 3.0*sigma],0.25*np.asarray(y_lim),'r')\nplt.title(label)\nax.grid(linestyle='--', linewidth=0.25, color=[0.5,0.5,0.5])\nplt.xlabel('Daily log return')\nplt.ylabel('Frequency')\n\n\nfig, ax = plt.subplots()\n\nstats.probplot(values, dist=\"norm\", plot=pylab)\npylab.show()\nax.grid(linestyle='--', linewidth=0.25, color=[0.5,0.5,0.5])\nplt.xlabel('Normal distribution')\nplt.ylabel('Empirical distribution of daily log return')\n#%% shift moves dates back by 5\n# weekly log returns\ndf_log_r_wkly = df.apply(lambda x: np.log(x) - np.log(x.shift(5)))\nwkly_log_returns = df_log_r_wkly['Adj Close'];\n\nfig, ax = plt.subplots()\n\nax.plot(wkly_log_returns,marker='x')\nplt.axhline(y=0, color='k', linestyle='-')\nplt.xlabel('Date')\nplt.ylabel('Weekly log return')\nplt.show()\nplt.rcParams[\"font.family\"] = \"Times New Roman\"\nplt.rcParams[\"font.size\"] = 10\n\nax.grid(linestyle='--', linewidth=0.25, color=[0.5,0.5,0.5])\n"
      },
      {
        "id": "ex3",
        "title": "10.3 B1_Ch10_3.py",
        "filename": "B1_Ch10_3.py",
        "code": "# B1_Ch10_3.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport math\nimport numpy as np\nfrom matplotlib import pyplot as plt \n\nx = np.linspace(-2,2,100);\n\ndef plot_curve(x, y):\n    \n    fig, ax = plt.subplots()\n\n    plt.xlabel(\"$\\it{x}$\") \n    plt.ylabel(\"$\\it{f}(\\it{x})$\") \n    plt.plot(x, y, linewidth = 1.5) \n    plt.axhline(y=0, color='k', linewidth = 1.5)\n    plt.axvline(x=0, color='k', linewidth = 1.5)\n    ax.grid(linestyle='--', linewidth=0.25, color=[0.5,0.5,0.5])\n    plt.axis('equal')\n    plt.xticks(np.arange(-2, 2.5, step=0.5))\n    plt.yticks(np.arange(y.min(), y.max() + 0.5, step=0.5))\n    ax.set_xlim(x.min(),x.max())\n    ax.set_ylim(y.min(),y.max())\n    ax.spines['top'].set_visible(False)\n    ax.spines['right'].set_visible(False)\n    ax.spines['bottom'].set_visible(False)\n    ax.spines['left'].set_visible(False)\n    plt.axis('square')\n#%% plot linear, quadratic, and cubic functions\n\nplt.close('all')\n\n# linear function\ny = x + 1;\n\nplot_curve(x, y)\n\n# linear function\ny = -x + 1;\n\nplot_curve(x, y)\n\n# quadratic  function, parabola opens upwards\ny = np.power(x,2) - 2;\n\nplot_curve(x, y)\n\n# quadratic  function, parabola opens downwards\ny = -np.power(x,2) + 2;\n\nplot_curve(x, y)\n\n# cubic function\ny = np.power(x,3)/4;\n\nplot_curve(x, y)\n\n# cubic function\ny = -(np.power(x,3) - x)/3;\n\nplot_curve(x, y)\n"
      },
      {
        "id": "ex4",
        "title": "10.4 B1_Ch10_4.py",
        "filename": "B1_Ch10_4.py",
        "code": "# B1_Ch10_4.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport matplotlib.pyplot as plt\nfrom scipy.interpolate import interp1d, interp2d\nimport numpy as np\n\ntenors = [0.5, 1, 2, 5, 10, 15, 30]\nIR     = [0.02, 0.03, 0.038, 0.04, 0.048, 0.046, 0.044]\n\nf_linear = interp1d(tenors,IR) # default is 'linear'\nf_cubic  = interp1d(tenors,IR,kind = 'cubic') \n\n\ntenors_x = [4, 8, 20, 25]\ntenors_vec = np.linspace(0.5,30,50)\nIR_linear_y     = f_linear(tenors_x)\nIR_linear_y_vec = f_linear(tenors_vec)\n\nIR_cubic_y     = f_cubic(tenors_x)\nIR_cubic_y_vec = f_cubic(tenors_vec)\n\n#%% visualization\n\nplt.close('all')\n\nfig, ax = plt.subplots()\n\nplt.xlabel(\"Tenor (year)\") \nplt.ylabel(\"Interest rate\") \nplt.plot(tenors,IR,marker = 'o', linewidth = 1.5, linestyle=\"None\") \nplt.plot(tenors_x,IR_linear_y, color = 'r', marker = 'x', linestyle=\"None\", markersize = 12) \nplt.plot(tenors_vec,IR_linear_y_vec, color = 'b') \n\nplt.rcParams[\"font.family\"] = \"Times New Roman\"\nplt.rcParams[\"font.size\"] = 10\n\nplt.show()\nax.grid(linestyle='--', linewidth=0.25, color=[0.5,0.5,0.5])\n\nfig, ax = plt.subplots()\n\nplt.xlabel(\"Tenor (year)\") \nplt.ylabel(\"Interest rate\") \nplt.plot(tenors,IR,marker = 'o', linewidth = 1.5, linestyle=\"None\") \nplt.plot(tenors_x,IR_cubic_y, color = 'r', marker = 'x', linestyle=\"None\", markersize = 12) \nplt.plot(tenors_vec,IR_cubic_y_vec, color = 'b') \n\nplt.rcParams[\"font.family\"] = \"Times New Roman\"\nplt.rcParams[\"font.size\"] = 10\n\nplt.show()\nax.grid(linestyle='--', linewidth=0.25, color=[0.5,0.5,0.5])\n"
      },
      {
        "id": "ex5",
        "title": "10.5 B1_Ch10_5.py",
        "filename": "B1_Ch10_5.py",
        "code": "# B1_Ch10_5.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport matplotlib.pyplot as plt\nfrom scipy.interpolate import interp1d, interp2d\nimport numpy as np\nfrom matplotlib import cm\n\nIV = [[0.306, 0.302, 0.298, 0.294],\n      [0.290, 0.287, 0.282, 0.278],\n      [0.281, 0.277, 0.273, 0.269],\n      [0.287, 0.284, 0.279, 0.275],\n      [0.300, 0.296, 0.292, 0.288]]\n\n\n# surface of implied volatility\n \ntau = [0.25, 0.375, 0.5, 0.625]; \n# time to maturity\n \nMoneyness = [0.9, 0.95, 1, 1.05, 1.1]; \n# Moneyness, S/K\n\nxx,yy = np.meshgrid(tau,Moneyness)\n\nx_array = np.squeeze(np.asarray(xx))\ny_array = np.squeeze(np.asarray(yy))\nz_array = np.squeeze(np.asarray(IV))\n\nf_linear = interp2d(tau,Moneyness,IV) # default = linear\nf_cubic  = interp2d(tau,Moneyness,IV, kind = 'cubic')\n\nx_q = np.linspace(0.25, 0.625 ,30)\ny_q = np.linspace(0.9,  1.1   ,30)\n\nxx_q,yy_q = np.meshgrid(x_q,y_q)\n\nzz_q_linear = f_linear(x_q,y_q)\nzz_q_cubic  = f_cubic(x_q,y_q)\n\n#%% visualization\n\nplt.close('all')\n\n# Normalize to [0,1]\nnorm = plt.Normalize(zz_q_linear.min(), zz_q_linear.max())\ncolors = cm.coolwarm(norm(zz_q_linear))\n\nfig = plt.figure()\nax = fig.add_subplot(111, projection='3d')\nsurf = ax.plot_surface(xx_q, yy_q, zz_q_linear,\n    facecolors=colors, shade=False)\nsurf.set_facecolor((0,0,0,0))\n\nax.scatter(x_array, y_array, z_array, c='k', marker='x')\n\nplt.show()\n\nplt.tight_layout()\nax.set_xlabel('Time to maturity')\nax.set_ylabel('Moneyness')\nax.set_zlabel('Vol')\n\nax.xaxis._axinfo[\"grid\"].update({\"linewidth\":0.25, \"linestyle\" : \":\"})\nax.yaxis._axinfo[\"grid\"].update({\"linewidth\":0.25, \"linestyle\" : \":\"})\nax.zaxis._axinfo[\"grid\"].update({\"linewidth\":0.25, \"linestyle\" : \":\"})\n\nplt.rcParams[\"font.family\"] = \"Times New Roman\"\nplt.rcParams[\"font.size\"] = \"10\"\nax.view_init(30, 30)\n\n# Normalize to [0,1]\nnorm = plt.Normalize(zz_q_cubic.min(), zz_q_cubic.max())\ncolors = cm.coolwarm(norm(zz_q_cubic))\n\nfig = plt.figure()\nax = fig.add_subplot(111, projection='3d')\nsurf = ax.plot_surface(xx_q, yy_q, zz_q_cubic,\n    facecolors=colors, shade=False)\nsurf.set_facecolor((0,0,0,0))\n\nax.scatter(x_array, y_array, z_array, c='k', marker='x')\n\nplt.show()\n\nplt.tight_layout()\nax.set_xlabel('Time to maturity')\nax.set_ylabel('Moneyness')\nax.set_zlabel('Vol')\n\nax.xaxis._axinfo[\"grid\"].update({\"linewidth\":0.25, \"linestyle\" : \":\"})\nax.yaxis._axinfo[\"grid\"].update({\"linewidth\":0.25, \"linestyle\" : \":\"})\nax.zaxis._axinfo[\"grid\"].update({\"linewidth\":0.25, \"linestyle\" : \":\"})\n\nplt.rcParams[\"font.family\"] = \"Times New Roman\"\nplt.rcParams[\"font.size\"] = \"10\"\nax.view_init(30, 30)\n"
      },
      {
        "id": "ex6",
        "title": "10.6 B1_Ch10_6.py",
        "filename": "B1_Ch10_6.py",
        "code": "# B1_Ch10_6.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\ndef pvfix(y_p, nper, pmt, fv):\n    \n    '''\n    r_p : periodic interest rate\n    nper: number of payment periods\n    pmt : periodic payment\n    fv  : payment received other than pmt \n    in the end of the last period\n    '''\n    pv = pmt*((1.0 + y_p)**nper - 1.0)/(1.0 + y_p)**nper/y_p + \\\n    fv/(1.0 + y_p)**nper;\n    \n    return pv\n\ny = 0.05;  # annual interest rate\nm = 4;     # compounding frequency\nT = 5;     # years\nc = 10;    # annual payment\npmt = c/m  # periodic payment\nfv = 100;  # payment at the end\n\nPV = pvfix(y/m, m*T, pmt, fv)\nprint(\"Present Value (PV) = \" + str(round(PV, 4)))\n"
      },
      {
        "id": "ex7",
        "title": "10.7 B1_Ch10_7.py",
        "filename": "B1_Ch10_7.py",
        "code": "# B1_Ch10_7.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport numpy as np\nfrom matplotlib import pyplot as plt \n\nL = 252   # lookback window, 252 business days in a year\n\nlambda_94 = 0.94; \n\ni_days = range(0,L);\n\nweights = (1.0 - lambda_94)/(1 - lambda_94**L)*np.power(lambda_94,i_days)\n\nplt.close('all')\n\nfig, ax = plt.subplots()\n\nplt.plot(i_days, weights, linewidth = 1.5) \nplt.plot(i_days[0], weights[0], marker = 'x',markersize = 12) \nplt.axhline(y=weights[0]/2, color='r', linewidth = 0.5)\nax.grid(linestyle='--', linewidth=0.25, color=[0.5,0.5,0.5])\n\nx_label = \"Lookback days, $\\it{i}$\" \nax.set_xlabel(x_label)\ny_label = \"Weight\" \nax.set_ylabel(y_label)\nplt.rcParams[\"font.family\"] = \"Times New Roman\"\nplt.rcParams[\"font.size\"] = \"10\"\n\n\nlambda_array = np.linspace (0.99,0.9,num = 19)\n\nHL = np.log(1.0/2.0)/np.log(lambda_array)\n\nfig, ax = plt.subplots()\n\nplt.xlabel(\"$\\it{\\lambda}$\") \nplt.ylabel(\"Half life\") \nplt.plot(lambda_array, HL, marker = 'x',markersize = 12) \n\nax.grid(linestyle='--', linewidth=0.25, color=[0.5,0.5,0.5])\nplt.rcParams[\"font.family\"] = \"Times New Roman\"\nplt.rcParams[\"font.size\"] = \"10\"\n"
      },
      {
        "id": "ex8",
        "title": "10.8 B1_Ch10_8.py",
        "filename": "B1_Ch10_8.py",
        "code": "# B1_Ch10_8.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport numpy as np\nimport numpy_financial as npf\n\nCFs = [-400, 120, 80, 180, 100];\nCFs_flip = CFs[::-1]\n\nroots = np.roots(CFs_flip)\nmask = (roots.imag == 0) & (roots.real > 0)\n\nx = roots[mask].real\n\nirr_replicated = 1/x - 1\n\nirr_result = npf.irr(CFs)\nprint(\"IRR = \" + str(round(irr_result,5)))\n"
      },
      {
        "id": "ex9",
        "title": "10.9 B1_Ch10_9.py",
        "filename": "B1_Ch10_9.py",
        "code": "# B1_Ch10_9.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport math\nimport numpy as np\nfrom matplotlib import pyplot as plt \n\nSt_array = np.linspace(20,80,300);\nK = 50; # strike price\n\n# payoff of European call option\nC_payoff = np.maximum(St_array - K, 0)\n\n# payoff of European put option\nP_payoff = np.maximum(K - St_array, 0)\n\nplt.close('all')\n\nfig, ax = plt.subplots()\n\nplt.xlabel(\"Underlying price, $\\it{S}$\") \nplt.ylabel(\"European Put payoff, $\\it{C}$\") \nplt.plot(St_array,C_payoff, linewidth = 1.5) \nplt.plot(K,0,'xr',linewidth = 0.25,markersize=12)\nplt.plot([K,K],[0,np.max(C_payoff)],'r--',linewidth = 0.25)\n\nplt.axis('equal')\n\nplt.rcParams[\"font.family\"] = \"Times New Roman\"\nplt.rcParams[\"font.size\"] = 10\n\nax.grid(linestyle='--', linewidth=0.25, color=[0.5,0.5,0.5])\n# plt.grid(True)\n\nplt.show()\n\nfig, ax = plt.subplots()\n\nplt.xlabel(\"Underlying price, $\\it{S}$\") \nplt.ylabel(\"European Put payoff, $\\it{P}$\") \nplt.plot(St_array,P_payoff,linewidth = 1.5) \nplt.plot(K,0,'xr',linewidth = 0.25,markersize=12)\nplt.plot([K,K],[0,np.max(P_payoff)],'r--',linewidth = 0.25)\n\nplt.axis('equal')\n\nplt.rcParams[\"font.family\"] = \"Times New Roman\"\nplt.rcParams[\"font.size\"] = 10\n\nax.grid(linestyle='--', linewidth=0.25, color=[0.5,0.5,0.5])\n# plt.grid(True)\n\nplt.show()\n"
      },
      {
        "id": "ex10",
        "title": "10.10 B1_Ch10_10.py",
        "filename": "B1_Ch10_10.py",
        "code": "# B1_Ch10_10.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nfrom matplotlib import pyplot as plt \nfrom sympy import plot_implicit, symbols, Eq\nx, y = symbols('x y')\n\n\ndef plot_curve(Eq_sym):\n\n    h_plot = plot_implicit(Eq_sym, (x, -3, 3), (y, -3, 3)) \n    h_plot.show()\n\n#%% plot linear, quadratic, and cubic functions\n\nplt.close('all')\n\n#%% Parabola \n\nEq_sym = Eq(x**2 - y,2)\nplot_curve(Eq_sym)\n\nEq_sym = Eq(x**2 + y,2)\nplot_curve(Eq_sym)\n\nEq_sym = Eq(x - y**2,-2)\nplot_curve(Eq_sym)\n\nEq_sym = Eq(x + y**2,2)\nplot_curve(Eq_sym)\n\n\n#%% Ellipse \n\nEq_sym = Eq(x**2/4 + y**2,1)\nplot_curve(Eq_sym)\n\nEq_sym = Eq(x**2 + y**2/4,1)\nplot_curve(Eq_sym)\n\nEq_sym = Eq(5*x**2/8 -3*x*y/4 + 5*y**2/8,1)\nplot_curve(Eq_sym)\n\nEq_sym = Eq(5*x**2/8 +3*x*y/4 + 5*y**2/8,1)\nplot_curve(Eq_sym)\n\n#%% Hyperbola \n\nEq_sym = Eq(-x**2 + y**2,1)\nplot_curve(Eq_sym)\n\nEq_sym = Eq(x**2 - y**2,1)\nplot_curve(Eq_sym)\n\nEq_sym = Eq(x*y,1)\nplot_curve(Eq_sym)\n\nEq_sym = Eq(-x*y,1)\nplot_curve(Eq_sym)\n"
      },
      {
        "id": "ex11",
        "title": "10.11 B1_Ch10_11.py",
        "filename": "B1_Ch10_11.py",
        "code": "# B1_Ch10_11.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport math\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib import cm\n\ndef mesh_square(x0,y0,r,num):\n    \n    # generate mesh using polar coordinates\n \n    rr = np.linspace(-r,r,num)\n    xx,yy = np.meshgrid(rr,rr);\n \n    xx = xx + x0; \n    yy = yy + y0;\n    \n    return xx, yy\n\ndef plot_surf(xx,yy,zz,caption):\n\n    norm_plt = plt.Normalize(zz.min(), zz.max())\n    colors = cm.coolwarm(norm_plt(zz))\n\n    fig = plt.figure()\n    ax = fig.add_subplot(111, projection='3d')\n    surf = ax.plot_surface(xx,yy,zz,\n    facecolors=colors, shade=False)\n    surf.set_facecolor((0,0,0,0))\n    # z_lim = [zz.min(),zz.max()]\n    # ax.plot3D([0,0],[0,0],z_lim,'k')\n    plt.show()\n\n    plt.tight_layout()\n    ax.set_xlabel('$\\it{x}$')\n    ax.set_ylabel('$\\it{y}$')\n    ax.set_zlabel('$\\it{f}$($\\it{x}$,$\\it{y}$)')\n    ax.set_title(caption)\n\n\n    ax.xaxis._axinfo[\"grid\"].update({\"linewidth\":0.25, \"linestyle\" : \":\"})\n    ax.yaxis._axinfo[\"grid\"].update({\"linewidth\":0.25, \"linestyle\" : \":\"})\n    ax.zaxis._axinfo[\"grid\"].update({\"linewidth\":0.25, \"linestyle\" : \":\"})\n\n    plt.rcParams[\"font.family\"] = \"Times New Roman\"\n    plt.rcParams[\"font.size\"] = \"10\"\n\ndef plot_contourf(xx,yy,zz,caption):\n    \n    fig, ax = plt.subplots()\n\n    cntr2 = ax.contourf(xx,yy,zz, levels = 15, cmap=\"RdBu_r\")\n\n    fig.colorbar(cntr2, ax=ax)\n    plt.show()\n\n    ax.set_xlabel('$\\it{x}$')\n    ax.set_ylabel('$\\it{y}$')\n\n    ax.set_title(caption)\n    ax.grid(linestyle='--', linewidth=0.25, color=[0.5,0.5,0.5])\n    \n#%% initialization\n\nx0  = 0;  # center of the mesh\ny0  = 0;  # center of the mesh\nr   = 2;  # radius of the mesh\nnum = 30; # number of mesh grids\nxx,yy = mesh_square(x0,y0,r,num); # generate mesh\n\n#%% f(x,y) = y\nplt.close('all')\n\nzz1 = yy;\ncaption = '$\\it{f} = \\it{y}$';\nplot_surf (xx,yy,zz1,caption)\nplot_contourf (xx,yy,zz1,caption)\n\n#%% f(x,y) = -x\n\nzz1 = -xx;\ncaption = '$\\it{f} = -\\it{x}$';\nplot_surf (xx,yy,zz1,caption)\nplot_contourf (xx,yy,zz1,caption)\n\n#%% f(x,y) = x + y\n\nzz1 = xx + yy;\ncaption = '$\\it{f} = \\it{x} + \\it{y}$';\nplot_surf (xx,yy,zz1,caption)\nplot_contourf (xx,yy,zz1,caption)\n\n#%% f(x,y) = -x + y\n\nzz1 = -xx + yy;\ncaption = '$\\it{f} = -\\it{x} + \\it{y}$';\nplot_surf (xx,yy,zz1,caption)\nplot_contourf (xx,yy,zz1,caption)\n"
      },
      {
        "id": "ex12",
        "title": "10.12 B1_Ch10_12.py",
        "filename": "B1_Ch10_12.py",
        "code": "# B1_Ch10_12.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport math\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib import cm\n\ndef mesh_circ(x0,y0,r,num):\n    \n    # generate mesh using polar coordinates\n \n    theta = np.linspace(0,2*math.pi,num)\n    r = np.linspace(0,r,num);\n\n    theta_matrix,r_matrix = np.meshgrid(theta,r);\n \n    xx = np.multiply(np.cos(theta_matrix), r_matrix) + x0; \n    yy = np.multiply(np.sin(theta_matrix), r_matrix) + y0;\n    \n    return xx, yy\n\ndef plot_surf(xx,yy,zz,caption):\n\n    norm_plt = plt.Normalize(zz.min(), zz.max())\n    colors = cm.coolwarm(norm_plt(zz))\n\n    fig = plt.figure()\n    ax = fig.add_subplot(111, projection='3d')\n    surf = ax.plot_surface(xx,yy,zz,\n    facecolors=colors, shade=False)\n    surf.set_facecolor((0,0,0,0))\n    # z_lim = [zz.min(),zz.max()]\n    # ax.plot3D([0,0],[0,0],z_lim,'k')\n    plt.show()\n\n    plt.tight_layout()\n    ax.set_xlabel('$\\it{x}$')\n    ax.set_ylabel('$\\it{y}$')\n    ax.set_zlabel('$\\it{f}$($\\it{x}$,$\\it{y}$)')\n    ax.set_title(caption)\n\n\n    ax.xaxis._axinfo[\"grid\"].update({\"linewidth\":0.25, \"linestyle\" : \":\"})\n    ax.yaxis._axinfo[\"grid\"].update({\"linewidth\":0.25, \"linestyle\" : \":\"})\n    ax.zaxis._axinfo[\"grid\"].update({\"linewidth\":0.25, \"linestyle\" : \":\"})\n\n    plt.rcParams[\"font.family\"] = \"Times New Roman\"\n    plt.rcParams[\"font.size\"] = \"10\"\n\ndef plot_contourf(xx,yy,zz,caption):\n    \n    fig, ax = plt.subplots()\n\n    cntr2 = ax.contourf(xx,yy,zz, levels = 15, cmap=\"RdBu_r\")\n\n    fig.colorbar(cntr2, ax=ax)\n    plt.show()\n\n    ax.set_xlabel('$\\it{x}$')\n    ax.set_ylabel('$\\it{y}$')\n\n    ax.set_title(caption)\n    ax.grid(linestyle='--', linewidth=0.25, color=[0.5,0.5,0.5])\n    \n#%% initialization\n\nx0  = 0;  # center of the mesh\ny0  = 0;  # center of the mesh\nr   = 2;  # radius of the mesh\nnum = 30; # number of mesh grids\nxx,yy = mesh_circ(x0,y0,r,num); # generate mesh\n\n#%% f(x,y) = x^2 + y^2, circular paraboloid\nplt.close('all')\n\nzz1 = np.multiply(xx, xx) + np.multiply(yy, yy);\ncaption = '$\\it{f} = \\it{x}^2 + \\it{y}^2$';\nplot_surf (xx,yy,zz1,caption)\nplot_contourf (xx,yy,zz1,caption)\n\n#%% f(x,y) = - x^2 - y^2, circular paraboloid\n\nzz1 = -np.multiply(xx, xx) - np.multiply(yy, yy);\ncaption = '$\\it{f} = -\\it{x}^2 - \\it{y}^2$';\nplot_surf (xx,yy,zz1,caption)\nplot_contourf (xx,yy,zz1,caption)\n\n#%% f(x,y) = (x^2 + y^2)^(1/2), circular cone\n\nzz1 = np.sqrt(np.multiply(xx, xx) + np.multiply(yy, yy));\ncaption = '$\\it{f} = (\\it{x}^2 + \\it{y}^2)^{1/2}$';\nplot_surf (xx,yy,zz1,caption)\nplot_contourf (xx,yy,zz1,caption)\n\n#%% f(x,y) = -(x^2 + y^2)^(1/2), circular cone\n\nzz1 = -np.sqrt(np.multiply(xx, xx) + np.multiply(yy, yy));\ncaption = '$\\it{f} = -(\\it{x}^2 + \\it{y}^2)^{1/2}$';\nplot_surf (xx,yy,zz1,caption)\nplot_contourf (xx,yy,zz1,caption)\n\n#%% f(x,y) = x^2 + xy + y^2, elliptic paraboloid\n\nzz1 = np.multiply(xx, xx) + np.multiply(xx, yy) + np.multiply(yy, yy);\ncaption = '$\\it{f} = \\it{x}^2 + \\it{xy} + \\it{y}^2$';\nplot_surf (xx,yy,zz1,caption)\nplot_contourf (xx,yy,zz1,caption)\n\n#%% f(x,y) = - x^2 + xy - y^2, elliptic paraboloid\n\nzz1 = -np.multiply(xx, xx) + np.multiply(xx, yy) - np.multiply(yy, yy);\ncaption = '$\\it{f} = -\\it{x}^2 + \\it{xy} - \\it{y}^2$';\nplot_surf (xx,yy,zz1,caption)\nplot_contourf (xx,yy,zz1,caption)\n\n#%% f(x,y) = x^2 - y^2, hyperbolic paraboloid, saddle surface\n\nzz1 = np.multiply(xx, xx) - np.multiply(yy, yy);\ncaption = '$\\it{f} = \\it{x}^2 - \\it{y}^2$';\nplot_surf (xx,yy,zz1,caption)\nplot_contourf (xx,yy,zz1,caption)\n\n#%% f(x,y) = x*y, hyperbolic paraboloid, saddle surface\n\nzz1 = np.multiply(xx, yy);\ncaption = '$\\it{f} = \\it{xy}$';\nplot_surf (xx,yy,zz1,caption)\nplot_contourf (xx,yy,zz1,caption)\n\n#%% f(x,y) = x^2, valley surface\n\nzz1 = np.multiply(xx, xx);\ncaption = '$\\it{f} = \\it{x}^2$';\nplot_surf (xx,yy,zz1,caption)\nplot_contourf (xx,yy,zz1,caption)\n\n#%% f(x,y) = -x^2/2 + xy - y^2/2, ridge surface\n\nzz1 = -np.multiply(xx, xx)/2.0 + np.multiply(xx, yy) - np.multiply(yy, yy)/2.0;\ncaption = '$\\it{f} = -\\it{x}^2/2 + \\it{xy} - \\it{y}^2/2$';\nplot_surf (xx,yy,zz1,caption)\nplot_contourf (xx,yy,zz1,caption)\n"
      }
    ]
  },
  {
    "id": "b1_ch11",
    "title": "第11章：金融計算 II",
    "number": 11,
    "content": {
      "intro": {
        "title": "第 11 章：金融計算 II - 詳解",
        "roadmap": {
          "guide": "",
          "objectives": "進入高級量化建模與優化領域。掌握泰勒展開式在風險敏感度分析中的應用，並實作馬可維茲（Markowitz）資產組合優化，尋找效率前緣（Efficient Frontier）。",
          "topics": "*   11.1 多元函數分析基礎\n*   11.2 極限概念\n*   11.3 導數 (Derivative) 與變動率\n*   11.4 偏導數 (Partial Derivative)\n*   11.5 連鎖律 (Chain Rule) 與誤差分析\n*   11.6 泰勒展開 (Taylor Expansion)\n*   11.7 數值微分實作\n*   11.8 最佳化演算法 (Optimization)\n*   11.9 多目標最佳化初步"
        },
        "value": {
          "practical": "*   **實務場景**：資產管理公司的投資組合動態再平衡（Rebalancing）。\n*   **考試重點**：效率前緣的概念、切線矩陣及風險分散的邊際貢獻。",
          "theory": "*   **泰勒展開與風險敏感度**：金融產品價格 $\\Delta P \\approx \\Delta \\times \\Delta S + \\frac{1}{2}\\Gamma \\times (\\Delta S)^2$。這就是微積分在風險度量中的直接體現。\n*   **現代投資組合論 (MPT)**：理解在給定風險水平下如何最大化收益。這涉及到二次規劃（Quadratic Programming）的數學背景。",
          "further_reading": "*   Black-Litterman 模型：結合市場意見的進階資產配置思維。"
        },
        "implementation": {
          "python": "*   **最佳化引擎**：使用 `scipy.optimize.minimize` 調配上百種資產的權重，使波動率最小化。\n*   **敏感度自動化**：透過代碼快速計算複雜產品的 Delta 與 Gamma。",
          "logic": "*   `minimize(objective_func, constraints)`：風險管理的核心——在約束條件下尋找最優權重。\n*   二次規劃模型建構。",
          "scenarios": "| 腳本名稱 | 核心使命 |\n| :--- | :--- |\n| **B1_Ch11_1.py** | 實作 Black-Scholes 期權定價模型，計算歐式買權價格。 |\n| **B1_Ch11_2.py** | 演示希臘字母 Delta 的計算及其在對沖策略中的應用。 |\n| **B1_Ch11_3.py** | 實作隱含波動率 (Implied Volatility) 的二分法搜尋算法。 |\n| **B1_Ch11_4.py** | 演示波動率微笑 (Volatility Smile) 的截面展示。 |\n| **B1_Ch11_5.py** | 實作二項樹 (Binomial Tree) 模型進行美式期權定價。 |\n| **B1_Ch11_6.py** | 演示蒙地卡羅模擬在奇異期權 (Exotic Options) 定價中的原型。 |\n| **B1_Ch11_7.py** | 實作 Gamma 與 Vega 的風險邊際貢獻分析。 |\n| **B1_Ch11_8.py** | 演示期權組合的損益圖表 (Payoff Diagram) 繪製。 |\n| **B1_Ch11_9.py** | 實作標的資產價格路徑的幾何布朗運動 (GBM) 模擬。 |\n| **B1_Ch11_10.py** | 利用 SciPy 優化最小化投資組合變異數 (Portfolio Variance) 並視覺化等高線圖。 |\n| **B1_Ch11_11.py** | 利用 NSGA-II 多目標優化算法求解 Pareto 前沿與效率前緣 (Efficient Frontier)。 |"
        },
        "body": "### 11.1 多元函數分析基礎\n\n#### 概念定義\n多元函數 $f(x_1, x_2, ..., x_n)$ 的值取決於多個自變數。\n金融中常見：\n- 期權價格 = $f(S, K, r, T, \\sigma)$\n- 組合變異數 = $f(w_1, w_2, ..., w_n)$\n\n#### 財金理論背景\n金融資產受多重因子驅動：\n- 利率、匯率、股價、波動率同時影響結構型產品\n- 投資組合的風險取決於所有權重的組合\n\n#### Python 實現邏輯\n```python\nimport numpy as np\nfrom scipy.stats import norm\n\n# 多變數函數：BS 期權價格\ndef bs_call(S, K, r, T, sigma):\n    d1 = (np.log(S/K) + (r + 0.5*sigma**2)*T) / (sigma*np.sqrt(T))\n    d2 = d1 - sigma*np.sqrt(T)\n    return S * norm.cdf(d1) - K * np.exp(-r*T) * norm.cdf(d2)\n\n# 投資組合變異數\ndef portfolio_variance(weights, cov_matrix):\n    return np.dot(weights.T, np.dot(cov_matrix, weights))\n```\n\n#### 常見陷阱與注意事項\n- **維度災難**：高維空間的直覺可能失效\n- **相關性**：多變數通常不獨立\n- **梯度方向**：需向量化計算\n\n#### 實務應用場景\n- 衍生品定價的多因子模型\n- 投資組合最佳化\n- 多因子風險歸因\n\n#### 與其他章節的關聯\n多元函數是 Ch11.4 偏導數和 Ch11.8 最佳化的基礎。\n\n---\n\n### 11.2 極限概念\n\n#### 概念定義\n極限描述函數當自變數趨近某值時的行為：\n$$\n\\lim_{x \\to a} f(x) = L\n$$\n\n#### 財金理論背景\n極限在金融中的應用：\n- 連續複利 = $\\lim_{m \\to \\infty} (1 + r/m)^m$\n- 永續年金 = 有限現金流的極限\n- 導數定義\n\n#### 數學公式或模型\n連續複利：\n$$\n\\lim_{m \\to \\infty} \\left(1 + \\frac{r}{m}\\right)^m = e^r\n$$\n\n#### Python 實現邏輯\n```python\nimport numpy as np\n\n# 連續複利的極限驗證\nr = 0.10\nm_values = [1, 2, 4, 12, 52, 365, 1000, 10000]\nfor m in m_values:\n    compound = (1 + r/m)**m\n    print(f\"m={m:5d}: {compound:.6f}\")\n\nprint(f\"連續複利: {np.exp(r):.6f}\")  # e^0.10 = 1.105171\n```\n\n#### 常見陷阱與注意事項\n- **數值精度**：極大 m 可能有浮點誤差\n- **極限存在性**：非所有函數都有極限\n- **洛必達法則**：處理 0/0 型不定式\n\n#### 實務應用場景\n- 連續複利的理論推導\n- 長期現金流的收斂性\n- 衍生品定價的連續假設\n\n#### 與其他章節的關聯\n極限是 Ch11.3 導數定義的數學基礎。\n\n---\n\n### 11.3 導數 (Derivative) 與變動率\n\n#### 概念定義\n導數是函數的瞬間變化率：\n$$\nf'(x) = \\lim_{h \\to 0} \\frac{f(x+h) - f(x)}{h}\n$$\n\n幾何意義：切線斜率。\n\n#### 財金理論背景\n導數對應金融中的敏感度：\n- **Duration**：債券價格對利率的導數\n- **Delta**：期權價格對標的價格的導數\n- **邊際效用**：效用函數的導數\n\n#### 數學公式或模型\nDuration 公式：\n$$\nD = -\\frac{1}{P} \\frac{dP}{dy}\n$$\n\n#### Python 實現邏輯\n```python\nimport numpy as np\nfrom scipy.misc import derivative\n\n# 解析導數\ndef bond_price(y, C=5, n=4, FV=100):\n    cf = np.array([C]*n + [FV])\n    cf[-1] += C  # 最後一期還本+利息\n    periods = np.arange(1, n+2)\n    return np.sum(cf / (1+y)**periods)\n\ndef bond_duration_analytical(y, C=5, n=4, FV=100):\n    P = bond_price(y, C, n, FV)\n    dP_dy = derivative(bond_price, y, dx=1e-6)\n    return -dP_dy / P\n\n# 數值導數\nP = bond_price(0.05)\ndP = derivative(bond_price, 0.05, dx=1e-6)\nprint(f\"價格: {P:.2f}, dP/dy: {dP:.2f}\")\n```\n\n#### 常見陷阱與注意事項\n- **步長選擇**：太大不精確，太小有數值誤差\n- **不連續點**：期權 Payoff 在 K 處不可微\n- **高階導數**：二階導數對應凸性\n\n#### 實務應用場景\n- 計算 Duration 和 Greeks\n- 風險因子敏感度分析\n- 對沖比例計算\n\n#### 與其他章節的關聯\n導數是 Ch11.4 偏導數的一維特例，用於 Ch12 Duration 計算。\n\n---\n\n### 11.4 偏導數 (Partial Derivative)\n\n#### 概念定義\n保持其他變數不變，對單一變數求導：\n$$\n\\frac{\\partial f}{\\partial x_i} = \\lim_{h \\to 0} \\frac{f(x_1, ..., x_i+h, ..., x_n) - f(...)}{h}\n$$\n\n#### 財金理論背景\n期權 Greeks 就是偏導數：\n- $\\Delta = \\frac{\\partial C}{\\partial S}$\n- $\\Gamma = \\frac{\\partial^2 C}{\\partial S^2}$\n- $\\Theta = \\frac{\\partial C}{\\partial t}$\n- $\\text{Vega} = \\frac{\\partial C}{\\partial \\sigma}$\n- $\\rho = \\frac{\\partial C}{\\partial r}$\n\n#### 數學公式或模型\nBlack-Scholes Delta：\n$$\n\\Delta_{call} = N(d_1)\n$$\n\n#### Python 實現邏輯\n```python\nfrom scipy.stats import norm\nimport numpy as np\n\ndef bs_greeks(S, K, r, T, sigma, option_type='call'):\n    d1 = (np.log(S/K) + (r + 0.5*sigma**2)*T) / (sigma*np.sqrt(T))\n    d2 = d1 - sigma*np.sqrt(T)\n    \n    # Delta\n    delta = norm.cdf(d1) if option_type == 'call' else norm.cdf(d1) - 1\n    \n    # Gamma\n    gamma = norm.pdf(d1) / (S * sigma * np.sqrt(T))\n    \n    # Vega (per 1% change)\n    vega = S * norm.pdf(d1) * np.sqrt(T) / 100\n    \n    # Theta (per day)\n    theta = (-(S * norm.pdf(d1) * sigma) / (2 * np.sqrt(T)) \n             - r * K * np.exp(-r*T) * norm.cdf(d2)) / 365\n    \n    # Rho (per 1% change)\n    rho = K * T * np.exp(-r*T) * norm.cdf(d2) / 100\n    \n    return {'delta': delta, 'gamma': gamma, 'vega': vega, \n            'theta': theta, 'rho': rho}\n```\n\n#### 常見陷阱與注意事項\n- **單位不同**：Vega 常以 1% 波動率報價\n- **符號慣例**：Theta 通常為負（時間價值損耗）\n- **Gamma 風險**：ATM 期權 Gamma 最大\n\n#### 實務應用場景\n- Delta 對沖\n- Greeks 風險限額\n- 期權交易策略分析\n\n#### 與其他章節的關聯\n偏導數計算用於 Ch11.5 連鎖律的敏感度傳導。\n\n---\n\n### 11.5 連鎖律 (Chain Rule) 與誤差分析\n\n#### 概念定義\n複合函數的微分法則：\n$$\n\\frac{df}{dx} = \\frac{df}{dg} \\cdot \\frac{dg}{dx}\n$$\n\n多變數版本（全微分）：\n$$\ndf = \\sum_i \\frac{\\partial f}{\\partial x_i} dx_i\n$$\n\n#### 財金理論背景\n風險傳導的數學基礎：\n- 宏觀因子 → 利率 → 債券價格\n- 波動率 → 期權價格 → 結構型產品\n\n誤差分析：參數估計誤差如何傳導到價值估計。\n\n#### 數學公式或模型\nDelta-Gamma 近似：\n$$\n\\Delta C \\approx \\Delta \\cdot \\Delta S + \\frac{1}{2} \\Gamma \\cdot (\\Delta S)^2\n$$\n\n#### Python 實現邏輯\n```python\nimport numpy as np\n\n# 期權價格變動的近似\ndef delta_gamma_approx(delta, gamma, dS):\n    return delta * dS + 0.5 * gamma * dS**2\n\n# 完整 Greeks 近似\ndef option_pnl_approx(greeks, dS, dsigma, dt):\n    pnl = (greeks['delta'] * dS + \n           0.5 * greeks['gamma'] * dS**2 +\n           greeks['vega'] * dsigma +\n           greeks['theta'] * dt)\n    return pnl\n\n# 驗證\ndS = 2  # 股價上漲 2\ndelta, gamma = 0.6, 0.05\napprox = delta_gamma_approx(delta, gamma, dS)\nprint(f\"近似價格變動: {approx:.2f}\")\n```\n\n#### 常見陷阱與注意事項\n- **高階項**：大變動時需加入更高階項\n- **交叉項**：多因子變動時有交互效應\n- **線性化誤差**：非線性產品近似誤差大\n\n#### 實務應用場景\n- 風險因子敏感度分解\n- P&L 歸因分析\n- 參數估計的誤差傳導\n\n#### 與其他章節的關聯\n連鎖律是 Ch11.6 泰勒展開的數學基礎。\n\n---\n\n### 11.6 泰勒展開 (Taylor Expansion)\n\n#### 概念定義\n將函數在某點展開為多項式級數：\n$$\nf(x) = f(a) + f'(a)(x-a) + \\frac{f''(a)}{2!}(x-a)^2 + ...\n$$\n\n#### 財金理論背景\n風險度量的核心工具：\n- **Delta-Gamma 近似**：期權價格的二階展開\n- **Duration-Convexity**：債券價格的二階展開\n- 這些近似簡化了複雜非線性的風險計算\n\n#### 數學公式或模型\n債券價格變動：\n$$\n\\frac{\\Delta P}{P} \\approx -D \\cdot \\Delta y + \\frac{1}{2} C \\cdot (\\Delta y)^2\n$$\n\n#### Python 實現邏輯\n```python\nimport numpy as np\n\ndef taylor_bond_price_change(D, C, dy):\n    \"\"\"用 Duration-Convexity 近似債券價格變動\"\"\"\n    return -D * dy + 0.5 * C * dy**2\n\n# 範例\nD = 4.5  # Modified Duration\nC = 25   # Convexity\ndy = 0.01  # 利率上升 1%\n\n# 近似\napprox_change = taylor_bond_price_change(D, C, dy)\nprint(f\"價格變動近似: {approx_change:.4%}\")\n\n# 只用 Duration\nlinear_approx = -D * dy\nprint(f\"線性近似: {linear_approx:.4%}\")\nprint(f\"凸性修正: {0.5 * C * dy**2:.4%}\")\n```\n\n#### 常見陷阱與注意事項\n- **收斂半徑**：展開點太遠可能不收斂\n- **項數選擇**：更多項更精確但更複雜\n- **符號慣例**：Duration 的負號處理\n\n#### 實務應用場景\n- 快速估算利率/股價變動的影響\n- 風險限額的簡化計算\n- 對沖比例的近似\n\n#### 與其他章節的關聯\n泰勒展開用於 Ch12 Duration-Convexity 近似。\n\n---\n\n### 11.7 數值微分實作\n\n#### 概念定義\n當解析導數不可得時，用數值方法近似：\n- **前向差分**：$f'(x) \\approx \\frac{f(x+h) - f(x)}{h}$\n- **後向差分**：$f'(x) \\approx \\frac{f(x) - f(x-h)}{h}$\n- **中心差分**：$f'(x) \\approx \\frac{f(x+h) - f(x-h)}{2h}$\n\n#### 財金理論背景\n複雜衍生品難以推導解析 Greeks：\n- 路徑依賴期權\n- Monte Carlo 定價的敏感度\n- 複雜結構型產品\n\n#### Python 實現邏輯\n```python\nimport numpy as np\n\ndef numerical_derivative(f, x, h=1e-5, method='central'):\n    if method == 'forward':\n        return (f(x + h) - f(x)) / h\n    elif method == 'backward':\n        return (f(x) - f(x - h)) / h\n    else:  # central\n        return (f(x + h) - f(x - h)) / (2 * h)\n\ndef numerical_second_derivative(f, x, h=1e-4):\n    return (f(x + h) - 2*f(x) + f(x - h)) / h**2\n\n# 範例：數值 Delta 和 Gamma\ndef option_price(S, K=100, r=0.05, T=0.5, sigma=0.2):\n    from scipy.stats import norm\n    d1 = (np.log(S/K) + (r + 0.5*sigma**2)*T) / (sigma*np.sqrt(T))\n    d2 = d1 - sigma*np.sqrt(T)\n    return S*norm.cdf(d1) - K*np.exp(-r*T)*norm.cdf(d2)\n\nS = 100\ndelta_num = numerical_derivative(lambda s: option_price(s), S)\ngamma_num = numerical_second_derivative(lambda s: option_price(s), S)\nprint(f\"數值 Delta: {delta_num:.4f}\")\nprint(f\"數值 Gamma: {gamma_num:.4f}\")\n```\n\n#### 常見陷阱與注意事項\n- **步長選擇**：$h \\approx \\sqrt{\\epsilon_{machine}} \\times x$ 最優\n- **數值誤差**：太小的 h 會有捨入誤差\n- **效率**：每計算一個導數需多次函數求值\n\n#### 實務應用場景\n- 複雜期權的 Greeks 計算\n- Monte Carlo 敏感度分析\n- 模型校準的雅可比矩陣\n\n#### 與其他章節的關聯\n數值微分用於 Ch11.8 最佳化的梯度計算。\n\n---\n\n### 11.8 最佳化演算法 (Optimization)\n\n#### 概念定義\n尋找使目標函數達到極值的參數：\n$$\n\\min_\\mathbf{w} f(\\mathbf{w}) \\quad \\text{s.t.} \\quad g(\\mathbf{w}) \\leq 0\n$$\n\n常用算法：\n- 梯度下降\n- 牛頓法\n- 約束最佳化（SLSQP, COBYLA）\n\n#### 財金理論背景\n投資組合最佳化的核心：\n- **Markowitz 模型**：給定報酬最小化變異數\n- **Sharpe Ratio 最大化**\n- **風險平價**\n\n#### 數學公式或模型\n最小變異數：\n$$\n\\min_\\mathbf{w} \\mathbf{w}^T \\Sigma \\mathbf{w} \\quad \\text{s.t.} \\quad \\sum w_i = 1, \\quad \\mathbf{w}^T \\mu \\geq \\mu_{target}\n$$\n\n#### Python 實現邏輯\n```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\n# 輸入數據\nreturns = np.array([0.10, 0.08, 0.12])\ncov_matrix = np.array([[0.04, 0.01, 0.02],\n                       [0.01, 0.03, 0.01],\n                       [0.02, 0.01, 0.05]])\n\ndef portfolio_variance(w):\n    return np.dot(w.T, np.dot(cov_matrix, w))\n\ndef portfolio_return(w):\n    return np.dot(w, returns)\n\n# 約束\nconstraints = [\n    {'type': 'eq', 'fun': lambda w: np.sum(w) - 1},  # 權重和為 1\n    {'type': 'ineq', 'fun': lambda w: portfolio_return(w) - 0.09}  # 報酬 >= 9%\n]\n\n# 邊界 (禁止賣空)\nbounds = [(0, 1) for _ in range(len(returns))]\n\n# 優化\nresult = minimize(portfolio_variance, x0=[1/3]*3, \n                  method='SLSQP', bounds=bounds, constraints=constraints)\nprint(f\"最優權重: {result.x}\")\nprint(f\"組合變異數: {result.fun:.4f}\")\n```\n\n#### 常見陷阱與注意事項\n- **局部最優**：非凸問題可能有多個極值\n- **約束違反**：數值解可能略違約束\n- **初始值**：不同起點可能得不同解\n\n#### 實務應用場景\n- Markowitz 投資組合最佳化\n- 模型參數校準\n- 對沖成本最小化\n\n#### 與其他章節的關聯\n最佳化用於 Ch11.9 多目標和效率前緣構建。\n\n---\n\n### 11.9 多目標最佳化初步\n\n#### 概念定義\n同時優化多個相互衝突的目標：\n$$\n\\min \\{f_1(\\mathbf{x}), f_2(\\mathbf{x}), ..., f_k(\\mathbf{x})\\}\n$$\n\n**Pareto 最優**：無法在改善一個目標的同時不惡化另一個。\n\n#### 財金理論背景\n**效率前緣 (Efficient Frontier)**：\n- 給定風險下的最大報酬\n- 給定報酬下的最小風險\n- 所有 Pareto 最優組合的集合\n\n#### Python 實現邏輯\n```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport matplotlib.pyplot as plt\n\ndef compute_efficient_frontier(returns, cov_matrix, n_points=50):\n    n_assets = len(returns)\n    \n    # 目標報酬範圍\n    min_ret = min(returns)\n    max_ret = max(returns)\n    target_returns = np.linspace(min_ret, max_ret, n_points)\n    \n    results = []\n    for target in target_returns:\n        constraints = [\n            {'type': 'eq', 'fun': lambda w: np.sum(w) - 1},\n            {'type': 'eq', 'fun': lambda w, t=target: np.dot(w, returns) - t}\n        ]\n        bounds = [(0, 1) for _ in range(n_assets)]\n        \n        result = minimize(\n            lambda w: np.sqrt(np.dot(w.T, np.dot(cov_matrix, w))),\n            x0=[1/n_assets]*n_assets,\n            method='SLSQP', bounds=bounds, constraints=constraints\n        )\n        \n        if result.success:\n            results.append((result.fun, target, result.x))\n    \n    return results\n\n# 繪製效率前緣\nfrontier = compute_efficient_frontier(returns, cov_matrix)\nvols = [r[0] for r in frontier]\nrets = [r[1] for r in frontier]\n\nplt.plot(vols, rets, 'b-', linewidth=2)\nplt.xlabel('Volatility')\nplt.ylabel('Expected Return')\nplt.title('Efficient Frontier')\n```\n\n#### 常見陷阱與注意事項\n- **計算成本**：需求解多個單目標問題\n- **數值穩定**：邊界點可能不穩定\n- **隱含假設**：Markowitz 假設正態分佈\n\n#### 實務應用場景\n- 戰略資產配置\n- 風險預算設定\n- ESG 投資的收益-影響權衡\n\n#### 與其他章節的關聯\n多目標最佳化生成的效率前緣可用 Ch7 視覺化展示。"
      }
    },
    "examples": [
      {
        "id": "ex1",
        "title": "11.1 B1_Ch11_1.py",
        "filename": "B1_Ch11_1.py",
        "code": "# B1_Ch11_1.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport math\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom scipy.stats import norm\nfrom mpl_toolkits.mplot3d import axes3d\nimport matplotlib.tri as tri\nfrom matplotlib.font_manager import FontProperties\n\nfont = FontProperties()\nfont.set_family('serif')\nfont.set_name('Times New Roman')\nfont.set_size(8)\n\n# Delta of European option\n\ndef blsprice(St, K, tau, r, vol, q):\n    '''\n    St: current price of underlying asset\n    K:  strike price\n    tau: time to maturity\n    r: annualized risk-free rate\n    vol: annualized asset price volatility\n    '''\n    \n    d1 = (math.log(St / K) + (r - q + 0.5 * vol ** 2)\\\n          *tau) / (vol * math.sqrt(tau));\n    d2 = d1 - vol*math.sqrt(tau);\n    \n    Call = norm.cdf(d1, loc=0, scale=1)*St*math.exp(-q*tau) - \\\n        norm.cdf(d2, loc=0, scale=1)*K*math.exp(-r*tau)\n        \n    Put  = -norm.cdf(-d1, loc=0, scale=1)*St*math.exp(-q*tau) + \\\n        norm.cdf(-d2, loc=0, scale=1)*K*math.exp(-r*tau)\n        \n    return Call, Put\n\ndef plot_curve(S_array,Call_array,Put_array,S,Call0,Put0,text):\n    \n    fig, axs = plt.subplots(1,2)\n\n    axs[0].plot(S_array, Call_array)\n    axs[0].plot(S, Call0,'rx', markersize = 12)\n    x_label = '$\\it{' + text + '}$'\n    axs[0].set_xlabel(x_label, fontname=\"Times New Roman\", fontsize=8)\n    y_label = '$\\it{C}$($\\it{' + text + '}$)'\n    axs[0].set_ylabel(y_label, family=\"Times New Roman\", fontsize=8)\n    axs[0].grid(linestyle='--', linewidth=0.25, color=[0.5,0.5,0.5])\n\n    axs[1].plot(S_array, Put_array)\n    axs[1].plot(S, Put0,'rx', markersize = 12)\n    axs[1].set_xlabel(x_label, family=\"Times New Roman\", fontsize=8)\n    y_label = '$\\it{P}$($\\it{' + text + '}$)'\n    axs[1].set_ylabel(y_label, fontname=\"Times New Roman\", fontsize=8)\n    axs[1].grid(linestyle='--', linewidth=0.25, color=[0.5,0.5,0.5])\n\n# end of function\n\nblsprice_vec = np.vectorize(blsprice)\n\nS = 50;    # spot price\nS_array  = np.linspace(20,80,26);\n\nK = 50;    # strike price\nK_array  = np.linspace(20,80,26);\n\nr = 0.03;  # risk-free rate\nr_array  = np.linspace(0.01,0.05,26);\n\nvol = 0.5; # volatility \nvol_array  = np.linspace(0.01,0.9,26);\n\nq = 0;     # continuously compounded yield of the underlying asset\nq_array  = np.linspace(0,0.02,26);\n\ntau = 1;     # time to maturity\ntau_array  = np.linspace(0.1,1,26);\n\nCall0, Put0 = blsprice_vec(S, K, tau, r, vol, q)\n\n#%% option vs S\n\nplt.close('all')\n\nCall_array, Put_array = blsprice_vec(S_array, K, tau, r, vol, q)\n\nplot_curve(S_array,Call_array,Put_array,S,Call0,Put0,'S')\n\n#%% option vs K\n\nCall_array, Put_array = blsprice_vec(S, K_array, tau, r, vol, q)\n\nplot_curve(K_array,Call_array,Put_array,K,Call0,Put0,'K')\n\n#%% option vs tau, time to maturity\n\nCall_array, Put_array = blsprice_vec(S, K, tau_array, r, vol, q)\n\nplot_curve(tau_array,Call_array,Put_array,tau,Call0,Put0,'\\u03C4')\n\n#%% option vs r, risk-free rate\n\nCall_array, Put_array = blsprice_vec(S, K, tau, r_array, vol, q)\n\nplot_curve(r_array,Call_array,Put_array,r,Call0,Put0,'r')\n\n#%% option vs vol\n\nCall_array, Put_array = blsprice_vec(S, K, tau, r, vol_array, q)\n\nplot_curve(vol_array,Call_array,Put_array,vol,Call0,Put0,'\\sigma')\n\n#%% option vs q, continuous dividend\n\nCall_array, Put_array = blsprice_vec(S, K, tau, r, vol, q_array)\n\nplot_curve(q_array,Call_array,Put_array,q,Call0,Put0,'q')\n"
      },
      {
        "id": "ex2",
        "title": "11.2 B1_Ch11_2.py",
        "filename": "B1_Ch11_2.py",
        "code": "# B1_Ch11_2.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nfrom sympy import latex, lambdify, limit, log\nfrom sympy.abc import x\nimport numpy as np\nfrom matplotlib import pyplot as plt \n\nf_x = log(x + 1)/x\n\nx_array = np.linspace(-0.8,2,100)\n\nf_x_fcn = lambdify(x,f_x)\nf_x_array = f_x_fcn(x_array)\n\nf_x_0_limit = limit(f_x,x,0)\n\nf_x_array = f_x_fcn(x_array)\n\n#%% visualization\n\nplt.close('all')\n\nfig, ax = plt.subplots()\n\nax.plot(x_array, f_x_array, linewidth = 1.5) \nax.axhline(y = f_x_0_limit, color = 'r')\nax.plot(0,f_x_0_limit, color = 'r', marker = 'x', markersize = 12)\nax.grid(linestyle='--', linewidth=0.25, color=[0.5,0.5,0.5])\nax.set_xlim(x_array.min(),x_array.max())\n\nax.set_xlabel('$\\it{x}$',fontname = 'Times New Roman')\nax.set_ylabel('$%s$' % latex(f_x), fontname = 'Times New Roman')\n"
      },
      {
        "id": "ex3",
        "title": "11.3 B1_Ch11_3.py",
        "filename": "B1_Ch11_3.py",
        "code": "# B1_Ch11_3.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nfrom sympy import latex, lambdify, diff, sin\nfrom sympy.abc import x\nimport numpy as np\nfrom matplotlib import pyplot as plt \n\n\n# f_x = x**2 - 2\nf_x = x**3/3 - x/3\n# f_x = sin(x)\n\nx_array = np.linspace(-2,2,100)\nf_x.evalf(subs = {x: 0})\n\nf_x_fcn = lambdify(x,f_x)\nf_x_array = f_x_fcn(x_array)\n\n#%% 1st and 2nd order derivatives\n\nf_x_1_diff = diff(f_x,x)\nf_x_1_diff_fcn = lambdify(x,f_x_1_diff)\n\nf_x_1_diff_array = f_x_1_diff_fcn(x_array)\n\nf_x_2_diff = diff(f_x,x,2)\nf_x_2_diff_fcn = lambdify(x,f_x_2_diff)\n\nf_x_2_diff_const = f_x_2_diff_fcn(x_array)\n\n#%% plot first order derivative of quadratic function\n\nplt.close('all')\n\nfig, ax = plt.subplots(2,1)\n\nax[0].plot(x_array, f_x_array, linewidth = 1.5) \nax[0].set_xlabel(\"$\\it{x}$\")\nax[0].set_ylabel('$%s$' % latex(f_x))\n\nax[0].grid(linestyle='--', linewidth=0.25, color=[0.5,0.5,0.5])\n\nax[1].plot(x_array, f_x_1_diff_array, linewidth = 1.5) \nax[1].set_xlabel(\"$\\it{x}$\")\nax[1].set_ylabel('$%s$' % latex(f_x_1_diff))\n\nax[1].grid(linestyle='--', linewidth=0.25, color=[0.5,0.5,0.5])\nx_lim = ax[1].get_xlim()\n"
      },
      {
        "id": "ex4",
        "title": "11.4 B1_Ch11_4.py",
        "filename": "B1_Ch11_4.py",
        "code": "# B1_Ch11_4.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nfrom sympy import lambdify, diff, evalf\nfrom sympy.abc import x\nimport numpy as np\nfrom matplotlib import pyplot as plt \n\n\nf_x = x**2 - 2\nf_x = x**3/3 - x/3\n# f_x = sin(x)\n\nx_array   = np.linspace(-2,2,100)\nx_0_array = np.linspace(-1.5,1.5,12)\nf_x.evalf(subs = {x: 0})\n\nf_x_fcn = lambdify(x,f_x)\nf_x_array = f_x_fcn(x_array)\n\n#%% plot tangent lines\n\nplt.close('all')\n\nf_x_1_diff = diff(f_x,x)\nf_x_1_diff_fcn = lambdify(x,f_x_1_diff)\n\nfig, ax = plt.subplots()\n\nax.plot(x_array, f_x_array, linewidth = 1.5) \nax.set_xlabel(\"$\\it{x}$\")\nax.set_ylabel(\"$\\it{f}(\\it{x})$\")\n\nfor x_0 in x_0_array:\n    \n    y_0 = f_x.evalf(subs = {x: x_0})\n    x_t_array = np.linspace(x_0-0.5, x_0+0.5, 10)\n    a = f_x_1_diff.evalf(subs = {x: x_0})\n    \n    tangent_f = a*(x - x_0) + y_0\n    \n    tangent_f_fcn = lambdify(x,tangent_f)\n    tangent_array = tangent_f_fcn(x_t_array)\n    \n    ax.plot(x_t_array, tangent_array, linewidth = 0.25, color = 'r') \n    ax.plot(x_0,y_0,marker = 'x', color = 'r')\n\nax.grid(linestyle='--', linewidth=0.25, color=[0.5,0.5,0.5])\nplt.axis('equal')\n"
      },
      {
        "id": "ex5",
        "title": "11.5 B1_Ch11_5.py",
        "filename": "B1_Ch11_5.py",
        "code": "# B1_Ch11_5.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nfrom sympy import lambdify, diff, exp, latex\nfrom sympy.abc import x, y\nimport numpy as np\nfrom matplotlib import pyplot as plt \nimport math\nfrom matplotlib import cm\n\ndef mesh_square(x0,y0,r,num):\n    \n    # generate mesh using polar coordinates\n \n    rr = np.linspace(-r,r,num)\n    xx,yy = np.meshgrid(rr,rr);\n \n    xx = xx + x0; \n    yy = yy + y0;\n    \n    return xx, yy\n\ndef plot_surf(xx,yy,zz,caption):\n\n    norm_plt = plt.Normalize(zz.min(), zz.max())\n    colors = cm.coolwarm(norm_plt(zz))\n\n    fig = plt.figure()\n    ax = fig.add_subplot(111, projection='3d')\n    surf = ax.plot_surface(xx,yy,zz,\n    facecolors=colors, shade=False)\n    surf.set_facecolor((0,0,0,0))\n    # z_lim = [zz.min(),zz.max()]\n    # ax.plot3D([0,0],[0,0],z_lim,'k')\n    plt.show()\n\n    plt.tight_layout()\n    ax.set_xlabel('$\\it{x}$',fontname = 'Times New Roman')\n    ax.set_ylabel('$\\it{y}$',fontname = 'Times New Roman')\n\n    ax.set_zlabel('$%s$' % latex(caption), fontname = 'Times New Roman')\n\n\n    ax.xaxis._axinfo[\"grid\"].update({\"linewidth\":0.25, \"linestyle\" : \":\"})\n    ax.yaxis._axinfo[\"grid\"].update({\"linewidth\":0.25, \"linestyle\" : \":\"})\n    ax.zaxis._axinfo[\"grid\"].update({\"linewidth\":0.25, \"linestyle\" : \":\"})\n\n    plt.rcParams[\"font.family\"] = \"Times New Roman\"\n    plt.rcParams[\"font.size\"] = \"10\"\n\n#%% Initialization\n\nx0  = 0;  # center of the mesh\ny0  = 0;  # center of the mesh\nr   = 2;  # radius of the mesh\nnum = 40; # number of mesh grids\nxx,yy = mesh_square(x0,y0,r,num); # generate mesh\n\n#%% plot f(x,y)\n\nplt.close('all')\n\nf_xy = x*exp(- x**2 - y**2);\n\nf_xy_fcn = lambdify([x,y],f_xy)\n\nf_xy_zz = f_xy_fcn(xx,yy)\n\ncaption = f_xy\n\nplot_surf(xx,yy,f_xy_zz,caption)\n\n#%% plot partial df/dx\n\ndf_dx = f_xy.diff(x)\ndf_dx_fcn = lambdify([x,y],df_dx)\n\ndf_dx_zz = df_dx_fcn(xx,yy)\n\ncaption = df_dx\n\nplot_surf(xx,yy,df_dx_zz,caption)\n\n#%% plot partial df/dy\n\ndf_dy = f_xy.diff(y)\ndf_dy_fcn = lambdify([x,y],df_dy)\n\ndf_dy_zz = df_dy_fcn(xx,yy)\n\ncaption = df_dy\n\nplot_surf(xx,yy,df_dy_zz,caption)\n\n#%% plot partial d2f/dx/dy\n\ndf_dxdy = f_xy.diff(x,y)\n# df_dxdy = df_dy.diff(x)\n# df_dxdy = df_dx.diff(y)\n\ndf_dxdy_fcn = lambdify([x,y],df_dxdy)\n\ndf_dxdy_zz = df_dxdy_fcn(xx,yy)\n\ncaption = df_dxdy\n\nplot_surf(xx,yy,df_dxdy_zz,caption)\n\n"
      },
      {
        "id": "ex6",
        "title": "11.6 B1_Ch11_6.py",
        "filename": "B1_Ch11_6.py",
        "code": "# B1_Ch11_6.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport math\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import norm\n\ndef blsprice(St, K, tau, r, vol):\n    '''\n    St: current price of underlying asset\n    K:  strike price\n    tau: time to maturity\n    r: annualized risk-free rate\n    vol: annualized asset price volatility\n    '''\n    \n    d1 = (math.log(St / K) + (r + 0.5 * vol ** 2)\\\n          *tau) / (vol * math.sqrt(tau));\n    d2 = d1 - vol*math.sqrt(tau);\n    \n    Call = norm.cdf(d1, loc=0, scale=1)*St - \\\n        norm.cdf(d2, loc=0, scale=1)*K*math.exp(-r*tau)\n        \n    Put  = -norm.cdf(-d1, loc=0, scale=1)*St + \\\n        norm.cdf(-d2, loc=0, scale=1)*K*math.exp(-r*tau)\n        \n    return Call, Put\n\n\ndef blsdelta(St, K, tau, r, vol):\n    '''\n    St: current price of underlying asset\n    K:  strike price\n    tau: time to maturity\n    r: annualized risk-free rate\n    vol: annualized asset price volatility\n    '''\n    \n    d1 = (math.log(St / K) + (r + 0.5 * vol ** 2)\\\n          *tau) / (vol * math.sqrt(tau));\n    d2 = d1 - vol*math.sqrt(tau);\n    Delta_call  = norm.cdf(d1, loc=0, scale=1)\n    Delta_put   = -norm.cdf(-d1, loc=0, scale=1)\n    return Delta_call, Delta_put\n\ndef blsgamma(St, K, tau, r, vol):\n    '''\n    St: current price of underlying asset\n    K:  strike price\n    tau: time to maturity\n    r: annualized risk-free rate\n    vol: annualized asset price volatility\n    '''\n    \n    d1 = (math.log(St / K) + (r + 0.5 * vol ** 2)\\\n          *tau) / (vol * math.sqrt(tau));\n        \n    Gamma = norm.pdf(d1)/St/vol/math.sqrt(tau);\n\n    return Gamma\n\ndef plot_curve(x,y1,y2,caption):\n    \n    fig, axs = plt.subplots(1,2)\n\n    axs[0].plot(x, y1)\n    axs[0].set_xlabel('$\\it{S}$', fontname=\"Times New Roman\", fontsize=10)\n    y_label = 'Call ' + caption\n    y_joint = np.concatenate((y1, y2))\n    axs[0].set_ylim([y_joint.min(),y_joint.max()])\n    if caption =='Delta':\n        axs[0].set_ylim([-1,1])\n\n    axs[0].set_ylabel(y_label, fontname=\"Times New Roman\", fontsize=10)\n    axs[0].grid(linestyle='--', linewidth=0.25, color=[0.5,0.5,0.5])\n\n    axs[1].plot(x, y2)\n    axs[1].set_xlabel('$\\it{S}$', fontname=\"Times New Roman\", fontsize=10)\n    y_label = 'Put ' + caption\n    axs[1].set_ylim([y_joint.min(),y_joint.max()])\n    if caption == 'Delta':\n        axs[1].set_ylim([-1,1])\n    axs[1].set_ylabel(y_label, fontname=\"Times New Roman\", fontsize=10)\n    axs[1].grid(linestyle='--', linewidth=0.25, color=[0.5,0.5,0.5])\n\n# end of function\n\nblsprice_vec = np.vectorize(blsprice)\nblsdelta_vec = np.vectorize(blsdelta)\nblsgamma_vec = np.vectorize(blsgamma)\n\nS_array  = np.linspace(20,80,50);\n\nK = 50;    # strike price\nr = 0.03;  # risk-free rate\nvol = 0.5; # volatility \ntau = 0.5;     # time to maturity\n\n#%% option vs S\n\nplt.close('all')\n\nCall_array, Put_array = blsprice_vec(S_array, K, tau, r, vol)\ncaption = 'price'\nplot_curve(S_array,Call_array,Put_array,caption)\n\n#%% Delta vs S\n\nCall_Delta_array, Put_Delta_array = blsdelta_vec(S_array, K, tau, r, vol)\ncaption = 'Delta'\nplot_curve(S_array,Call_Delta_array,Put_Delta_array,caption)\n\n#%% Gamma vs S\n\nGamma_array = blsgamma_vec(S_array, K, tau, r, vol)\ncaption = 'Gamma'\nplot_curve(S_array,Gamma_array,Gamma_array,caption)\n"
      },
      {
        "id": "ex7",
        "title": "11.7 B1_Ch11_7.py",
        "filename": "B1_Ch11_7.py",
        "code": "# B1_Ch11_7.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nfrom sympy import latex, lambdify, diff, sin, log, exp, series\nfrom sympy.abc import x\nimport numpy as np\nfrom matplotlib import pyplot as plt \n\nf_x = exp(x) # y + 1 = exp(r)\nx_array = np.linspace(-2,2,100)\n\nf_x = log(x + 1) # ln(y + 1) = r\nx_array = np.linspace(-0.8,2,100)\n\nx_0 = 0\n\ny_0 = f_x.evalf(subs = {x: x_0})\n\nf_x_fcn = lambdify(x,f_x)\nf_x_array = f_x_fcn(x_array)\n\n#%% Visualization\n\nplt.close('all')\n\nfig, ax = plt.subplots()\n\nax.plot(x_array, f_x_array, 'k', linewidth = 1.5) \nax.plot(x_0, y_0, 'xr', markersize = 12) \nax.set_xlabel(\"$\\it{x}$\")\nax.set_ylabel(\"$\\it{f}(\\it{x})$\")\n\norder_array = np.arange(2,8)\n\nfor order in order_array:\n\n    f_series = f_x.series(x,x_0,order).removeO()\n    f_series_fcn = lambdify(x,f_series)\n    f_series_array = f_series_fcn(x_array)\n    ax.plot(x_array, f_series_array, linewidth = 0.5) \n\nax.grid(linestyle='--', linewidth=0.25, color=[0.5,0.5,0.5])\nax.set_xlim(x_array.min(),x_array.max())\n"
      },
      {
        "id": "ex8",
        "title": "11.8 B1_Ch11_8.py",
        "filename": "B1_Ch11_8.py",
        "code": "# B1_Ch11_8.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport math\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import norm\n\ndef blsprice(St, K, tau, r, vol):\n    '''\n    St: current price of underlying asset\n    K:  strike price\n    tau: time to maturity\n    r: annualized risk-free rate\n    vol: annualized asset price volatility\n    '''\n    \n    d1 = (math.log(St / K) + (r + 0.5 * vol ** 2)\\\n          *tau) / (vol * math.sqrt(tau));\n    d2 = d1 - vol*math.sqrt(tau);\n    \n    Call = norm.cdf(d1, loc=0, scale=1)*St - \\\n        norm.cdf(d2, loc=0, scale=1)*K*math.exp(-r*tau)\n        \n    Put  = -norm.cdf(-d1, loc=0, scale=1)*St + \\\n        norm.cdf(-d2, loc=0, scale=1)*K*math.exp(-r*tau)\n        \n    return Call, Put\n\n\ndef blsdelta(St, K, tau, r, vol):\n    '''\n    St: current price of underlying asset\n    K:  strike price\n    tau: time to maturity\n    r: annualized risk-free rate\n    vol: annualized asset price volatility\n    '''\n    \n    d1 = (math.log(St / K) + (r + 0.5 * vol ** 2)\\\n          *tau) / (vol * math.sqrt(tau));\n    d2 = d1 - vol*math.sqrt(tau);\n    Delta_call  = norm.cdf(d1, loc=0, scale=1)\n    Delta_put   = -norm.cdf(-d1, loc=0, scale=1)\n    return Delta_call, Delta_put\n\ndef blsgamma(St, K, tau, r, vol):\n    '''\n    St: current price of underlying asset\n    K:  strike price\n    tau: time to maturity\n    r: annualized risk-free rate\n    vol: annualized asset price volatility\n    '''\n    \n    d1 = (math.log(St / K) + (r + 0.5 * vol ** 2)\\\n          *tau) / (vol * math.sqrt(tau));\n        \n    Gamma = norm.pdf(d1)/St/vol/math.sqrt(tau);\n\n    return Gamma\n\ndef plot_curve(x,y1,y2,x0,y0,caption):\n    \n    fig, axs = plt.subplots(1,2)\n\n    axs[0].plot(x, y1)\n    axs[0].plot(x, y2)\n    axs[0].plot(x0, y0, 'xr', markersize = 12)\n    axs[0].set_xlabel('$\\it{S}$', fontname=\"Times New Roman\", fontsize=10)\n    y_label = caption + ' price'\n    axs[0].set_ylabel(y_label, fontname=\"Times New Roman\", fontsize=10)\n    axs[0].grid(linestyle='--', linewidth=0.25, color=[0.5,0.5,0.5])\n\n    axs[1].plot(x, y1 - y2)\n    axs[1].plot(x0, 0, 'xr', markersize = 12)\n    plt.axhline(y=0, color='k', linewidth = 0.5)\n    axs[1].fill_between(x, y1 - y2, 0, facecolor = np.divide([219, 238, 243], 255))\n    axs[1].set_xlabel('$\\it{S}$', fontname=\"Times New Roman\", fontsize=10)\n    axs[1].set_ylabel('Error', fontname=\"Times New Roman\", fontsize=10)\n    axs[1].grid(linestyle='--', linewidth=0.25, color=[0.5,0.5,0.5])\n\n# end of function\n\nblsprice_vec = np.vectorize(blsprice)\nblsdelta_vec = np.vectorize(blsdelta)\nblsgamma_vec = np.vectorize(blsgamma)\n\nS_array  = np.linspace(20,80,50);\n\nK = 50;    # strike price\nr = 0.03;  # risk-free rate\nvol = 0.5; # volatility \ntau = 0.5;     # time to maturity\n\nS_0 = 50;  # expansion point\nC_0, P_0 = blsprice_vec(S_0, K, tau, r, vol)\nDelta_C_0, Delta_P_0 = blsdelta_vec(S_0, K, tau, r, vol)\nGamma_0 = blsgamma_vec(S_0, K, tau, r, vol)\n\nCall_array, Put_array = blsprice_vec(S_array, K, tau, r, vol)\n\n#%% Delta approximation\n\nplt.close('all')\n\nCall_delta_apprx = Delta_C_0*(S_array - S_0) + C_0\ncaption = 'Call'\nplot_curve(S_array,Call_array,Call_delta_apprx,S_0,C_0,caption)\n\nPut_delta_apprx = Delta_P_0*(S_array - S_0) + P_0\ncaption = 'Put'\nplot_curve(S_array,Put_array,Put_delta_apprx,S_0,P_0,caption)\n\n\n#%% Delta-Gamma approximation\n\nCall_delta_gamma_apprx = Delta_C_0*(S_array - S_0) + Gamma_0*np.power((S_array - S_0),2)/2 + C_0\ncaption = 'Call'\nplot_curve(S_array,Call_array,Call_delta_gamma_apprx,S_0,C_0,caption)\n\nPut_delta_gamma_apprx = Delta_P_0*(S_array - S_0) + Gamma_0*np.power((S_array - S_0),2)/2 + P_0\ncaption = 'Put'\nplot_curve(S_array,Put_array,Put_delta_gamma_apprx,S_0,P_0,caption)\n"
      },
      {
        "id": "ex9",
        "title": "11.9 B1_Ch11_9.py",
        "filename": "B1_Ch11_9.py",
        "code": "# B1_Ch11_9.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport numpy as np\nimport math\nimport matplotlib.pyplot as plt\nfrom scipy.stats import norm\n\ndef blsprice(St, K, tau, r, vol):\n    '''\n    St: current price of underlying asset\n    K:  strike price\n    tau: time to maturity\n    r: annualized risk-free rate\n    vol: annualized asset price volatility\n    '''\n    \n    d1 = (math.log(St / K) + (r + 0.5 * vol ** 2)\\\n          *tau) / (vol * math.sqrt(tau));\n    d2 = d1 - vol*math.sqrt(tau);\n    \n    Call = norm.cdf(d1, loc=0, scale=1)*St - \\\n        norm.cdf(d2, loc=0, scale=1)*K*math.exp(-r*tau)\n        \n    Put  = -norm.cdf(-d1, loc=0, scale=1)*St + \\\n        norm.cdf(-d2, loc=0, scale=1)*K*math.exp(-r*tau)\n        \n    return Call, Put\n\n\ndef blsdelta(St, K, tau, r, vol):\n    '''\n    St: current price of underlying asset\n    K:  strike price\n    tau: time to maturity\n    r: annualized risk-free rate\n    vol: annualized asset price volatility\n    '''\n    \n    d1 = (math.log(St / K) + (r + 0.5 * vol ** 2)\\\n          *tau) / (vol * math.sqrt(tau));\n    d2 = d1 - vol*math.sqrt(tau);\n    Delta_call  = norm.cdf(d1, loc=0, scale=1)\n    Delta_put   = -norm.cdf(-d1, loc=0, scale=1)\n    return Delta_call, Delta_put\n\ndef blsgamma(St, K, tau, r, vol):\n    '''\n    St: current price of underlying asset\n    K:  strike price\n    tau: time to maturity\n    r: annualized risk-free rate\n    vol: annualized asset price volatility\n    '''\n    \n    d1 = (math.log(St / K) + (r + 0.5 * vol ** 2)\\\n          *tau) / (vol * math.sqrt(tau));\n        \n    Gamma = norm.pdf(d1)/St/vol/math.sqrt(tau);\n\n    return Gamma\n\nS_0 = 50;    # current spot price\nK = 50;    # strike price\nr = 0.03;  # risk-free rate\nvol = 0.5; # volatility \ntau = 0.5;     # time to maturity\n\nblsprice_vec = np.vectorize(blsprice)\nblsdelta_vec = np.vectorize(blsdelta)\nblsgamma_vec = np.vectorize(blsgamma)\n\nC_0, _ = blsprice_vec(S_0, K, tau, r, vol)\nDelta_C_0, _ = blsdelta_vec(S_0, K, tau, r, vol)\nGamma_0 = blsgamma_vec(S_0, K, tau, r, vol)\n\nDelta_S_array = np.arange(0.1,5.0,0.1)\n\nDelta_apprx = np.full_like(Delta_S_array,0)\nGamma_apprx = np.full_like(Delta_S_array,0)\n\ni = 0;\n\nfor Delta_S in Delta_S_array:\n    \n    \n    C_up, _   = blsprice_vec(S_0 + Delta_S, K, tau, r, vol)\n    C_down, _ = blsprice_vec(S_0 - Delta_S, K, tau, r, vol)\n    \n    Delta_apprx[int(i)] = (C_up - C_down)/2/Delta_S\n    \n    Gamma_apprx[int(i)] = (C_up - 2.0*C_0+ C_down)/Delta_S**2\n    \n    i += 1\n\n#%% visualize numerical Delta and Gamma\n\nplt.close('all')\n\nfig, axs = plt.subplots()\n\naxs.plot(Delta_S_array, Delta_apprx, linestyle = 'none', marker = 'x')\nplt.axhline(y=Delta_C_0, color='r', linewidth = 0.5)\n\naxs.set_xlabel('$\\Delta\\it{S}$', fontname=\"Times New Roman\", fontsize=10)\naxs.set_ylabel('Delta', fontname=\"Times New Roman\", fontsize=10)\naxs.grid(linestyle='--', linewidth=0.25, color=[0.5,0.5,0.5])\n\nfig, axs = plt.subplots()\n\naxs.plot(Delta_S_array, Gamma_apprx, linestyle = 'none', marker = 'x')\nplt.axhline(y=Gamma_0, color='r', linewidth = 0.5)\n\naxs.set_xlabel('$\\Delta\\it{S}$', fontname=\"Times New Roman\", fontsize=10)\naxs.set_ylabel('Gamma', fontname=\"Times New Roman\", fontsize=10)\naxs.grid(linestyle='--', linewidth=0.25, color=[0.5,0.5,0.5])\n"
      },
      {
        "id": "ex10",
        "title": "11.10 B1_Ch11_10.py",
        "filename": "B1_Ch11_10.py",
        "code": "# B1_Ch11_10.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport numpy as np\nfrom scipy.optimize import minimize, LinearConstraint, Bounds\nimport matplotlib.pyplot as plt\n\ndef min_var_obj(w, *args):\n    \n    \n    sigma_1, sigma_2, rho = args\n    w1 = w[0];\n    w2 = w[1];\n    \n    obj = sigma_1**2*w1**2 + \\\n    sigma_2**2*w2**2 + \\\n    2*sigma_1*sigma_2*rho*w1*w2;\n    return obj\n\ndef mesh_square(x0,y0,r,num):\n\n# generate mesh using polar coordinates\n \n    rr = np.linspace(-r,r,num)\n\n    xx,yy = np.meshgrid(rr,rr);\n \n    xx = xx + x0; \n    yy = yy + y0;\n\n    return xx, yy\n\n#%% optimization\n\nsigma_1 = 0.3;\nsigma_2 = 0.4;\nrho = 0.5;\n\nx0 = [0,0]; # initial guess\nlinear_constraint = LinearConstraint([1,1],[1],[1])\n\nbounds = Bounds([-1, -1], [1.5, 1.5])\n\n# Pass in a tuple with the wanted arguments a, b, c\nres = minimize(min_var_obj, x0,\n               args=(sigma_1,sigma_2,rho),\n               method='trust-constr',\n               bounds = bounds,\n               constraints=[linear_constraint])\noptimized_x = res.x;\n\nprint(\"==== Optimized weights ====\")\nprint(res.x)\n\nprint(\"==== Optimized objective ====\")\nprint(res.fun)\n\n#%% Visualize contourf of portfolio variance and volatility\n\nx0  = 0;  # center of the mesh\ny0  = 0;  # center of the mesh\nr   = 1;  # radius of the mesh\nnum = 30; # number of mesh grids\nxx,yy = mesh_square(x0,y0,r,num); # generate mesh\n\nplt.close('all')\n\n\nzz = sigma_1**2*np.multiply(xx,xx) + \\\n    sigma_2**2*np.multiply(yy,yy) + \\\n    2*sigma_1*sigma_2*rho*np.multiply(xx,yy);\n\nw1 = np.linspace(-1,1,10)\nw2 = 1.0 - w1; \n\nvar = sigma_1**2*np.multiply(w1,w1) + \\\n    sigma_2**2*np.multiply(w2,w2) + \\\n    2*sigma_1*sigma_2*rho*np.multiply(w1,w2);\n\n\nfig, ax = plt.subplots()\n\ncntr2 = ax.contourf(xx,yy,zz, levels = 15, cmap=\"RdBu_r\")\nplt.plot(w1,w2,'k',linewidth = 1.5)\nfig.colorbar(cntr2, ax=ax)\nplt.show()\nplt.plot(optimized_x[0],optimized_x[1], 'rx', markersize = 12)\n\nax.set_xlabel('$\\it{w}_1$')\nax.set_ylabel('$\\it{w}_2$')\nax.axis('square')\nax.grid(linestyle='--', linewidth=0.25, color=[0.5,0.5,0.5])\nax.set_xlim([-r,r])\nax.set_ylim([-r,r])\n\nfig, ax = plt.subplots()\n\ncntr2 = ax.contourf(xx,yy,np.sqrt(zz), levels = 15, cmap=\"RdBu_r\")\nplt.plot(w1,w2,'k',linewidth = 1.5)\nfig.colorbar(cntr2, ax=ax)\nplt.show()\nplt.plot(optimized_x[0],optimized_x[1], 'rx', markersize = 12)\n\nax.set_xlabel('$\\it{w}_1$')\nax.set_ylabel('$\\it{w}_2$')\nax.axis('square')\nax.grid(linestyle='--', linewidth=0.25, color=[0.5,0.5,0.5])\nax.set_xlim([-r,r])\nax.set_ylim([-r,r])\n"
      },
      {
        "id": "ex11",
        "title": "11.11 B1_Ch11_11.py",
        "filename": "B1_Ch11_11.py",
        "code": "# B1_Ch11_11.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport numpy as np\n\nfrom pymoo.model.problem import Problem\nfrom pymoo.algorithms.nsga2 import NSGA2\nfrom pymoo.optimize import minimize\nfrom pymoo.visualization.scatter import Scatter\nimport matplotlib.pyplot as plt\n\ndef mesh_square(x0,y0,r,num):\n\n# generate mesh using polar coordinates\n \n    rr = np.linspace(-r,r,num)\n\n    xx,yy = np.meshgrid(rr,rr);\n \n    xx = xx + x0; \n    yy = yy + y0;\n\n    return xx, yy\n\nclass MyProblem(Problem):\n\n    def __init__(self):\n        super().__init__(n_var=2,\n                         n_obj=2,\n                         n_constr=1,\n                         xl=np.array([-1, -1]),\n                         xu=np.array([1.5, 1.5]))\n\n    def _evaluate(self, x, out, *args, **kwargs):\n        \n        \n        sigma_1 = 0.3;\n        sigma_2 = 0.4;\n        rho = 0.5;\n        Er1 = 0.2;\n        Er2 = 0.1;\n        f1 = (sigma_1**2*x[:, 0] ** 2 + \n              sigma_2**2*x[:, 1] ** 2 + \n              2*sigma_1*sigma_2*rho*x[:, 0]*x[:, 1])\n        \n        f2 = -(Er1*x[:, 0] + Er2*x[:, 1])\n        g1 = (x[:, 0] + x[:, 1] - 1) ** 2 - 1e-5\n\n        out[\"F\"] = np.column_stack([f1, f2])\n        out[\"G\"] = g1\n        \n\nproblem = MyProblem()\nalgorithm = NSGA2(pop_size=200)\n\nres = minimize(problem,\n               algorithm,\n               (\"n_gen\", 100),\n               verbose=True,\n               seed=1)\n\nresults = res.F\nopt_weights = res.X\nopt_variance = results[:,0]\nopt_Erp = -results[:,1]\n\n#%% visualization of Pareto front and efficient frontier\n\nplt.close('all')\n\nfig, ax = plt.subplots()\n\nplt.scatter(results[:,0],results[:,1],marker = 'x')\nplt.show()\n\nax.set_xlabel(\"$\\it{f}_1$\")\nax.set_ylabel(\"$\\it{f}_2$\")\n\nax.grid(linestyle='--', linewidth=0.25, color=[0.5,0.5,0.5])\n\nfig, ax = plt.subplots()\n\nplt.scatter(opt_variance, opt_Erp,marker = 'x')\nplt.show()\n\nax.set_xlabel(\"$\\it{\\sigma}_p^2$\")\nax.set_ylabel(\"$\\it{E(r_p)}$\")\n\nax.grid(linestyle='--', linewidth=0.25, color=[0.5,0.5,0.5])\n\nfig, ax = plt.subplots()\n\nplt.scatter(np.sqrt(opt_variance), opt_Erp, marker = 'x')\nplt.show()\n\nax.set_xlabel(\"$\\it{\\sigma}_p$\")\nax.set_ylabel(\"$\\it{E(r_p)}$\")\n\nax.grid(linestyle='--', linewidth=0.25, color=[0.5,0.5,0.5])\n\n#%% confourf of portfolio variance\n\nx0  = 0;  # center of the mesh\ny0  = 0;  # center of the mesh\nr   = 1.5;  # radius of the mesh\nnum = 30; # number of mesh grids\nxx,yy = mesh_square(x0,y0,r,num); # generate mesh\n\nsigma_1 = 0.3;\nsigma_2 = 0.4;\nrho = 0.5;\nEr1 = 0.2;\nEr2 = 0.1;\n\nzz = sigma_1**2*np.multiply(xx,xx) + \\\n    sigma_2**2*np.multiply(yy,yy) + \\\n    2*sigma_1*sigma_2*rho*np.multiply(xx,yy);\n\nw1 = np.linspace(-1.5,1.5,10)\nw2 = 1.0 - w1; \n\nvar = sigma_1**2*np.multiply(w1,w1) + \\\n    sigma_2**2*np.multiply(w2,w2) + \\\n    2*sigma_1*sigma_2*rho*np.multiply(w1,w2);\n\n\nfig, ax = plt.subplots()\n\ncntr2 = ax.contourf(xx,yy,zz, levels = 15, cmap=\"RdBu_r\")\nplt.plot(opt_weights[:,0],opt_weights[:,1],linestyle = 'none', marker = 'x', color = 'r')\nplt.plot(w1,w2,'k',linewidth = 1.5)\nfig.colorbar(cntr2, ax=ax)\nplt.show()\n\nax.set_xlabel('$\\it{w}_1$')\nax.set_ylabel('$\\it{w}_2$')\nax.axis('square')\nax.grid(linestyle='--', linewidth=0.25, color=[0.5,0.5,0.5])\nax.set_xlim([-r,r])\nax.set_ylim([-r,r])\n\n#%% confourf of portfolio expected return\n\nErp = 0.2*w1 + 0.1*w2;\n\nzz = 0.2*xx + 0.1*yy;\n\nfig, ax = plt.subplots()\n\ncntr2 = ax.contourf(xx,yy,zz, levels = 15, cmap=\"RdBu_r\")\nplt.plot(w1,w2,'k',linewidth = 1.5)\nfig.colorbar(cntr2, ax=ax)\nplt.show()\nplt.plot(opt_weights[:,0],opt_weights[:,1],linestyle = 'none', marker = 'x', color = 'r')\n\nax.set_xlabel('$\\it{w}_1$')\nax.set_ylabel('$\\it{w}_2$')\nax.axis('square')\nax.grid(linestyle='--', linewidth=0.25, color=[0.5,0.5,0.5])\nax.set_xlim([-r,r])\nax.set_ylim([-r,r])\n"
      }
    ]
  },
  {
    "id": "b1_ch12",
    "title": "第12章：固定收益分析",
    "number": 12,
    "content": {
      "intro": {
        "title": "第 12 章：固定收益分析 - 詳解",
        "roadmap": {
          "guide": "",
          "objectives": "精通利率風險的量化。本章旨在教會學習者如何實作債券定價（TVM）、計算到期收益率（YTM）、以及關鍵的風險度量指標：存續期間（Duration）與凸性（Convexity）。",
          "topics": "*   12.1 貨幣時間價值 (TVM) 深入計算\n*   12.2 債券類型與現金流結構介紹\n*   12.3 到期收益率 (YTM) 求取\n*   12.4 麥考利與修正存續期間 (Duration)\n*   12.5 關鍵利率存續期間 (Key Rate Duration)\n*   12.6 凸性 (Convexity) 計算與應用"
        },
        "value": {
          "practical": "*   **實務場景**：保險公司或養老基金的資產負債匹配 (Liability Driven Investment)。\n*   **考試重點**：修正存續期間 (MD) 的計算及利用存續期間與凸性估計價格變動。",
          "theory": "*   **利率風險的非線性**：債券價格與利率呈反向關係。存續期間是價格對利率的一階敏感度，而凸性是二階敏感度。\n*   **關鍵利率存續期間 (Key Rate Duration)**：用於分析收益率曲線非平行移動（如：陡峭化或平坦化）對組合價值的影響。",
          "further_reading": "*   隨機利率模型 (Vasicek, CIR) 在債券期權定價中的應用。"
        },
        "implementation": {
          "python": "*   **折現現金流 (DCF) 引擎**：編寫一個能處理任意付息頻率與本金償還計畫的定價函數。\n*   **風險對沖模擬**：計算需要多少國債期貨才能精確鎖定目前的存續期間敞口。",
          "logic": "*   現金流向量化處理：`np.vander()` 或矩陣相乘計算 PV。\n*   `Duration = \\sum (t \\times PV_t) / Price` 的 Python 自動化計算。\n*   求 YTM 的數值求根算法應用。",
          "scenarios": "| 腳本名稱 | 核心使命 |\n| :--- | :--- |\n| **B1_Ch12_1.py** | 實作單一資產風險值 (VaR) 的歷史模擬法計算。 |\n| **B1_Ch12_2.py** | 實作參數法 (Variance-Covariance) VaR 計算與標準化收益檢驗。 |\n| **B1_Ch12_3.py** | 演示蒙地卡羅 VaR 模擬，分析非線性產品的風險暴露。 |\n| **B1_Ch12_4.py** | 計算預期不足額 (Expected Shortfall, ES)，分析尾部風險深度。 |\n| **B1_Ch12_5.py** | 實作 VaR 的回溯測試 (Backtesting) 與 Kupiec 檢定邏輯。 |\n| **B1_Ch12_6.py** | 演示邊際價值風險 (MVaR) 與增量價值風險 (IVaR) 的計算。 |\n| **B1_Ch12_7.py** | 實作壓力測試 (Stress Testing) 情境，模擬極端市場崩潰下的組合損益。 |\n| **B1_Ch12_8.py** | 演示資本分配與風險調整後收益 (RAROC) 的基礎指標計算。 |\n| **B1_Ch12_9.py** | 實作主成分分析 (PCA) 在多維風險因子降維中的應用。 |\n| **B1_Ch12_10.py** | 利用 QuantLib Hull-White 模型對可贖回債券 (Callable Bond) 與可賣回債券 (Puttable Bond) 進行定價。 |\n| **B1_Ch12_11.py** | 分析票息率對債券價格、修正存續期間與凸性的影響，使用 QuantLib 計算。 |\n| **B1_Ch12_12.py** | 分析收益率對債券價格、修正存續期間與凸性的影響，使用 QuantLib 計算。 |\n| **B1_Ch12_13.py** | 實作 Duration-Convexity 近似法估算債券價格變動，並與分析解進行誤差比較。 |"
        },
        "body": "### 12.1 貨幣時間價值 (TVM) 深入計算\n\n#### 概念定義\n**貨幣時間價值**：今天的錢比明天的錢更有價值。\n核心概念：\n- **現值 (PV)**：未來現金流的今日價值\n- **終值 (FV)**：今日現金流的未來價值\n- **折現因子**：$DF = \\frac{1}{(1+r)^t}$\n\n#### 財金理論背景\nTVM 是所有金融估值的基礎：\n- 債券定價 = 現金流現值之和\n- 股票估值 = 預期股息的現值\n- 專案評估 = NPV 分析\n\n#### 數學公式或模型\n現值公式：\n$$\nPV = \\sum_{t=1}^{n} \\frac{CF_t}{(1+r)^t}\n$$\n\n終值公式：\n$$\nFV = PV \\times (1+r)^n\n$$\n\n#### Python 實現邏輯\n```python\nimport numpy as np\n\ndef present_value(cash_flows, r, periods=None):\n    \"\"\"計算多期現金流現值\"\"\"\n    if periods is None:\n        periods = np.arange(1, len(cash_flows)+1)\n    return np.sum(cash_flows / (1+r)**periods)\n\ndef future_value(pv, r, n):\n    \"\"\"計算終值\"\"\"\n    return pv * (1+r)**n\n\n# 債券現值範例\ncoupon = 5\nface_value = 100\nn = 4\nr = 0.06\n\n# 現金流：4年票息 + 最後一期本金\ncash_flows = np.array([coupon]*n)\ncash_flows[-1] += face_value\nbond_price = present_value(cash_flows, r)\nprint(f\"債券價格: {bond_price:.2f}\")\n```\n\n#### 常見陷阱與注意事項\n- **連續 vs 離散**：衍生品常用連續複利\n- **日計基礎**：30/360 vs ACT/ACT\n- **期初 vs 期末**：年金計算需注意\n\n#### 實務應用場景\n- 債券和貸款定價\n- 退休金精算\n- 資本預算決策\n\n#### 與其他章節的關聯\nTVM 是 Ch10 利率計算和 Ch12 債券定價的核心。\n\n---\n\n### 12.2 債券類型與現金流結構介紹\n\n#### 概念定義\n債券現金流類型：\n- **零息債券**：無票息，折價發行\n- **附息債券**：定期票息 + 到期還本\n- **永續債**：無限期票息\n- **含權債券**：可贖回/可賣回\n\n#### 財金理論背景\n理解現金流結構是定價的第一步：\n- 零息是最基本的建構模組\n- 附息債券 = 多個零息的組合\n- 含權債券需考慮執行機率\n\n#### Python 實現邏輯\n```python\nimport numpy as np\n\ndef zero_coupon_price(face_value, r, T):\n    \"\"\"零息債券定價\"\"\"\n    return face_value / (1+r)**T\n\ndef coupon_bond_price(coupon, face_value, r, n, freq=1):\n    \"\"\"附息債券定價\"\"\"\n    periods = np.arange(1, n*freq+1)\n    cf = np.array([coupon/freq]*(n*freq))\n    cf[-1] += face_value\n    discount = (1+r/freq)**periods\n    return np.sum(cf / discount)\n\ndef consol_price(coupon, r):\n    \"\"\"永續債定價\"\"\"\n    return coupon / r\n\n# 範例\nprint(f\"零息債券: {zero_coupon_price(100, 0.05, 5):.2f}\")\nprint(f\"附息債券: {coupon_bond_price(5, 100, 0.05, 5):.2f}\")\nprint(f\"永續債券: {consol_price(5, 0.05):.2f}\")\n```\n\n#### 常見陷阱與注意事項\n- **付息頻率**：年付 vs 半年付 vs 季付\n- **應計利息**：交易日非付息日需調整\n- **全價 vs 淨價**：報價通常是淨價\n\n#### 實務應用場景\n- 公司債和政府債評估\n- 固定收益投資組合配置\n- 利率衍生品標的\n\n#### 與其他章節的關聯\n現金流結構用於 Ch12.3 YTM 計算和 Ch12.4 Duration 分析。\n\n---\n\n### 12.3 到期收益率 (YTM) 求取\n\n#### 概念定義\n**YTM (Yield to Maturity)**：使債券現金流現值等於市價的內部報酬率。\n$$\nP = \\sum_{t=1}^{n} \\frac{CF_t}{(1+YTM)^t}\n$$\n\n假設：持有至到期，票息以 YTM 再投資。\n\n#### 財金理論背景\nYTM 是債券收益的標準度量：\n- 可比較不同債券的回報\n- 是收益率曲線的基礎\n- 反映市場對未來利率的預期\n\n#### 數學公式或模型\n無解析解，需數值求解：\n$$\nf(y) = \\sum_{t=1}^{n} \\frac{CF_t}{(1+y)^t} - P = 0\n$$\n\n#### Python 實現邏輯\n```python\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef ytm(price, cash_flows, periods, guess=0.05):\n    \"\"\"計算到期收益率\"\"\"\n    def objective(y):\n        pv = np.sum(cash_flows / (1+y)**periods)\n        return pv - price\n    \n    return brentq(objective, 0.001, 0.50)\n\n# 範例\ncoupon = 5\nface_value = 100\nn = 4\nmarket_price = 95\n\ncash_flows = np.array([coupon]*n)\ncash_flows[-1] += face_value\nperiods = np.arange(1, n+1)\n\ny = ytm(market_price, cash_flows, periods)\nprint(f\"YTM: {y:.4%}\")\n\n# numpy 財務函數\nimport numpy_financial as npf\nytm_npf = npf.irr([-market_price] + list([coupon]*3) + [coupon + face_value])\nprint(f\"YTM (npf): {ytm_npf:.4%}\")\n```\n\n#### 常見陷阱與注意事項\n- **再投資假設**：實際可能無法以 YTM 再投資\n- **含權債券**：YTM 不適用，需用 OAS\n- **負 YTM**：負利率環境下可能出現\n\n#### 實務應用場景\n- 債券相對價值比較\n- 收益率曲線構建\n- 投資決策基準\n\n#### 與其他章節的關聯\nYTM 是 Ch12.4 Duration 計算的折現率基礎。\n\n---\n\n### 12.4 麥考利與修正存續期間 (Duration)\n\n#### 概念定義\n- **Macaulay Duration**：現金流的加權平均期限\n$$\nD_{mac} = \\frac{\\sum_{t=1}^{n} t \\cdot \\frac{CF_t}{(1+y)^t}}{P}\n$$\n\n- **Modified Duration**：價格對利率的敏感度\n$$\nD_{mod} = \\frac{D_{mac}}{1+y}\n$$\n\n#### 財金理論背景\nDuration 是利率風險的一階度量：\n- 利率上升 1%，價格下跌約 D_mod %\n- 用於對沖利率風險\n- 資產負債匹配的核心工具\n\n#### 數學公式或模型\n價格變動近似：\n$$\n\\frac{\\Delta P}{P} \\approx -D_{mod} \\cdot \\Delta y\n$$\n\n#### Python 實現邏輯\n```python\nimport numpy as np\n\ndef macaulay_duration(cash_flows, periods, y):\n    \"\"\"計算 Macaulay Duration\"\"\"\n    pv = np.sum(cash_flows / (1+y)**periods)\n    weighted_time = np.sum(periods * cash_flows / (1+y)**periods)\n    return weighted_time / pv\n\ndef modified_duration(cash_flows, periods, y):\n    \"\"\"計算 Modified Duration\"\"\"\n    D_mac = macaulay_duration(cash_flows, periods, y)\n    return D_mac / (1 + y)\n\n# 範例\ncoupon = 5\nface_value = 100\nn = 4\ny = 0.05\n\ncash_flows = np.array([coupon]*n)\ncash_flows[-1] += face_value\nperiods = np.arange(1, n+1)\n\nD_mac = macaulay_duration(cash_flows, periods, y)\nD_mod = modified_duration(cash_flows, periods, y)\nprint(f\"Macaulay Duration: {D_mac:.2f} 年\")\nprint(f\"Modified Duration: {D_mod:.2f}\")\n\n# 價格敏感度\ndy = 0.01  # 利率上升 1%\napprox_change = -D_mod * dy\nprint(f\"利率+1% 價格變動: {approx_change:.2%}\")\n```\n\n#### 常見陷阱與注意事項\n- **非線性**：大幅利率變動時 Duration 近似不準\n- **平行移動假設**：假設整條曲線等量移動\n- **頻率調整**：半年付息需調整計算\n\n#### 實務應用場景\n- 債券投資組合的利率風險管理\n- 資產負債匹配（ALM）\n- 期貨對沖比例計算\n\n#### 與其他章節的關聯\nDuration 與 Ch12.6 Convexity 結合提供更精確的近似。\n\n---\n\n### 12.5 關鍵利率存續期間 (Key Rate Duration)\n\n#### 概念定義\n**Key Rate Duration (KRD)**：衡量特定期限利率單獨變動對債券價格的影響。\n\n傳統 Duration 假設平行移動，KRD 可捕捉：\n- 曲線變陡 (Steepening)\n- 曲線變平 (Flattening)\n- 曲線扭曲 (Twist)\n\n#### 財金理論背景\n收益率曲線的非平行移動是常態：\n- 短期利率受央行政策影響大\n- 長期利率受通膨預期影響\n- 不同期限的風險暴露不同\n\n#### 數學公式或模型\n$$\nKRD_t = -\\frac{1}{P} \\frac{\\partial P}{\\partial r_t}\n$$\n\n總 Duration ≈ Σ KRD_t\n\n#### Python 實現邏輯\n```python\nimport numpy as np\n\ndef key_rate_duration(cash_flows, periods, spot_rates, key_rate_idx, shift=0.0001):\n    \"\"\"計算關鍵利率存續期間\"\"\"\n    # 基準價格\n    discount_factors = np.exp(-spot_rates * periods)  # 連續複利\n    P0 = np.sum(cash_flows * discount_factors)\n    \n    # 移動特定關鍵利率\n    shifted_rates = spot_rates.copy()\n    shifted_rates[key_rate_idx] += shift\n    \n    # 插值影響相鄰期限\n    # (簡化版本：只移動該期限)\n    shifted_df = np.exp(-shifted_rates * periods)\n    P_up = np.sum(cash_flows * shifted_df)\n    \n    # KRD\n    return -(P_up - P0) / (P0 * shift)\n\n# 範例\nperiods = np.array([1, 2, 3, 5, 10])\nspot_rates = np.array([0.02, 0.025, 0.03, 0.035, 0.04])\ncash_flows = np.array([5, 5, 5, 5, 105])\n\nfor i, t in enumerate(periods):\n    krd = key_rate_duration(cash_flows, periods, spot_rates, i)\n    print(f\"KRD at {t}Y: {krd:.3f}\")\n```\n\n#### 常見陷阱與注意事項\n- **關鍵期限選擇**：通常選 2Y, 5Y, 10Y, 30Y\n- **插值方法**：影響相鄰期限的傳導\n- **加總性**：KRD 之和應接近總 Duration\n\n#### 實務應用場景\n- 複雜債券組合的曲線風險管理\n- 長短端風險分解\n- 公債期貨對沖設計\n\n#### 與其他章節的關聯\nKRD 需要 Ch10 插值技術構建完整曲線。\n\n---\n\n### 12.6 凸性 (Convexity) 計算與應用\n\n#### 概念定義\n**Convexity** 是價格-利率曲線的曲率（二階導數）：\n$$\nC = \\frac{1}{P} \\frac{\\partial^2 P}{\\partial y^2}\n$$\n\n配合 Duration 提供更精確的近似：\n$$\n\\frac{\\Delta P}{P} \\approx -D_{mod} \\cdot \\Delta y + \\frac{1}{2} C \\cdot (\\Delta y)^2\n$$\n\n#### 財金理論背景\n凸性捕捉非線性風險：\n- **正凸性**：債券漲多跌少，對投資人有利\n- **負凸性**：可贖回債券的特徵\n- 大幅利率變動時凸性修正非常重要\n\n#### 數學公式或模型\n凸性公式：\n$$\nC = \\frac{1}{P(1+y)^2} \\sum_{t=1}^{n} t(t+1) \\frac{CF_t}{(1+y)^t}\n$$\n\n#### Python 實現邏輯\n```python\nimport numpy as np\n\ndef convexity(cash_flows, periods, y):\n    \"\"\"計算凸性\"\"\"\n    pv = np.sum(cash_flows / (1+y)**periods)\n    weighted = np.sum(periods * (periods+1) * cash_flows / (1+y)**(periods+2))\n    return weighted / pv\n\ndef duration_convexity_approx(D_mod, C, dy):\n    \"\"\"Duration-Convexity 近似\"\"\"\n    return -D_mod * dy + 0.5 * C * dy**2\n\n# 範例\ncoupon = 5\nface_value = 100\nn = 10\ny = 0.05\n\ncash_flows = np.array([coupon]*n)\ncash_flows[-1] += face_value\nperiods = np.arange(1, n+1)\n\nD_mod = modified_duration(cash_flows, periods, y)\nC = convexity(cash_flows, periods, y)\nprint(f\"Modified Duration: {D_mod:.2f}\")\nprint(f\"Convexity: {C:.2f}\")\n\n# 比較近似精度\nfor dy in [0.01, 0.02, 0.03]:\n    linear = -D_mod * dy\n    quadratic = duration_convexity_approx(D_mod, C, dy)\n    \n    # 實際價格變動\n    P0 = np.sum(cash_flows / (1+y)**periods)\n    P1 = np.sum(cash_flows / (1+y+dy)**periods)\n    actual = (P1 - P0) / P0\n    \n    print(f\"dy={dy:.0%}: 線性={linear:.4%}, D-C={quadratic:.4%}, 實際={actual:.4%}\")\n```\n\n#### 常見陷阱與注意事項\n- **單位問題**：凸性有時以「每 100bp² 的價格變動」報價\n- **負凸性**：MBS 和可贖回債券可能有負凸性\n- **高階項**：極端情境可能需要更高階近似\n\n#### 實務應用場景\n- 利率風險的精確估計\n- 債券選擇（正凸性較佳）\n- 資產負債匹配精度提升\n\n#### 與其他章節的關聯\n凸性與 Ch11 泰勒展開的二階項對應，完善 Ch12.4 Duration 的風險估計。"
      }
    },
    "examples": [
      {
        "id": "ex1",
        "title": "12.1 B1_Ch12_1.py",
        "filename": "B1_Ch12_1.py",
        "code": "# B1_Ch12_1.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nr = 0.05\npv = 1000\nm = np.arange(1,100)\nfv = pv*(1+r/m)**m\n\nplt.figure()\nplt.plot(m,fv)\nplt.xlabel('Annual compounding frequency',fontsize=8)\nplt.ylabel('Future value',fontsize=8)\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.gca().yaxis.set_ticks_position('left')\nplt.gca().xaxis.set_ticks_position('bottom')\n"
      },
      {
        "id": "ex2",
        "title": "12.2 B1_Ch12_2.py",
        "filename": "B1_Ch12_2.py",
        "code": "# B1_Ch12_2.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ncoupon_rate = 0.1\nPar = 1000\nn = 10\nytm = np.arange(0,0.2,0.005)\npv = 0\n\nfor i in range(n):\n    pv = Par*coupon_rate/(1+ytm)**i + pv \n\nplt.plot(ytm,pv)\nplt.xlabel('YTM',fontsize=8)\nplt.ylabel('Price',fontsize=8)\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.gca().yaxis.set_ticks_position('left')\nplt.gca().xaxis.set_ticks_position('bottom')\n\n"
      },
      {
        "id": "ex3",
        "title": "12.3 B1_Ch12_3.py",
        "filename": "B1_Ch12_3.py",
        "code": "# B1_Ch12_3.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport QuantLib as ql\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ntodaysDate = ql.Date(10, 7, 2017)\nql.Settings.instance().evaluationDate = todaysDate\ndayCount = ql.Thirty360()\ncalendar = ql.UnitedStates()\ninterpolation = ql.Linear()\ncompounding = ql.Compounded\ncompoundingFrequency = ql.Annual\n\nissueDate = ql.Date(15, 1, 2017)\nmaturityDate = ql.Date(15, 1, 2020)\ntenor = ql.Period(ql.Semiannual)\ncalendar = ql.UnitedStates()\nbussinessConvention = ql.Unadjusted\ndateGeneration = ql.DateGeneration.Backward\nmonthEnd = False\nschedule = ql.Schedule (issueDate, maturityDate, tenor, calendar, bussinessConvention,\n                            bussinessConvention , dateGeneration, monthEnd)\n\n# Now lets build the coupon\ncouponRate = .1\ncoupons = [couponRate]\n\n# Now lets construct the FixedRateBond\nsettlementDays = 3\nfaceValue = 100\nfixedRateBond = ql.FixedRateBond(settlementDays, faceValue, schedule, coupons, dayCount)\n\nytm = np.arange(0,0.2,0.01)\ncleanPrice = np.zeros(len(ytm))\ndirtyPrice = np.zeros(len(ytm))\n\nfor i in range(len(ytm)):\n    cleanPrice[i] = fixedRateBond.cleanPrice(ytm[i],fixedRateBond.dayCounter(), compounding, ql.Semiannual)\n    dirtyPrice[i] = fixedRateBond.dirtyPrice(ytm[i],fixedRateBond.dayCounter(), compounding, ql.Semiannual)\n    \nplt.plot(ytm, dirtyPrice,label='Dirty price')\nplt.plot(ytm, cleanPrice,'o',color ='r',fillstyle='none',label='Clean price')\nplt.legend(loc='upper right')\nplt.xlabel('YTM',fontsize=8)\nplt.ylabel('Bond Price',fontsize=8)\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.gca().yaxis.set_ticks_position('left')\nplt.gca().xaxis.set_ticks_position('bottom')\n\n\n"
      },
      {
        "id": "ex4",
        "title": "12.4 B1_Ch12_4.py",
        "filename": "B1_Ch12_4.py",
        "code": "# B1_Ch12_4.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport QuantLib as ql\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ntodaysDate = ql.Date(15, 1, 2015)\nspotDates = [ql.Date(15, 1, 2015),ql.Date(15, 1, 2016), ql.Date(15, 1, 2017),ql.Date(15, 1, 2018),ql.Date(15, 1, 2019),ql.Date(15, 1, 2020)]\nspotRates = [0.027, 0.035, 0.042,0.047,0.052,0.055]\ndayCount = ql.Thirty360()\ncalendar = ql.UnitedStates()\ninterpolation = ql.Linear()\ncompounding = ql.Compounded\ncompoundingFrequency = ql.Annual\n\nissueDate = ql.Date(15, 1, 2015)\nmaturityDate = ql.Date(15, 1, 2020)\ntenor = ql.Period(ql.Semiannual)\ncalendar = ql.UnitedStates()\nbussinessConvention = ql.Unadjusted\ndateGeneration = ql.DateGeneration.Backward\nmonthEnd = False\nschedule = ql.Schedule (issueDate, maturityDate, tenor, calendar, bussinessConvention,\n                            bussinessConvention , dateGeneration, monthEnd)\n\n# Now lets build the coupon\ndayCount = ql.Thirty360()\ncouponRate1 = .085\ncoupons1 = [couponRate1]\n\ncouponRate2 = .03\ncoupons2 = [couponRate2]\n\n# Now lets construct the FixedRateBond\nsettlementDays = 0\nfaceValue = 100\nfixedRateBond1 = ql.FixedRateBond(settlementDays, faceValue, schedule, coupons1, dayCount)\nfixedRateBond2 = ql.FixedRateBond(settlementDays, faceValue, schedule, coupons2, dayCount)\n\ndirtyPrice1 = np.zeros(1826)\ncleanPrice1 = np.zeros(1826)\ndirtyPrice2 = np.zeros(1826)\ncleanPrice2 = np.zeros(1826)\n\nfor i in range(1826):\n    ql.Settings.instance().evaluationDate = todaysDate + i\n    spotCurve = ql.ZeroCurve(spotDates, spotRates, dayCount, calendar, interpolation,\n                                 compounding, compoundingFrequency)\n    spotCurveHandle = ql.YieldTermStructureHandle(spotCurve)\n\n    # create a bond engine with the term structure as input;\n    # set the bond to use this bond engine\n    bondEngine = ql.DiscountingBondEngine(spotCurveHandle)\n    fixedRateBond1.setPricingEngine(bondEngine)\n    fixedRateBond2.setPricingEngine(bondEngine)\n\n    # Finally the price\n    fixedRateBond1.NPV()\n    dirtyPrice1[i] = fixedRateBond1.dirtyPrice()\n    cleanPrice1[i] = fixedRateBond1.cleanPrice()\n    \n    fixedRateBond2.NPV()\n    dirtyPrice2[i] = fixedRateBond2.dirtyPrice()\n    cleanPrice2[i] = fixedRateBond2.cleanPrice()\n\nfor c in fixedRateBond1.cashflows():\n    print('%20s %12f' % (c.date(), c.amount())) \n    \nfor c in fixedRateBond2.cashflows():\n    print('%20s %12f' % (c.date(), c.amount())) \n\n\nplt.plot(dirtyPrice1)\nplt.plot(cleanPrice1)\nplt.plot(dirtyPrice2)\nplt.plot(cleanPrice2)\nplt.xlabel('Time',fontsize=8)\nplt.ylabel('Price',fontsize=8)\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.gca().yaxis.set_ticks_position('left')\nplt.gca().xaxis.set_ticks_position('bottom')\n\n\n\n"
      },
      {
        "id": "ex5",
        "title": "12.5 B1_Ch12_5.py",
        "filename": "B1_Ch12_5.py",
        "code": "# B1_Ch12_5.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport QuantLib as ql\nimport matplotlib.pyplot as plt\n\ncalc_date = ql.Date(15, 1, 2020)\nql.Settings.instance().evaluationDate = calc_date\n\ndata = [\n    ('15-01-2020', '15-04-2020', 0, 97.5),\n    ('15-01-2020', '15-07-2020', 0, 94.9),\n    ('15-01-2020', '15-01-2021', 0, 90.0),\n    ('15-01-2020', '15-07-2021', 8.0,96.0),\n    ('15-01-2020', '15-01-2022', 12.0, 101.6),\n]\n\nhelpers = []\nday_count = ql.Thirty360()\nsettlement_days = 0\nface_amount = 100\n\nfor issue_date, maturity, coupon, price in data:\n    price = ql.QuoteHandle(ql.SimpleQuote(price))\n    issue_date = ql.Date(issue_date, '%d-%m-%Y')\n    maturity = ql.Date(maturity, '%d-%m-%Y')\n    schedule = ql.MakeSchedule(issue_date, maturity, ql.Period(ql.Semiannual))\n    helper = ql.FixedRateBondHelper(price, settlement_days, face_amount, schedule, [coupon / 100], day_count)\n    helpers.append(helper)\n    \nyieldcurve = ql.PiecewiseLogCubicDiscount(calc_date, helpers, day_count)   \nspots = []\ntenors = []\n\nfor d in yieldcurve.dates():\n    yrs = day_count.yearFraction(calc_date, d)\n    print(yrs)\n    compounding = ql.Compounded\n    # compounding = ql.Simple\n    freq = ql.Semiannual\n    freq = ql.Quarterly\n    freq = ql.Daily\n    # freq = ql.Continuous\n    zero_rate = yieldcurve.zeroRate(yrs, compounding, freq)\n    tenors.append(yrs)\n    eq_rate = zero_rate.equivalentRate(day_count,\n                                       ql.Compounded,\n                                       freq,\n                                       calc_date,\n                                       d).rate()\n    spots.append(eq_rate)\n    \n\nplt.plot(tenors,spots,'x-')\nplt.xlabel('Tenor',fontsize=8)\nplt.ylabel('Rate',fontsize=8) \nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.gca().yaxis.set_ticks_position('left')\nplt.gca().xaxis.set_ticks_position('bottom')\n\n\n\n\n"
      },
      {
        "id": "ex6",
        "title": "12.6 B1_Ch12_6.py",
        "filename": "B1_Ch12_6.py",
        "code": "# B1_Ch12_6.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport QuantLib as ql\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ntodaysDate = ql.Date(10, 7, 2017)\nql.Settings.instance().evaluationDate = todaysDate\ndayCount = ql.Thirty360()\ncalendar = ql.UnitedStates()\ninterpolation = ql.Linear()\ncompounding = ql.Compounded\ncompoundingFrequency = ql.Annual\n\nissueDate = ql.Date(15, 1, 2017)\nmaturityDate = ql.Date(15, 1, 2020)\ntenor = ql.Period(ql.Semiannual)\ncalendar = ql.UnitedStates()\nbussinessConvention = ql.Unadjusted\ndateGeneration = ql.DateGeneration.Backward\nmonthEnd = False\nschedule = ql.Schedule (issueDate, maturityDate, tenor, calendar, bussinessConvention,\n                            bussinessConvention , dateGeneration, monthEnd)\n\n# Now lets build the coupon\ndayCount = ql.Thirty360()\ncouponRate = .1\ncoupons = [couponRate]\n\n# Now lets construct the FixedRateBond\nsettlementDays = 3\nfaceValue = 100\nfixedRateBond = ql.FixedRateBond(settlementDays, faceValue, schedule, coupons, dayCount)\n\nytm = np.arange(0,0.2,0.01)\nduration_mod = np.zeros(len(ytm))\nduration_mac = np.zeros(len(ytm))\ndirtyPrice = np.zeros(len(ytm))\n\nfor i in range(len(ytm)):\n    y=ytm[i]\n    duration_mod[i] = ql.BondFunctions.duration(fixedRateBond,y,ql.ActualActual(), ql.Compounded, ql.Annual, ql.Duration.Modified)\n    duration_mac[i] = ql.BondFunctions.duration(fixedRateBond,y,ql.ActualActual(), ql.Compounded, ql.Annual, ql.Duration.Macaulay)\n    # cleanPrice[i] = fixedRateBond.cleanPrice(ytm[i],fixedRateBond.dayCounter(), compounding, ql.Semiannual)\n    dirtyPrice[i] = fixedRateBond.dirtyPrice(y,fixedRateBond.dayCounter(), ql.Compounded, ql.Annual)\n    \nplt.figure(1)\nplt.subplot(311)    \nplt.plot(ytm, dirtyPrice)\nplt.xlabel('Yield To Maturity',fontsize=8)\nplt.ylabel('Bond Price',fontsize=8)\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\n\nplt.subplot(312)    \nplt.plot(ytm, duration_mod)\nplt.xlabel('Yield To Maturity',fontsize=8)\nplt.ylabel('Modified Duration',fontsize=8)\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\n\nplt.subplot(313)   \nplt.plot(ytm, duration_mac)\n\nplt.xlabel('Yield To Maturity',fontsize=8)\nplt.ylabel('Macaulay Duration',fontsize=8)\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.subplots_adjust(hspace=0.5)\n\n\n\n\n\n"
      },
      {
        "id": "ex7",
        "title": "12.7 B1_Ch12_7.py",
        "filename": "B1_Ch12_7.py",
        "code": "# B1_Ch12_7.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport QuantLib as ql\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ntodaysDate = ql.Date(10, 7, 2017)\nql.Settings.instance().evaluationDate = todaysDate\ndayCount = ql.Thirty360()\ncalendar = ql.UnitedStates()\ninterpolation = ql.Linear()\ncompounding = ql.Compounded\ncompoundingFrequency = ql.Annual\n\nissueDate = ql.Date(15, 1, 2017)\nmaturityDate = ql.Date(15, 1, 2020)\ntenor = ql.Period(ql.Semiannual)\ncalendar = ql.UnitedStates()\nbussinessConvention = ql.Unadjusted\ndateGeneration = ql.DateGeneration.Backward\nmonthEnd = False\nschedule = ql.Schedule (issueDate, maturityDate, tenor, calendar, bussinessConvention,\n                            bussinessConvention , dateGeneration, monthEnd)\n\n# Now lets build the coupon\ndayCount = ql.Thirty360()\ncouponRate = np.arange(0,0.2,0.01)\n\n# Now lets construct the FixedRateBond\nsettlementDays = 3\nfaceValue = 100\n\nytm = .1\nduration_mod = np.zeros(len(couponRate))\nduration_mac = np.zeros(len(couponRate))\ndirtyPrice = np.zeros(len(couponRate))\n\nfor i in range(len(couponRate)):\n    coupons = [couponRate[i]]\n    fixedRateBond = ql.FixedRateBond(settlementDays, faceValue, schedule, coupons, dayCount)\n    duration_mod[i] = ql.BondFunctions.duration(fixedRateBond,ytm,ql.ActualActual(), ql.Compounded, ql.Annual, ql.Duration.Modified)\n    duration_mac[i] = ql.BondFunctions.duration(fixedRateBond,ytm,ql.ActualActual(), ql.Compounded, ql.Annual, ql.Duration.Macaulay)\n    # cleanPrice[i] = fixedRateBond.cleanPrice(ytm[i],fixedRateBond.dayCounter(), compounding, ql.Semiannual)\n    dirtyPrice[i] = fixedRateBond.dirtyPrice(ytm,fixedRateBond.dayCounter(), ql.Compounded, ql.Annual)\n    \nplt.figure(1)\nplt.subplot(311)    \nplt.plot(couponRate, dirtyPrice)\nplt.xlabel('Coupon rate',fontsize=8)\nplt.ylabel('Bond Price',fontsize=8)\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\n\nplt.subplot(312)    \nplt.plot(couponRate, duration_mod)\nplt.xlabel('Coupon rate',fontsize=8)\nplt.ylabel('Modified Duration',fontsize=8)\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\n\nplt.subplot(313)   \nplt.plot(couponRate, duration_mac)\nplt.xlabel('Coupon rate',fontsize=8)\nplt.ylabel('Macaulay Duration',fontsize=8)\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.subplots_adjust(hspace=0.5)\n\n\n\n\n\n\n"
      },
      {
        "id": "ex8",
        "title": "12.8 B1_Ch12_8.py",
        "filename": "B1_Ch12_8.py",
        "code": "# B1_Ch12_8.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport QuantLib as ql\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ntodaysDate = ql.Date(1, 7, 2020)\nql.Settings.instance().evaluationDate = todaysDate\ndayCount = ql.Thirty360()\ncalendar = ql.UnitedStates()\ninterpolation = ql.Linear()\ncompounding = ql.Compounded\ncompoundingFrequency = ql.Annual\n\nissueDate = ql.Date(1, 7, 2020)\nmaturityDate = ql.Date(15, 7, 2025)\ntenor = ql.Period(ql.Semiannual)\ncalendar = ql.UnitedStates()\nbussinessConvention = ql.Unadjusted\ndateGeneration = ql.DateGeneration.Backward\nmonthEnd = False\nschedule = ql.Schedule (issueDate, maturityDate, tenor, calendar, bussinessConvention,\n                            bussinessConvention , dateGeneration, monthEnd)\n\n# Now lets build the coupon\ndayCount = ql.Thirty360()\ncouponRate = .04\ncoupons = [couponRate]\n\n# Now lets construct the FixedRateBond\nsettlementDays = 3\nfaceValue = 100\nfixedRateBond = ql.FixedRateBond(settlementDays, faceValue, schedule, coupons, dayCount)\n\ndelta_y_base = 0.0001\nytm = np.arange(5.0,7.0,delta_y_base)*0.01\napproxPrice = np.zeros(len(ytm))\ndirtyPrice = np.zeros(len(ytm))\n\n\nP0 = fixedRateBond.dirtyPrice(0.06,fixedRateBond.dayCounter(), compounding, ql.Semiannual)\nP_up = fixedRateBond.dirtyPrice(0.060 + delta_y_base,fixedRateBond.dayCounter(), compounding, ql.Semiannual)\nP_down = fixedRateBond.dirtyPrice(0.060 - delta_y_base,fixedRateBond.dayCounter(), compounding, ql.Semiannual)\nduration = (P_down - P_up)/(2*P0*delta_y_base)\n\nfor i in range(len(ytm)):\n    delta_y = ytm[i] - 0.06\n    approxPrice[i] = P0*(1-duration*delta_y)\n    dirtyPrice[i] = fixedRateBond.dirtyPrice(ytm[i],fixedRateBond.dayCounter(), compounding, ql.Semiannual)\n    \nplt.figure(1)    \nplt.plot(ytm*100, dirtyPrice,label='Analytical',color = 'b')\nplt.plot(ytm*100, approxPrice,color ='r',label='Duration approx')\nplt.plot(6, P0,'x',color ='k',fillstyle='none',label='P0')\nplt.legend(loc='upper right')\nplt.xlabel('Yield, y(%)',fontsize=8)\nplt.ylabel('Dirty Price (USD)',fontsize=8)\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.gca().yaxis.set_ticks_position('left')\nplt.gca().xaxis.set_ticks_position('bottom')\n\nplt.figure(2) \nplt.plot(ytm*100, approxPrice-dirtyPrice,color ='b')\nplt.xlabel('Yield Shift, in bps',fontsize=8)\nplt.ylabel('Error (USD)',fontsize=8)\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.gca().yaxis.set_ticks_position('left')\nplt.gca().xaxis.set_ticks_position('bottom')\n\n\n\n\n\n\n\n"
      },
      {
        "id": "ex9",
        "title": "12.9 B1_Ch12_9.py",
        "filename": "B1_Ch12_9.py",
        "code": "# B1_Ch12_9.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport QuantLib as ql\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nprint(\"🚀 Starting Key Rate Duration Analysis...\")\n\ntodaysDate = ql.Date(18, 8, 2020)\ntenor_tmp =[0, 1, 3, 6, 12, 24, 3*12, 5*12, 7*12, 10*12, 15*12, 20*12, 25*12, 30*12]\nspotDates = [ todaysDate + ql.Period(x,ql.Months) for x in tenor_tmp ]\nspotRates = [0.0, 0.005, 0.0075, 0.01, 0.012, 0.015, 0.018, 0.025, 0.03, 0.032, 0.035, 0.038, 0.0385, 0.0375]\ndayCount = ql.Thirty360()\ncalendar = ql.UnitedStates()\ninterpolation = ql.Linear()\ncompounding = ql.Compounded\ncompoundingFrequency = ql.Semiannual\n\nissueDate = ql.Date(18, 8, 2020)\nmaturityDate = ql.Date(18, 8, 2045)\ntenor = ql.Period(ql.Semiannual)\nbussinessConvention = ql.Unadjusted\ndateGeneration = ql.DateGeneration.Backward\nmonthEnd = False\nschedule = ql.Schedule (issueDate, maturityDate, tenor, calendar, bussinessConvention,\n                            bussinessConvention , dateGeneration, monthEnd)\n\n# Now lets build the coupon\ncouponRate1 = .05\ncoupons1 = [couponRate1]\n\n# Now lets construct the FixedRateBond\nsettlementDays = 0\nfaceValue = 100\nfixedRateBond1 = ql.FixedRateBond(settlementDays, faceValue, schedule, coupons1, dayCount)\n\nql.Settings.instance().evaluationDate = todaysDate\nspotCurve = ql.ZeroCurve(spotDates, spotRates, dayCount, calendar, interpolation,\n                             compounding, compoundingFrequency)\nspotCurveHandle = ql.RelinkableYieldTermStructureHandle(spotCurve)\n# create a bond engine with the term structure as input;\n# set the bond to use this bond engine\nbondEngine = ql.DiscountingBondEngine(spotCurveHandle)\nfixedRateBond1.setPricingEngine(bondEngine)\n\n# Finally the price\nP0 = fixedRateBond1.dirtyPrice()\nprint(f\"Base Bond Price (P0): ${P0:.4f}\")\n\nnodes = [ 0, 2, 5, 10, 20, 30 ]  # the durations\ndates = [ todaysDate + ql.Period(n,ql.Years) for n in nodes ]\nspreads = [ ql.SimpleQuote(0.0) for n in nodes ] # null spreads to begin\nnew_curve = ql.SpreadedLinearZeroInterpolatedTermStructure(\n    ql.YieldTermStructureHandle(spotCurve),\n    [ ql.QuoteHandle(q) for q in spreads ],\n    dates)\nspotCurveHandle.linkTo(new_curve)\nbondEngine = ql.DiscountingBondEngine(spotCurveHandle)\nfixedRateBond1.setPricingEngine(bondEngine)\n\ndelta_y = 0.005\nkey_rate_durations = []\nprice_changes_up = []\nprice_changes_down = []\nlabels = ['0-2Y', '5Y', '10Y', '20-30Y']\n\nprint(\"\\nCalculating nodal sensitivities...\")\n\nfor i in range(4):   \n    if i == 0: # 0-2Y\n        spreads[i].setValue(-delta_y) \n        spreads[i + 1].setValue(-delta_y) \n        p_dn = fixedRateBond1.dirtyPrice()\n        \n        spreads[i].setValue(delta_y) \n        spreads[i + 1].setValue(delta_y) \n        p_up = fixedRateBond1.dirtyPrice()\n        \n        duration = (p_dn - p_up)/(2*P0*delta_y) \n        key_rate_durations.append(duration)\n        price_changes_down.append(p_dn)\n        price_changes_up.append(p_up)\n        \n        print(f\"Node 0-2Y: P_dn={p_dn:.2f}, P_up={p_up:.2f}, KRD={duration:.4f}\")\n        \n        spreads[i].setValue(0) \n        spreads[i + 1].setValue(0) \n        \n    elif i == 3: # 20-30Y\n        spreads[i + 1].setValue(-delta_y) \n        spreads[i + 2].setValue(-delta_y) \n        p_dn = fixedRateBond1.dirtyPrice()\n        \n        spreads[i + 1].setValue(delta_y) \n        spreads[i + 2].setValue(delta_y) \n        p_up = fixedRateBond1.dirtyPrice() \n        \n        duration = (p_dn - p_up)/(2*P0*delta_y) \n        key_rate_durations.append(duration)\n        price_changes_down.append(p_dn)\n        price_changes_up.append(p_up)\n        \n        print(f\"Node 20-30Y: P_dn={p_dn:.2f}, P_up={p_up:.2f}, KRD={duration:.4f}\")\n        \n        spreads[i + 1].setValue(0.0) \n        spreads[i + 2].setValue(0.0) \n        \n    else: # 5Y, 10Y\n        spreads[i + 1].setValue(-delta_y) \n        p_dn = fixedRateBond1.dirtyPrice()\n        \n        spreads[i + 1].setValue(delta_y) \n        p_up = fixedRateBond1.dirtyPrice() \n        \n        duration = (p_dn - p_up)/(2*P0*delta_y) \n        key_rate_durations.append(duration)\n        price_changes_down.append(p_dn)\n        price_changes_up.append(p_up)\n        \n        node_name = \"5Y\" if i == 1 else \"10Y\"\n        print(f\"Node {node_name}: P_dn={p_dn:.2f}, P_up={p_up:.2f}, KRD={duration:.4f}\")\n        spreads[i + 1].setValue(0.0) \n\nprint(f\"\\nTotal Portfolio Key Rate Duration: {sum(key_rate_durations):.4f}\")\n\n# Visualization Section\nprint(\"\\n📊 Generating 2x2 comprehensive charts...\")\n\nfig, axes = plt.subplots(2, 2, figsize=(12, 9))\nplt.subplots_adjust(hspace=0.4, wspace=0.3, top=0.88)\n\n# Chart 1: KRD Bar Chart\nax1 = axes[0, 0]\nax1.bar(labels, key_rate_durations, color='#3498db', alpha=0.8, edgecolor='navy')\nax1.set_title('Key Rate Durations by Tenor', fontweight='bold')\nax1.set_ylabel('Duration Value')\nax1.grid(axis='y', linestyle='--', alpha=0.5)\n\n# Chart 2: Price Sensitivity\nax2 = axes[0, 1]\nx_indices = np.arange(len(labels))\nwidth = 0.35\nax2.bar(x_indices - width/2, price_changes_down, width, label='-50bp Shift', color='#2ecc71')\nax2.bar(x_indices + width/2, price_changes_up, width, label='+50bp Shift', color='#e74c3c')\nax2.axhline(y=P0, color='blue', linestyle='--', label='Base Price')\nax2.set_title('Bond Price Sensitivity', fontweight='bold')\nax2.set_xticks(x_indices)\nax2.set_xticklabels(labels)\nax2.set_ylabel('Price ($)')\nax2.set_ylim(min(price_changes_up)*0.98, max(price_changes_down)*1.02)\nax2.legend(loc='lower left', fontsize=8)\n\n# Chart 3: Cumulative Duration\nax3 = axes[1, 0]\nax3.plot(labels, np.cumsum(key_rate_durations), marker='o', color='purple', linewidth=2)\nax3.fill_between(labels, np.cumsum(key_rate_durations), color='purple', alpha=0.1)\nax3.set_title('Cumulative Duration Profile', fontweight='bold')\nax3.set_ylabel('Total Duration')\nax3.grid(True, alpha=0.3)\n\n# Chart 4: Percentage Price Change\nax4 = axes[1, 1]\npct_changes = [((dn - up) / (2 * P0)) * 100 for dn, up in zip(price_changes_down, price_changes_up)]\nax4.barh(labels, pct_changes, color='gold', edgecolor='black')\nax4.set_title('Price Change Percentage Sensitivity', fontweight='bold')\nax4.set_xlabel('Change (%)')\n\n# Final formatting\nfor ax in axes.flat:\n    ax.spines['right'].set_visible(False)\n    ax.spines['top'].set_visible(False)\n\nplt.suptitle(f'Comprehensive Key Rate Duration Analysis (Total KRD: {sum(key_rate_durations):.2f})', \n             fontsize=14, fontweight='bold')\nprint(\"✅ Visualization complete. Displaying figure...\")\nplt.show()\n"
      },
      {
        "id": "ex10",
        "title": "12.10 B1_Ch12_10.py",
        "filename": "B1_Ch12_10.py",
        "code": "# B1_Ch12_10.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport QuantLib as ql\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef value_bond(a, s, grid_points, bond):\n    model = ql.HullWhite(ts_handle, a, s)\n    engine = ql.TreeCallableFixedRateBondEngine(model, grid_points)\n    bond.setPricingEngine(engine)\n    return bond\n\ncalc_date = ql.Date(16,8,2016)\nql.Settings.instance().evaluationDate = calc_date\nday_count = ql.ActualActual(ql.ActualActual.Bond)\ncallability_schedule_call = ql.CallabilitySchedule()\ncallability_schedule_put = ql.CallabilitySchedule()\ncall_price = 100.0\ncall_date = ql.Date(15,ql.September,2016);\nnull_calendar = ql.NullCalendar();\nfor i in range(0,2):\n    callability_price  = ql.CallabilityPrice(\n        call_price, ql.CallabilityPrice.Clean)\n    callability_schedule_call.append(\n            ql.Callability(callability_price, \n                           ql.Callability.Call,\n                           call_date))\n    callability_schedule_put.append(\n            ql.Callability(callability_price, \n                           ql.Callability.Put,\n                           call_date))\n\n    call_date = null_calendar.advance(call_date, 12, ql.Months);\n    \nissue_date = ql.Date(16,ql.September,2015)        \nmaturity_date = ql.Date(15,ql.September,2017)\ncalendar = ql.UnitedStates(ql.UnitedStates.GovernmentBond)\ntenor = ql.Period(ql.Quarterly)\naccrual_convention = ql.Unadjusted\n\nschedule = ql.Schedule(issue_date, maturity_date, tenor,\n                       calendar, accrual_convention, accrual_convention,\n                       ql.DateGeneration.Backward, False)    \n\nsettlement_days = 0\nface_amount = 100\naccrual_daycount = ql.ActualActual(ql.ActualActual.Bond)\ncoupon = 0.0825\n\nbond = ql.FixedRateBond(\n    settlement_days, face_amount,\n    schedule, [coupon], accrual_daycount)\n\ncallable_bond = ql.CallableFixedRateBond(\n    settlement_days, face_amount,\n    schedule, [coupon], accrual_daycount,\n    ql.Following, face_amount, issue_date,\n    callability_schedule_call)\n\nputtable_bond = ql.CallableFixedRateBond(\n    settlement_days, face_amount,\n    schedule, [coupon], accrual_daycount,\n    ql.Following, face_amount, issue_date,\n    callability_schedule_put)\n\nrate = np.arange(0.0,0.18,0.001)\nbond_price = np.zeros(len(rate))\ncallable_bond_price = np.zeros(len(rate))\nputtable_bond_price = np.zeros(len(rate))\n\nfor i in range(len(rate)):\n    ts = ql.FlatForward(calc_date, \n                        rate[i], \n                        day_count, \n                        ql.Compounded, \n                        ql.Semiannual)\n    ts_handle = ql.YieldTermStructureHandle(ts)\n    \n    bondEngine = ql.DiscountingBondEngine(ts_handle)\n    bond.setPricingEngine(bondEngine)\n\n    callable_bond_price[i] = value_bond(0.03, 0.1, 80, callable_bond).cleanPrice()\n    puttable_bond_price[i] = value_bond(0.03, 0.1, 80, puttable_bond).cleanPrice()\n    bond_price[i] = bond.cleanPrice()\n\nplt.figure(1)    \nplt.plot(rate*100, bond_price)\nplt.plot(rate*100, callable_bond_price)\nplt.xlabel('Interest Rate (%)',fontsize=8)\nplt.ylabel('Bond Price ($)',fontsize=8)\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.gca().yaxis.set_ticks_position('left')\nplt.gca().xaxis.set_ticks_position('bottom')\n\nplt.figure(2)\nplt.plot(rate*100, bond_price)\nplt.plot(rate*100, puttable_bond_price)\nplt.xlabel('Interest Rate (%)',fontsize=8)\nplt.ylabel('Bond Price ($)',fontsize=8)\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.gca().yaxis.set_ticks_position('left')\nplt.gca().xaxis.set_ticks_position('bottom')\n\n\n"
      },
      {
        "id": "ex11",
        "title": "12.11 B1_Ch12_11.py",
        "filename": "B1_Ch12_11.py",
        "code": "# B1_Ch12_11.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport QuantLib as ql\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ntodaysDate = ql.Date(10, 7, 2017)\nql.Settings.instance().evaluationDate = todaysDate\ndayCount = ql.Thirty360()\ncalendar = ql.UnitedStates()\ninterpolation = ql.Linear()\ncompounding = ql.Compounded\ncompoundingFrequency = ql.Annual\n\nissueDate = ql.Date(15, 1, 2017)\nmaturityDate = ql.Date(15, 1, 2020)\ntenor = ql.Period(ql.Semiannual)\ncalendar = ql.UnitedStates()\nbussinessConvention = ql.Unadjusted\ndateGeneration = ql.DateGeneration.Backward\nmonthEnd = False\nschedule = ql.Schedule (issueDate, maturityDate, tenor, calendar, bussinessConvention,\n                            bussinessConvention , dateGeneration, monthEnd)\n\n# Now lets build the coupon\ndayCount = ql.Thirty360()\nytm = .1\n\n# Now lets construct the FixedRateBond\nsettlementDays = 3\nfaceValue = 100\n\ncouponRate = np.arange(0,0.2,0.01)\nduration_mod = np.zeros(len(couponRate))\ndirtyPrice = np.zeros(len(couponRate))\nconvexity = np.zeros(len(couponRate))\n\nfor i in range(len(couponRate)):\n    coupons = [couponRate[i]]\n    fixedRateBond = ql.FixedRateBond(settlementDays, faceValue, schedule, coupons, dayCount)\n    duration_mod[i] = ql.BondFunctions.duration(fixedRateBond,ytm,ql.ActualActual(), ql.Compounded, ql.Annual, ql.Duration.Modified)\n    convexity[i] = ql.BondFunctions.convexity(fixedRateBond,ytm,ql.ActualActual(), ql.Compounded, ql.Annual)\n    # cleanPrice[i] = fixedRateBond.cleanPrice(Coupon rate[i],fixedRateBond.dayCounter(), compounding, ql.Semiannual)\n    dirtyPrice[i] = fixedRateBond.dirtyPrice(ytm,fixedRateBond.dayCounter(), compounding, ql.Semiannual)\n    \nplt.figure(1)\nplt.subplot(311)    \nplt.plot(couponRate, dirtyPrice)\nplt.xlabel('Coupon rate',fontsize=8)\nplt.ylabel('Bond Price',fontsize=8)\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\n\nplt.subplot(312)    \nplt.plot(couponRate, duration_mod)\nplt.xlabel('Coupon rate',fontsize=8)\nplt.ylabel('Modified Duration',fontsize=8)\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\n\nplt.subplot(313)   \nplt.plot(couponRate, convexity)\nplt.xlabel('Coupon rate',fontsize=8)\nplt.ylabel('Convexity',fontsize=8)\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.subplots_adjust(hspace=0.5)\n"
      },
      {
        "id": "ex12",
        "title": "12.12 B1_Ch12_12.py",
        "filename": "B1_Ch12_12.py",
        "code": "# B1_Ch12_12.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport QuantLib as ql\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ntodaysDate = ql.Date(10, 7, 2017)\nql.Settings.instance().evaluationDate = todaysDate\ndayCount = ql.Thirty360()\ncalendar = ql.UnitedStates()\ninterpolation = ql.Linear()\ncompounding = ql.Compounded\ncompoundingFrequency = ql.Annual\n\nissueDate = ql.Date(15, 1, 2017)\nmaturityDate = ql.Date(15, 1, 2020)\ntenor = ql.Period(ql.Semiannual)\ncalendar = ql.UnitedStates()\nbussinessConvention = ql.Unadjusted\ndateGeneration = ql.DateGeneration.Backward\nmonthEnd = False\nschedule = ql.Schedule (issueDate, maturityDate, tenor, calendar, bussinessConvention,\n                            bussinessConvention , dateGeneration, monthEnd)\n\n# Now lets build the coupon\ndayCount = ql.Thirty360()\ncouponRate = .1\ncoupons = [couponRate]\n\n# Now lets construct the FixedRateBond\nsettlementDays = 3\nfaceValue = 100\nfixedRateBond = ql.FixedRateBond(settlementDays, faceValue, schedule, coupons, dayCount)\n\nytm = np.arange(0,0.2,0.01)\nduration_mod = np.zeros(len(ytm))\ndirtyPrice = np.zeros(len(ytm))\nconvexity = np.zeros(len(ytm))\n\nfor i in range(len(ytm)):\n    y=ytm[i]\n    duration_mod[i] = ql.BondFunctions.duration(fixedRateBond,y,ql.ActualActual(), ql.Compounded, ql.Annual, ql.Duration.Modified)\n    convexity[i] = ql.BondFunctions.convexity(fixedRateBond,y,ql.ActualActual(), ql.Compounded, ql.Annual)\n    dirtyPrice[i] = fixedRateBond.dirtyPrice(ytm[i],fixedRateBond.dayCounter(), compounding, ql.Semiannual)\n    \nplt.figure(1)\nplt.subplot(311)    \nplt.plot(ytm, dirtyPrice)\nplt.xlabel('Yield To Maturity',fontsize=8)\nplt.ylabel('Bond Price',fontsize=8)\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\n\nplt.subplot(312)    \nplt.plot(ytm, duration_mod)\nplt.xlabel('Yield To Maturity',fontsize=8)\nplt.ylabel('Modified Duration',fontsize=8)\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\n\nplt.subplot(313)   \nplt.plot(ytm, convexity)\nplt.xlabel('Yield To Maturity',fontsize=8)\nplt.ylabel('Convexity',fontsize=8)\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.subplots_adjust(hspace=0.5)\n"
      },
      {
        "id": "ex13",
        "title": "12.13 B1_Ch12_13.py",
        "filename": "B1_Ch12_13.py",
        "code": "# B1_Ch12_13.py\n\n###############\n# Prepared by Jianbin Liang, Ran An, and Wei Lu,\n# Editor-in-chief: Weisheng Jiang, and Sheng Tu\n# Book 1  |  Financial Risk Management with Python\n# Published and copyrighted by Tsinghua University Press\n# Beijing, China, 2021\n###############\n\nimport QuantLib as ql\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ntodaysDate = ql.Date(1, 7, 2020)\nql.Settings.instance().evaluationDate = todaysDate\ndayCount = ql.Thirty360()\ncalendar = ql.UnitedStates()\ninterpolation = ql.Linear()\ncompounding = ql.Compounded\ncompoundingFrequency = ql.Annual\n\nissueDate = ql.Date(1, 7, 2020)\nmaturityDate = ql.Date(15, 7, 2025)\n# maturityDate = advance('UnitedStates/GovernmentBond', as.Date('2020-01-15'), 10, 3)\ntenor = ql.Period(ql.Semiannual)\ncalendar = ql.UnitedStates()\nbussinessConvention = ql.Unadjusted\ndateGeneration = ql.DateGeneration.Backward\nmonthEnd = False\nschedule = ql.Schedule (issueDate, maturityDate, tenor, calendar, bussinessConvention,\n                            bussinessConvention , dateGeneration, monthEnd)\n\n# Now lets build the coupon\ndayCount = ql.Thirty360()\ncouponRate = .04\ncoupons = [couponRate]\n\n# Now lets construct the FixedRateBond\nsettlementDays = 3\nfaceValue = 100\nfixedRateBond = ql.FixedRateBond(settlementDays, faceValue, schedule, coupons, dayCount)\n\ndelta_y_base = 0.0001\nytm = np.arange(5.0,7.0,delta_y_base)*0.01\napproxPrice = np.zeros(len(ytm))\ndirtyPrice = np.zeros(len(ytm))\ndelta_y = np.zeros(len(ytm))\n\nP0 = fixedRateBond.dirtyPrice(0.06,fixedRateBond.dayCounter(), compounding, ql.Semiannual)\nP_up = fixedRateBond.dirtyPrice(0.060 + delta_y_base,fixedRateBond.dayCounter(), compounding, ql.Semiannual)\nP_down = fixedRateBond.dirtyPrice(0.060 - delta_y_base,fixedRateBond.dayCounter(), compounding, ql.Semiannual)\nduration = (P_down - P_up)/(2*P0*delta_y_base)\nconvexity = (P_down + P_up - 2*P0)/(P0*delta_y_base*delta_y_base)\n\nfor i in range(len(ytm)):\n    delta_y[i] = ytm[i] - 0.06\n    approxPrice[i] = P0*(1 - duration*delta_y[i] + 0.5*convexity*delta_y[i]*delta_y[i])\n    dirtyPrice[i] = fixedRateBond.dirtyPrice(ytm[i],fixedRateBond.dayCounter(), compounding, ql.Semiannual)\n    \nplt.figure(1)    \nplt.plot(ytm*100, dirtyPrice,label='Analytical',color = 'b')\nplt.plot(ytm*100, approxPrice,color ='r',label='Duration-convexity')\nplt.plot(6, P0,'x',color ='k',fillstyle='none',label='P0')\nplt.legend(loc='upper right')\nplt.xlabel('Yield, y(%)',fontsize=8)\nplt.ylabel('Dirty Price (USD)',fontsize=8)\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.gca().yaxis.set_ticks_position('left')\nplt.gca().xaxis.set_ticks_position('bottom')\n\nplt.figure(2) \nplt.plot(delta_y*10000, approxPrice-dirtyPrice,color ='b')\nplt.xlabel('Yield Shift, in bps',fontsize=8)\nplt.ylabel('Error (USD)',fontsize=8)\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.gca().yaxis.set_ticks_position('left')\nplt.gca().xaxis.set_ticks_position('bottom')\n"
      }
    ]
  }
]